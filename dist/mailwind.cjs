#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
const require$$1 = require("process");
const fs = require("fs");
const helpers$5 = require("yargs/helpers");
const yargs = require("yargs/yargs");
const os = require("os");
const path$1 = require("path");
const child_process = require("child_process");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var dist = {};
var bufferPolyfill = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output = [];
  for (var i = start; i < end2; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer[offset + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked2(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked2(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked2(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked2(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b)
      return 0;
    let x = a.length;
    let y2 = b.length;
    for (let i = 0, len = Math.min(x, y2); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y2 = b[i];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x = thisEnd - thisStart;
    let y2 = end2 - start;
    const len = Math.min(x, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer, val2, byteOffset, encoding, dir2) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir2 ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir2)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir2)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val2 === "string") {
      val2 = Buffer2.from(val2, encoding);
    }
    if (Buffer2.isBuffer(val2)) {
      if (val2.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val2, byteOffset, encoding, dir2);
    } else if (typeof val2 === "number") {
      val2 = val2 & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir2) {
          return Uint8Array.prototype.indexOf.call(buffer, val2, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val2, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val2], byteOffset, encoding, dir2);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val2, byteOffset, encoding, dir2) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val2.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val2.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir2) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val2, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val2, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val2, byteOffset, encoding) {
    return this.indexOf(val2, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val2, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end2) {
    if (start === 0 && end2 === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end2));
    }
  }
  function utf8Slice(buf, start, end2) {
    end2 = Math.min(buf.length, end2);
    const res = [];
    let i = start;
    while (i < end2) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end2) {
    let ret = "";
    end2 = Math.min(buf.length, end2);
    for (let i = start; i < end2; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end2) {
    let ret = "";
    end2 = Math.min(buf.length, end2);
    for (let i = start; i < end2; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end2) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len)
      end2 = len;
    let out = "";
    for (let i = start; i < end2; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end2) {
    const bytes = buf.slice(start, end2);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end2) {
    const len = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len : ~~end2;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end2 < 0) {
      end2 += len;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len) {
      end2 = len;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val2 = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val2 += this[offset + i] * mul;
    }
    return val2;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val2 = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val2 += this[offset + --byteLength3] * mul;
    }
    return val2;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val2 = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val2 += this[offset + i] * mul;
    }
    mul *= 128;
    if (val2 >= mul)
      val2 -= Math.pow(2, 8 * byteLength3);
    return val2;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val2 = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val2 += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val2 >= mul)
      val2 -= Math.pow(2, 8 * byteLength3);
    return val2;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val2 = this[offset] | this[offset + 1] << 8;
    return val2 & 32768 ? val2 | 4294901760 : val2;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val2 = this[offset + 1] | this[offset] << 8;
    return val2 & 32768 ? val2 | 4294901760 : val2;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val2 = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val2) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val2 = (first2 << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val2) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val2, start, end2, encoding) {
    if (typeof val2 === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val2.length === 1) {
        const code2 = val2.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val2 = code2;
        }
      }
    } else if (typeof val2 === "number") {
      val2 = val2 & 255;
    } else if (typeof val2 === "boolean") {
      val2 = Number(val2);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val2)
      val2 = 0;
    let i;
    if (typeof val2 === "number") {
      for (i = start; i < end2; ++i) {
        this[i] = val2;
      }
    } else {
      const bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
      }
      for (i = 0; i < end2 - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors2 = {};
  function E(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val2) {
    let res = "";
    let i = val2.length;
    const start = val2[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val2.slice(i - 3, i)}${res}`;
    }
    return `${val2.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(bufferPolyfill);
(function(exports2) {
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
  const t = bufferPolyfill, r = require$$1, o = (e) => e && e.__esModule ? e : { default: e }, l = o(r), u = globalThis || void 0 || self;
  Object.defineProperty(exports2, "Buffer", { enumerable: true, get: () => t.Buffer });
  Object.defineProperty(exports2, "process", { enumerable: true, get: () => l.default });
  exports2.global = u;
})(dist);
var cheerio$2 = { exports: {} };
var lib$l = {};
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
var load = {};
var options = {};
var __assign$b = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$b = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$b.apply(this, arguments);
};
Object.defineProperty(options, "__esModule", { value: true });
options.flatten = void 0;
var defaultOpts$1 = {
  xml: false,
  decodeEntities: true
};
options.default = defaultOpts$1;
var xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true
};
function flatten(options2) {
  return (options2 === null || options2 === void 0 ? void 0 : options2.xml) ? typeof options2.xml === "boolean" ? xmlModeDefault : __assign$b(__assign$b({}, xmlModeDefault), options2.xml) : options2 !== null && options2 !== void 0 ? options2 : void 0;
}
options.flatten = flatten;
var _static = {};
var lib$k = {};
var stringify$8 = {};
var lib$j = {};
var lib$i = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
  var ElementType2;
  (function(ElementType3) {
    ElementType3["Root"] = "root";
    ElementType3["Text"] = "text";
    ElementType3["Directive"] = "directive";
    ElementType3["Comment"] = "comment";
    ElementType3["Script"] = "script";
    ElementType3["Style"] = "style";
    ElementType3["Tag"] = "tag";
    ElementType3["CDATA"] = "cdata";
    ElementType3["Doctype"] = "doctype";
  })(ElementType2 = exports2.ElementType || (exports2.ElementType = {}));
  function isTag2(elem) {
    return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
  }
  exports2.isTag = isTag2;
  exports2.Root = ElementType2.Root;
  exports2.Text = ElementType2.Text;
  exports2.Directive = ElementType2.Directive;
  exports2.Comment = ElementType2.Comment;
  exports2.Script = ElementType2.Script;
  exports2.Style = ElementType2.Style;
  exports2.Tag = ElementType2.Tag;
  exports2.CDATA = ElementType2.CDATA;
  exports2.Doctype = ElementType2.Doctype;
})(lib$i);
var node$4 = {};
var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$a = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$a = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$a.apply(this, arguments);
};
Object.defineProperty(node$4, "__esModule", { value: true });
node$4.cloneNode = node$4.hasChildren = node$4.isDocument = node$4.isDirective = node$4.isComment = node$4.isText = node$4.isCDATA = node$4.isTag = node$4.Element = node$4.Document = node$4.CDATA = node$4.NodeWithChildren = node$4.ProcessingInstruction = node$4.Comment = node$4.Text = node$4.DataNode = node$4.Node = void 0;
var domelementtype_1$8 = lib$i;
var Node$4 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$4(this, recursive);
    };
    return Node2;
  }()
);
node$4.Node = Node$4;
var DataNode$4 = (
  /** @class */
  function(_super) {
    __extends$5(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$4)
);
node$4.DataNode = DataNode$4;
var Text$4 = (
  /** @class */
  function(_super) {
    __extends$5(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$4)
);
node$4.Text = Text$4;
var Comment$4 = (
  /** @class */
  function(_super) {
    __extends$5(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$4)
);
node$4.Comment = Comment$4;
var ProcessingInstruction$4 = (
  /** @class */
  function(_super) {
    __extends$5(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$8.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$4)
);
node$4.ProcessingInstruction = ProcessingInstruction$4;
var NodeWithChildren$4 = (
  /** @class */
  function(_super) {
    __extends$5(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$4)
);
node$4.NodeWithChildren = NodeWithChildren$4;
var CDATA$4 = (
  /** @class */
  function(_super) {
    __extends$5(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$4)
);
node$4.CDATA = CDATA$4;
var Document$4 = (
  /** @class */
  function(_super) {
    __extends$5(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$4)
);
node$4.Document = Document$4;
var Element$4 = (
  /** @class */
  function(_super) {
    __extends$5(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$8.ElementType.Script : name2 === "style" ? domelementtype_1$8.ElementType.Style : domelementtype_1$8.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$4)
);
node$4.Element = Element$4;
function isTag$4(node2) {
  return (0, domelementtype_1$8.isTag)(node2);
}
node$4.isTag = isTag$4;
function isCDATA$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.CDATA;
}
node$4.isCDATA = isCDATA$4;
function isText$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Text;
}
node$4.isText = isText$4;
function isComment$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Comment;
}
node$4.isComment = isComment$4;
function isDirective$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Directive;
}
node$4.isDirective = isDirective$4;
function isDocument$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Root;
}
node$4.isDocument = isDocument$4;
function hasChildren$4(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$4.hasChildren = hasChildren$4;
function cloneNode$4(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$4(node2)) {
    result = new Text$4(node2.data);
  } else if (isComment$4(node2)) {
    result = new Comment$4(node2.data);
  } else if (isTag$4(node2)) {
    var children = recursive ? cloneChildren$4(node2.children) : [];
    var clone_1 = new Element$4(node2.name, __assign$a({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$a({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$a({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$4(node2)) {
    var children = recursive ? cloneChildren$4(node2.children) : [];
    var clone_2 = new CDATA$4(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$4(node2)) {
    var children = recursive ? cloneChildren$4(node2.children) : [];
    var clone_3 = new Document$4(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$4(node2)) {
    var instruction = new ProcessingInstruction$4(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$4.cloneNode = cloneNode$4;
function cloneChildren$4(childs) {
  var children = childs.map(function(child) {
    return cloneNode$4(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$4;
  __exportStar(node$4, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$j);
var lib$h = {};
var lib$g = {};
var decode$4 = {};
var decodeDataHtml$4 = {};
Object.defineProperty(decodeDataHtml$4, "__esModule", { value: true });
decodeDataHtml$4.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decodeDataXml$4 = {};
Object.defineProperty(decodeDataXml$4, "__esModule", { value: true });
decodeDataXml$4.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decode_codepoint$4 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$4);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$4);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$4);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$4);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$4;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$4);
var encode$3 = {};
var encodeHtml$3 = {};
Object.defineProperty(encodeHtml$3, "__esModule", { value: true });
function restoreDiff$3(arr) {
  for (var i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
encodeHtml$3.default = new Map(/* @__PURE__ */ restoreDiff$3([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff$3([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff$3([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff$3([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c, index2) {
      return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$4);
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode$3, "__esModule", { value: true });
encode$3.encodeNonAsciiHTML = encode$3.encodeHTML = void 0;
var encode_html_js_1$3 = __importDefault$9(encodeHtml$3);
var escape_js_1$4 = _escape$4;
var htmlReplacer$3 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML$3(data2) {
  return encodeHTMLTrieRe$3(htmlReplacer$3, data2);
}
encode$3.encodeHTML = encodeHTML$3;
function encodeNonAsciiHTML$3(data2) {
  return encodeHTMLTrieRe$3(escape_js_1$4.xmlReplacer, data2);
}
encode$3.encodeNonAsciiHTML = encodeNonAsciiHTML$3;
function encodeHTMLTrieRe$3(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i = match.index;
    ret += str.substring(lastIdx, i);
    var char = str.charCodeAt(i);
    var next = encode_html_js_1$3.default.get(char);
    if (typeof next === "object") {
      if (i + 1 < str.length) {
        var nextChar = str.charCodeAt(i + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i + 1;
    } else {
      var cp = (0, escape_js_1$4.getCodePoint)(str, i);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode$4;
  var encode_js_1 = encode$3;
  var escape_js_12 = _escape$4;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode2;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode2(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode2;
  var escape_js_2 = _escape$4;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode$3;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode$4;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib$g);
var foreignNames$3 = {};
Object.defineProperty(foreignNames$3, "__esModule", { value: true });
foreignNames$3.attributeNames = foreignNames$3.elementNames = void 0;
foreignNames$3.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames$3.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign$9 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$9 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$9.apply(this, arguments);
};
var __createBinding$9 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$9 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$9 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$9(result, mod, k);
  }
  __setModuleDefault$9(result, mod);
  return result;
};
Object.defineProperty(lib$h, "__esModule", { value: true });
lib$h.render = void 0;
var ElementType$3 = __importStar$9(lib$i);
var entities_1$3 = lib$g;
var foreignNames_js_1$3 = foreignNames$3;
var unencodedElements$3 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes$3(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes$3(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes$3 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1$3.encodeXML : entities_1$3.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1$3.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag$3 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$4(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i = 0; i < nodes.length; i++) {
    output += renderNode$3(nodes[i], options2);
  }
  return output;
}
lib$h.render = render$4;
lib$h.default = render$4;
function renderNode$3(node2, options2) {
  switch (node2.type) {
    case ElementType$3.Root:
      return render$4(node2.children, options2);
    case ElementType$3.Doctype:
    case ElementType$3.Directive:
      return renderDirective$3(node2);
    case ElementType$3.Comment:
      return renderComment$3(node2);
    case ElementType$3.CDATA:
      return renderCdata$3(node2);
    case ElementType$3.Script:
    case ElementType$3.Style:
    case ElementType$3.Tag:
      return renderTag$3(node2, options2);
    case ElementType$3.Text:
      return renderText$3(node2, options2);
  }
}
var foreignModeIntegrationPoints$3 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements$3 = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$3(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1$3.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints$3.has(elem.parent.name)) {
      opts = __assign$9(__assign$9({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$3.has(elem.name)) {
    opts = __assign$9(__assign$9({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$3(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$3.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$4(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$3.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$3(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$3(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$3.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1$3.encodeXML)(data2) : (0, entities_1$3.escapeText)(data2);
  }
  return data2;
}
function renderCdata$3(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$3(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$8, "__esModule", { value: true });
stringify$8.innerText = stringify$8.textContent = stringify$8.getText = stringify$8.getInnerHTML = stringify$8.getOuterHTML = void 0;
var domhandler_1$j = lib$j;
var dom_serializer_1$3 = __importDefault$8(lib$h);
var domelementtype_1$7 = lib$i;
function getOuterHTML$3(node2, options2) {
  return (0, dom_serializer_1$3.default)(node2, options2);
}
stringify$8.getOuterHTML = getOuterHTML$3;
function getInnerHTML$3(node2, options2) {
  return (0, domhandler_1$j.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML$3(node3, options2);
  }).join("") : "";
}
stringify$8.getInnerHTML = getInnerHTML$3;
function getText$3(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$3).join("");
  if ((0, domhandler_1$j.isTag)(node2))
    return node2.name === "br" ? "\n" : getText$3(node2.children);
  if ((0, domhandler_1$j.isCDATA)(node2))
    return getText$3(node2.children);
  if ((0, domhandler_1$j.isText)(node2))
    return node2.data;
  return "";
}
stringify$8.getText = getText$3;
function textContent$3(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent$3).join("");
  if ((0, domhandler_1$j.hasChildren)(node2) && !(0, domhandler_1$j.isComment)(node2)) {
    return textContent$3(node2.children);
  }
  if ((0, domhandler_1$j.isText)(node2))
    return node2.data;
  return "";
}
stringify$8.textContent = textContent$3;
function innerText$3(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText$3).join("");
  if ((0, domhandler_1$j.hasChildren)(node2) && (node2.type === domelementtype_1$7.ElementType.Tag || (0, domhandler_1$j.isCDATA)(node2))) {
    return innerText$3(node2.children);
  }
  if ((0, domhandler_1$j.isText)(node2))
    return node2.data;
  return "";
}
stringify$8.innerText = innerText$3;
var traversal$3 = {};
Object.defineProperty(traversal$3, "__esModule", { value: true });
traversal$3.prevElementSibling = traversal$3.nextElementSibling = traversal$3.getName = traversal$3.hasAttrib = traversal$3.getAttributeValue = traversal$3.getSiblings = traversal$3.getParent = traversal$3.getChildren = void 0;
var domhandler_1$i = lib$j;
function getChildren$3(elem) {
  return (0, domhandler_1$i.hasChildren)(elem) ? elem.children : [];
}
traversal$3.getChildren = getChildren$3;
function getParent$3(elem) {
  return elem.parent || null;
}
traversal$3.getParent = getParent$3;
function getSiblings$3(elem) {
  var _a, _b;
  var parent = getParent$3(elem);
  if (parent != null)
    return getChildren$3(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal$3.getSiblings = getSiblings$3;
function getAttributeValue$3(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal$3.getAttributeValue = getAttributeValue$3;
function hasAttrib$3(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal$3.hasAttrib = hasAttrib$3;
function getName$3(elem) {
  return elem.name;
}
traversal$3.getName = getName$3;
function nextElementSibling$3(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$i.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal$3.nextElementSibling = nextElementSibling$3;
function prevElementSibling$3(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$i.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal$3.prevElementSibling = prevElementSibling$3;
var manipulation$4 = {};
Object.defineProperty(manipulation$4, "__esModule", { value: true });
manipulation$4.prepend = manipulation$4.prependChild = manipulation$4.append = manipulation$4.appendChild = manipulation$4.replaceElement = manipulation$4.removeElement = void 0;
function removeElement$3(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation$4.removeElement = removeElement$3;
function replaceElement$3(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation$4.replaceElement = replaceElement$3;
function appendChild$3(parent, child) {
  removeElement$3(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation$4.appendChild = appendChild$3;
function append$3(elem, next) {
  removeElement$3(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation$4.append = append$3;
function prependChild$3(parent, child) {
  removeElement$3(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation$4.prependChild = prependChild$3;
function prepend$3(elem, prev) {
  removeElement$3(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation$4.prepend = prepend$3;
var querying$3 = {};
Object.defineProperty(querying$3, "__esModule", { value: true });
querying$3.findAll = querying$3.existsOne = querying$3.findOne = querying$3.findOneChild = querying$3.find = querying$3.filter = void 0;
var domhandler_1$h = lib$j;
function filter$4(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$5(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying$3.filter = filter$4;
function find$5(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$h.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$3.find = find$5;
function findOneChild$3(test2, nodes) {
  return nodes.find(test2);
}
querying$3.findOneChild = findOneChild$3;
function findOne$3(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i = 0; i < nodes.length && !elem; i++) {
    var node2 = nodes[i];
    if (!(0, domhandler_1$h.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne$3(test2, node2.children, true);
    }
  }
  return elem;
}
querying$3.findOne = findOne$3;
function existsOne$3(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$h.isTag)(checked2) && (test2(checked2) || existsOne$3(test2, checked2.children));
  });
}
querying$3.existsOne = existsOne$3;
function findAll$3(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$h.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$3.findAll = findAll$3;
var legacy$3 = {};
Object.defineProperty(legacy$3, "__esModule", { value: true });
legacy$3.getElementsByTagType = legacy$3.getElementsByTagName = legacy$3.getElementById = legacy$3.getElements = legacy$3.testElement = void 0;
var domhandler_1$g = lib$j;
var querying_js_1$3 = querying$3;
var Checks$3 = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1$g.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1$g.isTag;
    }
    return function(elem) {
      return (0, domhandler_1$g.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1$g.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1$g.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck$3(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1$g.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1$g.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs$3(a, b) {
  return function(elem) {
    return a(elem) || b(elem);
  };
}
function compileTest$3(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks$3, key2) ? Checks$3[key2](value) : getAttribCheck$3(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$3);
}
function testElement$3(options2, node2) {
  var test2 = compileTest$3(options2);
  return test2 ? test2(node2) : true;
}
legacy$3.testElement = testElement$3;
function getElements$3(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest$3(options2);
  return test2 ? (0, querying_js_1$3.filter)(test2, nodes, recurse, limit) : [];
}
legacy$3.getElements = getElements$3;
function getElementById$3(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1$3.findOne)(getAttribCheck$3("id", id2), nodes, recurse);
}
legacy$3.getElementById = getElementById$3;
function getElementsByTagName$3(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$3.filter)(Checks$3["tag_name"](tagName), nodes, recurse, limit);
}
legacy$3.getElementsByTagName = getElementsByTagName$3;
function getElementsByTagType$3(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$3.filter)(Checks$3["tag_type"](type), nodes, recurse, limit);
}
legacy$3.getElementsByTagType = getElementsByTagType$3;
var helpers$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$j;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i, arr) {
      return !arr.includes(node2, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers$4);
var feeds$3 = {};
Object.defineProperty(feeds$3, "__esModule", { value: true });
feeds$3.getFeed = void 0;
var stringify_js_1$3 = stringify$8;
var legacy_js_1$3 = legacy$3;
function getFeed$3(doc) {
  var feedRoot = getOneElement$3(isValidFeed$3, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed$3(feedRoot) : getRssFeed$3(feedRoot);
}
feeds$3.getFeed = getFeed$3;
function getAtomFeed$3(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1$3.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements$3(children) };
      addConditionally$3(entry, "id", "id", children);
      addConditionally$3(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement$3("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$3("summary", children) || fetch$3("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$3("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally$3(feed, "id", "id", childs);
  addConditionally$3(feed, "title", "title", childs);
  var href = (_a = getOneElement$3("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$3(feed, "description", "subtitle", childs);
  var updated = fetch$3("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$3(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed$3(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement$3("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1$3.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements$3(children) };
      addConditionally$3(entry, "id", "guid", children);
      addConditionally$3(entry, "title", "title", children);
      addConditionally$3(entry, "link", "link", children);
      addConditionally$3(entry, "description", "description", children);
      var pubDate = fetch$3("pubDate", children) || fetch$3("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally$3(feed, "title", "title", childs);
  addConditionally$3(feed, "link", "link", childs);
  addConditionally$3(feed, "description", "description", childs);
  var updated = fetch$3("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$3(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING$3 = ["url", "type", "lang"];
var MEDIA_KEYS_INT$3 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements$3(where) {
  return (0, legacy_js_1$3.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING$3; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT$3; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement$3(tagName, node2) {
  return (0, legacy_js_1$3.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$3(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1$3.textContent)((0, legacy_js_1$3.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally$3(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch$3(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed$3(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$8, exports2);
  __exportStar(traversal$3, exports2);
  __exportStar(manipulation$4, exports2);
  __exportStar(querying$3, exports2);
  __exportStar(legacy$3, exports2);
  __exportStar(helpers$4, exports2);
  __exportStar(feeds$3, exports2);
  var domhandler_12 = lib$j;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$k);
var __assign$8 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$8 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$8.apply(this, arguments);
};
var __createBinding$8 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$8 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$8 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$8(result, mod, k);
  }
  __setModuleDefault$8(result, mod);
  return result;
};
Object.defineProperty(_static, "__esModule", { value: true });
_static.merge = _static.contains = _static.root = _static.parseHTML = _static.text = _static.xml = _static.html = void 0;
var domutils_1$4 = lib$k;
var options_js_1$1 = __importStar$8(options);
function render$3(that, dom, options2) {
  if (!that)
    return "";
  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options2).toString();
}
function isOptions(dom, options2) {
  return !options2 && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
}
function html$6(dom, options2) {
  var toRender = isOptions(dom) ? (options2 = dom, void 0) : dom;
  var opts = __assign$8(__assign$8(__assign$8({}, options_js_1$1.default), this === null || this === void 0 ? void 0 : this._options), (0, options_js_1$1.flatten)(options2 !== null && options2 !== void 0 ? options2 : {}));
  return render$3(this, toRender, opts);
}
_static.html = html$6;
function xml$1(dom) {
  var options2 = __assign$8(__assign$8({}, this._options), { xmlMode: true });
  return render$3(this, dom, options2);
}
_static.xml = xml$1;
function text$2(elements) {
  var elems = elements ? elements : this ? this.root() : [];
  var ret = "";
  for (var i = 0; i < elems.length; i++) {
    ret += (0, domutils_1$4.textContent)(elems[i]);
  }
  return ret;
}
_static.text = text$2;
function parseHTML(data2, context, keepScripts) {
  if (keepScripts === void 0) {
    keepScripts = typeof context === "boolean" ? context : false;
  }
  if (!data2 || typeof data2 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  var parsed = this.load(data2, options_js_1$1.default, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return parsed.root()[0].children.slice();
}
_static.parseHTML = parseHTML;
function root$2() {
  return this(this._root);
}
_static.root = root$2;
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  var next = contained;
  while (next && next !== next.parent) {
    next = next.parent;
    if (next === container) {
      return true;
    }
  }
  return false;
}
_static.contains = contains;
function merge$1(arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  var newLength = arr1.length;
  var len = +arr2.length;
  for (var i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
}
_static.merge = merge$1;
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (var i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}
var cheerio$1 = {};
var attributes$3 = {};
var utils$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isHtml = exports2.cloneDom = exports2.domEach = exports2.cssCase = exports2.camelCase = exports2.isCheerio = exports2.isTag = void 0;
  var domhandler_12 = lib$j;
  var domhandler_2 = lib$j;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_2.isTag;
  } });
  function isCheerio(maybeCheerio) {
    return maybeCheerio.cheerio != null;
  }
  exports2.isCheerio = isCheerio;
  function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function(_, x) {
      return x.toUpperCase();
    });
  }
  exports2.camelCase = camelCase;
  function cssCase(str) {
    return str.replace(/[A-Z]/g, "-$&").toLowerCase();
  }
  exports2.cssCase = cssCase;
  function domEach(array, fn) {
    var len = array.length;
    for (var i = 0; i < len; i++)
      fn(array[i], i);
    return array;
  }
  exports2.domEach = domEach;
  function cloneDom(dom) {
    var clone2 = "length" in dom ? Array.prototype.map.call(dom, function(el) {
      return (0, domhandler_12.cloneNode)(el, true);
    }) : [(0, domhandler_12.cloneNode)(dom, true)];
    var root2 = new domhandler_12.Document(clone2);
    clone2.forEach(function(node2) {
      node2.parent = root2;
    });
    return clone2;
  }
  exports2.cloneDom = cloneDom;
  var CharacterCodes;
  (function(CharacterCodes2) {
    CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
    CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
    CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
    CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
    CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
  })(CharacterCodes || (CharacterCodes = {}));
  function isHtml(str) {
    var tagStart = str.indexOf("<");
    if (tagStart < 0 || tagStart > str.length - 3)
      return false;
    var tagChar = str.charCodeAt(tagStart + 1);
    return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
  }
  exports2.isHtml = isHtml;
})(utils$2);
Object.defineProperty(attributes$3, "__esModule", { value: true });
attributes$3.toggleClass = attributes$3.removeClass = attributes$3.addClass = attributes$3.hasClass = attributes$3.removeAttr = attributes$3.val = attributes$3.data = attributes$3.prop = attributes$3.attr = void 0;
var static_js_1$2 = _static;
var utils_js_1$5 = utils$2;
var domutils_1$3 = lib$k;
var hasOwn$1 = Object.prototype.hasOwnProperty;
var rspace = /\s+/;
var dataAttrPrefix = "data-";
var primitives = {
  null: null,
  true: true,
  false: false
};
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name2, xmlMode) {
  var _a;
  if (!elem || !(0, utils_js_1$5.isTag)(elem))
    return void 0;
  (_a = elem.attribs) !== null && _a !== void 0 ? _a : elem.attribs = {};
  if (!name2) {
    return elem.attribs;
  }
  if (hasOwn$1.call(elem.attribs, name2)) {
    return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
  }
  if (elem.name === "option" && name2 === "value") {
    return (0, static_js_1$2.text)(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name2, value) {
  if (value === null) {
    removeAttribute(el, name2);
  } else {
    el.attribs[name2] = "".concat(value);
  }
}
function attr(name2, value) {
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return (0, utils_js_1$5.domEach)(this, function(el, i) {
        if ((0, utils_js_1$5.isTag)(el))
          setAttr(el, name2, value.call(el, i, el.attribs[name2]));
      });
    }
    return (0, utils_js_1$5.domEach)(this, function(el) {
      if (!(0, utils_js_1$5.isTag)(el))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach(function(objName) {
          var objValue = name2[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name2, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
}
attributes$3.attr = attr;
function getProp(el, name2, xmlMode) {
  return name2 in el ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el[name2]
  ) : !xmlMode && rboolean.test(name2) ? getAttr(el, name2, false) !== void 0 : getAttr(el, name2, xmlMode);
}
function setProp(el, name2, value, xmlMode) {
  if (name2 in el) {
    el[name2] = value;
  } else {
    setAttr(el, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : "".concat(value));
  }
}
function prop(name2, value) {
  var _this = this;
  var _a;
  if (typeof name2 === "string" && value === void 0) {
    var el = this[0];
    if (!el || !(0, utils_js_1$5.isTag)(el))
      return void 0;
    switch (name2) {
      case "style": {
        var property_1 = this.css();
        var keys = Object.keys(property_1);
        keys.forEach(function(p2, i) {
          property_1[i] = p2;
        });
        property_1.length = keys.length;
        return property_1;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        var prop_1 = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name2];
        if (typeof URL !== "undefined" && (name2 === "href" && (el.tagName === "a" || el.name === "link") || name2 === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop_1 !== void 0 && this.options.baseURI) {
          return new URL(prop_1, this.options.baseURI).href;
        }
        return prop_1;
      }
      case "innerText": {
        return (0, domutils_1$3.innerText)(el);
      }
      case "textContent": {
        return (0, domutils_1$3.textContent)(el);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el, name2, this.options.xmlMode);
    }
  }
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return (0, utils_js_1$5.domEach)(this, function(el2, i) {
        if ((0, utils_js_1$5.isTag)(el2)) {
          setProp(el2, name2, value.call(el2, i, getProp(el2, name2, _this.options.xmlMode)), _this.options.xmlMode);
        }
      });
    }
    return (0, utils_js_1$5.domEach)(this, function(el2) {
      if (!(0, utils_js_1$5.isTag)(el2))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach(function(key2) {
          var val2 = name2[key2];
          setProp(el2, key2, val2, _this.options.xmlMode);
        });
      } else {
        setProp(el2, name2, value, _this.options.xmlMode);
      }
    });
  }
  return void 0;
}
attributes$3.prop = prop;
function setData(el, name2, value) {
  var _a;
  var elem = el;
  (_a = elem.data) !== null && _a !== void 0 ? _a : elem.data = {};
  if (typeof name2 === "object")
    Object.assign(elem.data, name2);
  else if (typeof name2 === "string" && value !== void 0) {
    elem.data[name2] = value;
  }
}
function readData(el, name2) {
  var domNames;
  var jsNames;
  var value;
  if (name2 == null) {
    domNames = Object.keys(el.attribs).filter(function(attrName) {
      return attrName.startsWith(dataAttrPrefix);
    });
    jsNames = domNames.map(function(domName2) {
      return (0, utils_js_1$5.camelCase)(domName2.slice(dataAttrPrefix.length));
    });
  } else {
    domNames = [dataAttrPrefix + (0, utils_js_1$5.cssCase)(name2)];
    jsNames = [name2];
  }
  for (var idx = 0; idx < domNames.length; ++idx) {
    var domName = domNames[idx];
    var jsName = jsNames[idx];
    if (hasOwn$1.call(el.attribs, domName) && !hasOwn$1.call(el.data, jsName)) {
      value = el.attribs[domName];
      if (hasOwn$1.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
        }
      }
      el.data[jsName] = value;
    }
  }
  return name2 == null ? el.data : value;
}
function data(name2, value) {
  var _a;
  var elem = this[0];
  if (!elem || !(0, utils_js_1$5.isTag)(elem))
    return;
  var dataEl = elem;
  (_a = dataEl.data) !== null && _a !== void 0 ? _a : dataEl.data = {};
  if (!name2) {
    return readData(dataEl);
  }
  if (typeof name2 === "object" || value !== void 0) {
    (0, utils_js_1$5.domEach)(this, function(el) {
      if ((0, utils_js_1$5.isTag)(el)) {
        if (typeof name2 === "object")
          setData(el, name2);
        else
          setData(el, name2, value);
      }
    });
    return this;
  }
  if (hasOwn$1.call(dataEl.data, name2)) {
    return dataEl.data[name2];
  }
  return readData(dataEl, name2);
}
attributes$3.data = data;
function val(value) {
  var querying2 = arguments.length === 0;
  var element2 = this[0];
  if (!element2 || !(0, utils_js_1$5.isTag)(element2))
    return querying2 ? void 0 : this;
  switch (element2.name) {
    case "textarea":
      return this.text(value);
    case "select": {
      var option2 = this.find("option:selected");
      if (!querying2) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        var values = typeof value !== "object" ? [value] : value;
        for (var i = 0; i < values.length; i++) {
          this.find('option[value="'.concat(values[i], '"]')).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option2.toArray().map(function(el) {
        return (0, static_js_1$2.text)(el.children);
      }) : option2.attr("value");
    }
    case "input":
    case "option":
      return querying2 ? this.attr("value") : this.attr("value", value);
  }
  return void 0;
}
attributes$3.val = val;
function removeAttribute(elem, name2) {
  if (!elem.attribs || !hasOwn$1.call(elem.attribs, name2))
    return;
  delete elem.attribs[name2];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name2) {
  var attrNames = splitNames(name2);
  var _loop_1 = function(i2) {
    (0, utils_js_1$5.domEach)(this_1, function(elem) {
      if ((0, utils_js_1$5.isTag)(elem))
        removeAttribute(elem, attrNames[i2]);
    });
  };
  var this_1 = this;
  for (var i = 0; i < attrNames.length; i++) {
    _loop_1(i);
  }
  return this;
}
attributes$3.removeAttr = removeAttr;
function hasClass(className2) {
  return this.toArray().some(function(elem) {
    var clazz = (0, utils_js_1$5.isTag)(elem) && elem.attribs["class"];
    var idx = -1;
    if (clazz && className2.length) {
      while ((idx = clazz.indexOf(className2, idx + 1)) > -1) {
        var end2 = idx + className2.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
attributes$3.hasClass = hasClass;
function addClass(value) {
  if (typeof value === "function") {
    return (0, utils_js_1$5.domEach)(this, function(el2, i2) {
      if ((0, utils_js_1$5.isTag)(el2)) {
        var className3 = el2.attribs["class"] || "";
        addClass.call([el2], value.call(el2, i2, className3));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  var classNames = value.split(rspace);
  var numElements = this.length;
  for (var i = 0; i < numElements; i++) {
    var el = this[i];
    if (!(0, utils_js_1$5.isTag)(el))
      continue;
    var className2 = getAttr(el, "class", false);
    if (!className2) {
      setAttr(el, "class", classNames.join(" ").trim());
    } else {
      var setClass = " ".concat(className2, " ");
      for (var j = 0; j < classNames.length; j++) {
        var appendClass = "".concat(classNames[j], " ");
        if (!setClass.includes(" ".concat(appendClass)))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    }
  }
  return this;
}
attributes$3.addClass = addClass;
function removeClass(name2) {
  if (typeof name2 === "function") {
    return (0, utils_js_1$5.domEach)(this, function(el, i) {
      if ((0, utils_js_1$5.isTag)(el)) {
        removeClass.call([el], name2.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  var classes = splitNames(name2);
  var numClasses = classes.length;
  var removeAll = arguments.length === 0;
  return (0, utils_js_1$5.domEach)(this, function(el) {
    if (!(0, utils_js_1$5.isTag)(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      var elClasses = splitNames(el.attribs["class"]);
      var changed = false;
      for (var j = 0; j < numClasses; j++) {
        var index2 = elClasses.indexOf(classes[j]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
attributes$3.removeClass = removeClass;
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return (0, utils_js_1$5.domEach)(this, function(el2, i2) {
      if ((0, utils_js_1$5.isTag)(el2)) {
        toggleClass.call([el2], value.call(el2, i2, el2.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  var classNames = value.split(rspace);
  var numClasses = classNames.length;
  var state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  var numElements = this.length;
  for (var i = 0; i < numElements; i++) {
    var el = this[i];
    if (!(0, utils_js_1$5.isTag)(el))
      continue;
    var elementClasses = splitNames(el.attribs["class"]);
    for (var j = 0; j < numClasses; j++) {
      var index2 = elementClasses.indexOf(classNames[j]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}
attributes$3.toggleClass = toggleClass;
var traversing = {};
var lib$f = {};
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
const IgnoreCaseMode = {
  Unknown: null,
  QuirksMode: "quirks",
  IgnoreCase: true,
  CaseSensitive: false
};
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
const unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal$1(selector2) {
  switch (selector2.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace$1(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse$7(selector2) {
  const subselects2 = [];
  const endIndex = parseSelector$1(subselects2, `${selector2}`, 0);
  if (endIndex < selector2.length) {
    throw new Error(`Unmatched selector: ${selector2.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector$1(subselects2, selector2, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match = selector2.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector2.slice(selectorIndex)}`);
    }
    const [name2] = match;
    selectorIndex += offset + name2.length;
    return unescapeCSS(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector2.length && isWhitespace$1(selector2.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector2.length; selectorIndex++) {
      if (selector2.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector2.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector2.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector2.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector2.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector2.length) {
      const firstChar = selector2.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace = null;
          if (selector2.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector2.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector2.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector2.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector2.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector2.charCodeAt(selectorIndex))) {
              const quote = selector2.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector2.length && (selector2.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector2.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector2.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector2.length && (!isWhitespace$1(selector2.charCodeAt(selectorIndex)) && selector2.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector2.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector2.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector2.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector2.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector2.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector2.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name2)) {
              if (isQuote(selector2.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector$1(data2, selector2, selectorIndex + 1);
              if (selector2.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector2})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name2)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector2.startsWith("/*", selectorIndex)) {
            const endIndex = selector2.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector2.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector2.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name2;
            if (selector2.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInName = new Set([
  ...pseudoValChars,
  "~",
  "^",
  "$",
  "*",
  "+",
  "!",
  "|",
  ":",
  "[",
  "]",
  " ",
  "."
].map((c) => c.charCodeAt(0)));
function stringify$7(selector2) {
  return selector2.map((token2) => token2.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token2, index2, arr) {
  switch (token2.type) {
    case SelectorType.Child:
      return index2 === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index2 === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index2 === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index2 === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index2 === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      return token2.namespace === "*" && index2 + 1 < arr.length && "name" in arr[index2 + 1] ? "" : `${getNamespace(token2.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token2);
    case SelectorType.PseudoElement:
      return `::${escapeName(token2.name, charsToEscapeInName)}${token2.data === null ? "" : `(${escapeName(token2.data, charsToEscapeInPseudoValue)})`}`;
    case SelectorType.Pseudo:
      return `:${escapeName(token2.name, charsToEscapeInName)}${token2.data === null ? "" : `(${typeof token2.data === "string" ? escapeName(token2.data, charsToEscapeInPseudoValue) : stringify$7(token2.data)})`}`;
    case SelectorType.Attribute: {
      if (token2.name === "id" && token2.action === AttributeAction.Equals && token2.ignoreCase === "quirks" && !token2.namespace) {
        return `#${escapeName(token2.value, charsToEscapeInName)}`;
      }
      if (token2.name === "class" && token2.action === AttributeAction.Element && token2.ignoreCase === "quirks" && !token2.namespace) {
        return `.${escapeName(token2.value, charsToEscapeInName)}`;
      }
      const name2 = getNamespacedName(token2);
      if (token2.action === AttributeAction.Exists) {
        return `[${name2}]`;
      }
      return `[${name2}${getActionValue(token2.action)}="${escapeName(token2.value, charsToEscapeInAttributeValue)}"${token2.ignoreCase === null ? "" : token2.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token2) {
  return `${getNamespace(token2.namespace)}${escapeName(token2.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|` : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i = 0; i < str.length; i++) {
    if (charsToEscape.has(str.charCodeAt(i))) {
      ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
      lastIdx = i + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get AttributeAction() {
    return AttributeAction;
  },
  IgnoreCaseMode,
  get SelectorType() {
    return SelectorType;
  },
  isTraversal: isTraversal$1,
  parse: parse$7,
  stringify: stringify$7
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(es);
var lib$e = {};
var lib$d = {};
var stringify$6 = {};
var lib$c = {};
var node$3 = {};
var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$7 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$7 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$7.apply(this, arguments);
};
Object.defineProperty(node$3, "__esModule", { value: true });
node$3.cloneNode = node$3.hasChildren = node$3.isDocument = node$3.isDirective = node$3.isComment = node$3.isText = node$3.isCDATA = node$3.isTag = node$3.Element = node$3.Document = node$3.CDATA = node$3.NodeWithChildren = node$3.ProcessingInstruction = node$3.Comment = node$3.Text = node$3.DataNode = node$3.Node = void 0;
var domelementtype_1$6 = lib$i;
var Node$3 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$3(this, recursive);
    };
    return Node2;
  }()
);
node$3.Node = Node$3;
var DataNode$3 = (
  /** @class */
  function(_super) {
    __extends$4(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$3)
);
node$3.DataNode = DataNode$3;
var Text$3 = (
  /** @class */
  function(_super) {
    __extends$4(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$3)
);
node$3.Text = Text$3;
var Comment$3 = (
  /** @class */
  function(_super) {
    __extends$4(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$3)
);
node$3.Comment = Comment$3;
var ProcessingInstruction$3 = (
  /** @class */
  function(_super) {
    __extends$4(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$6.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$3)
);
node$3.ProcessingInstruction = ProcessingInstruction$3;
var NodeWithChildren$3 = (
  /** @class */
  function(_super) {
    __extends$4(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$3)
);
node$3.NodeWithChildren = NodeWithChildren$3;
var CDATA$3 = (
  /** @class */
  function(_super) {
    __extends$4(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$3)
);
node$3.CDATA = CDATA$3;
var Document$3 = (
  /** @class */
  function(_super) {
    __extends$4(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$3)
);
node$3.Document = Document$3;
var Element$3 = (
  /** @class */
  function(_super) {
    __extends$4(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$6.ElementType.Script : name2 === "style" ? domelementtype_1$6.ElementType.Style : domelementtype_1$6.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$3)
);
node$3.Element = Element$3;
function isTag$3(node2) {
  return (0, domelementtype_1$6.isTag)(node2);
}
node$3.isTag = isTag$3;
function isCDATA$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.CDATA;
}
node$3.isCDATA = isCDATA$3;
function isText$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Text;
}
node$3.isText = isText$3;
function isComment$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Comment;
}
node$3.isComment = isComment$3;
function isDirective$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Directive;
}
node$3.isDirective = isDirective$3;
function isDocument$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Root;
}
node$3.isDocument = isDocument$3;
function hasChildren$3(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$3.hasChildren = hasChildren$3;
function cloneNode$3(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$3(node2)) {
    result = new Text$3(node2.data);
  } else if (isComment$3(node2)) {
    result = new Comment$3(node2.data);
  } else if (isTag$3(node2)) {
    var children = recursive ? cloneChildren$3(node2.children) : [];
    var clone_1 = new Element$3(node2.name, __assign$7({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$7({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$7({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$3(node2)) {
    var children = recursive ? cloneChildren$3(node2.children) : [];
    var clone_2 = new CDATA$3(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$3(node2)) {
    var children = recursive ? cloneChildren$3(node2.children) : [];
    var clone_3 = new Document$3(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$3(node2)) {
    var instruction = new ProcessingInstruction$3(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$3.cloneNode = cloneNode$3;
function cloneChildren$3(childs) {
  var children = childs.map(function(child) {
    return cloneNode$3(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$3;
  __exportStar(node$3, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$c);
var lib$b = {};
var lib$a = {};
var decode$3 = {};
var decodeDataHtml$3 = {};
Object.defineProperty(decodeDataHtml$3, "__esModule", { value: true });
decodeDataHtml$3.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decodeDataXml$3 = {};
Object.defineProperty(decodeDataXml$3, "__esModule", { value: true });
decodeDataXml$3.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decode_codepoint$3 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$3);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$3);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$3);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$3);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$3;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$3);
var encode$2 = {};
var encodeHtml$2 = {};
Object.defineProperty(encodeHtml$2, "__esModule", { value: true });
function restoreDiff$2(arr) {
  for (var i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
encodeHtml$2.default = new Map(/* @__PURE__ */ restoreDiff$2([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff$2([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff$2([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff$2([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape$3 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c, index2) {
      return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$3);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode$2, "__esModule", { value: true });
encode$2.encodeNonAsciiHTML = encode$2.encodeHTML = void 0;
var encode_html_js_1$2 = __importDefault$7(encodeHtml$2);
var escape_js_1$3 = _escape$3;
var htmlReplacer$2 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML$2(data2) {
  return encodeHTMLTrieRe$2(htmlReplacer$2, data2);
}
encode$2.encodeHTML = encodeHTML$2;
function encodeNonAsciiHTML$2(data2) {
  return encodeHTMLTrieRe$2(escape_js_1$3.xmlReplacer, data2);
}
encode$2.encodeNonAsciiHTML = encodeNonAsciiHTML$2;
function encodeHTMLTrieRe$2(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i = match.index;
    ret += str.substring(lastIdx, i);
    var char = str.charCodeAt(i);
    var next = encode_html_js_1$2.default.get(char);
    if (typeof next === "object") {
      if (i + 1 < str.length) {
        var nextChar = str.charCodeAt(i + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i + 1;
    } else {
      var cp = (0, escape_js_1$3.getCodePoint)(str, i);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode$3;
  var encode_js_1 = encode$2;
  var escape_js_12 = _escape$3;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode2;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode2(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode2;
  var escape_js_2 = _escape$3;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode$2;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode$3;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib$a);
var foreignNames$2 = {};
Object.defineProperty(foreignNames$2, "__esModule", { value: true });
foreignNames$2.attributeNames = foreignNames$2.elementNames = void 0;
foreignNames$2.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames$2.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign$6 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$6 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$6.apply(this, arguments);
};
var __createBinding$7 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$7 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$7 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$7(result, mod, k);
  }
  __setModuleDefault$7(result, mod);
  return result;
};
Object.defineProperty(lib$b, "__esModule", { value: true });
lib$b.render = void 0;
var ElementType$2 = __importStar$7(lib$i);
var entities_1$2 = lib$a;
var foreignNames_js_1$2 = foreignNames$2;
var unencodedElements$2 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes$2(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes$2(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes$2 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1$2.encodeXML : entities_1$2.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1$2.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag$2 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$2(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i = 0; i < nodes.length; i++) {
    output += renderNode$2(nodes[i], options2);
  }
  return output;
}
lib$b.render = render$2;
lib$b.default = render$2;
function renderNode$2(node2, options2) {
  switch (node2.type) {
    case ElementType$2.Root:
      return render$2(node2.children, options2);
    case ElementType$2.Doctype:
    case ElementType$2.Directive:
      return renderDirective$2(node2);
    case ElementType$2.Comment:
      return renderComment$2(node2);
    case ElementType$2.CDATA:
      return renderCdata$2(node2);
    case ElementType$2.Script:
    case ElementType$2.Style:
    case ElementType$2.Tag:
      return renderTag$2(node2, options2);
    case ElementType$2.Text:
      return renderText$2(node2, options2);
  }
}
var foreignModeIntegrationPoints$2 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements$2 = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$2(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1$2.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints$2.has(elem.parent.name)) {
      opts = __assign$6(__assign$6({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$2.has(elem.name)) {
    opts = __assign$6(__assign$6({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$2(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$2.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$2(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$2.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$2(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$2(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$2.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1$2.encodeXML)(data2) : (0, entities_1$2.escapeText)(data2);
  }
  return data2;
}
function renderCdata$2(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$2(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$6, "__esModule", { value: true });
stringify$6.innerText = stringify$6.textContent = stringify$6.getText = stringify$6.getInnerHTML = stringify$6.getOuterHTML = void 0;
var domhandler_1$f = lib$c;
var dom_serializer_1$2 = __importDefault$6(lib$b);
var domelementtype_1$5 = lib$i;
function getOuterHTML$2(node2, options2) {
  return (0, dom_serializer_1$2.default)(node2, options2);
}
stringify$6.getOuterHTML = getOuterHTML$2;
function getInnerHTML$2(node2, options2) {
  return (0, domhandler_1$f.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML$2(node3, options2);
  }).join("") : "";
}
stringify$6.getInnerHTML = getInnerHTML$2;
function getText$2(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$2).join("");
  if ((0, domhandler_1$f.isTag)(node2))
    return node2.name === "br" ? "\n" : getText$2(node2.children);
  if ((0, domhandler_1$f.isCDATA)(node2))
    return getText$2(node2.children);
  if ((0, domhandler_1$f.isText)(node2))
    return node2.data;
  return "";
}
stringify$6.getText = getText$2;
function textContent$2(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent$2).join("");
  if ((0, domhandler_1$f.hasChildren)(node2) && !(0, domhandler_1$f.isComment)(node2)) {
    return textContent$2(node2.children);
  }
  if ((0, domhandler_1$f.isText)(node2))
    return node2.data;
  return "";
}
stringify$6.textContent = textContent$2;
function innerText$2(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText$2).join("");
  if ((0, domhandler_1$f.hasChildren)(node2) && (node2.type === domelementtype_1$5.ElementType.Tag || (0, domhandler_1$f.isCDATA)(node2))) {
    return innerText$2(node2.children);
  }
  if ((0, domhandler_1$f.isText)(node2))
    return node2.data;
  return "";
}
stringify$6.innerText = innerText$2;
var traversal$2 = {};
Object.defineProperty(traversal$2, "__esModule", { value: true });
traversal$2.prevElementSibling = traversal$2.nextElementSibling = traversal$2.getName = traversal$2.hasAttrib = traversal$2.getAttributeValue = traversal$2.getSiblings = traversal$2.getParent = traversal$2.getChildren = void 0;
var domhandler_1$e = lib$c;
function getChildren$2(elem) {
  return (0, domhandler_1$e.hasChildren)(elem) ? elem.children : [];
}
traversal$2.getChildren = getChildren$2;
function getParent$2(elem) {
  return elem.parent || null;
}
traversal$2.getParent = getParent$2;
function getSiblings$2(elem) {
  var _a, _b;
  var parent = getParent$2(elem);
  if (parent != null)
    return getChildren$2(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal$2.getSiblings = getSiblings$2;
function getAttributeValue$2(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal$2.getAttributeValue = getAttributeValue$2;
function hasAttrib$2(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal$2.hasAttrib = hasAttrib$2;
function getName$2(elem) {
  return elem.name;
}
traversal$2.getName = getName$2;
function nextElementSibling$2(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$e.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal$2.nextElementSibling = nextElementSibling$2;
function prevElementSibling$2(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$e.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal$2.prevElementSibling = prevElementSibling$2;
var manipulation$3 = {};
Object.defineProperty(manipulation$3, "__esModule", { value: true });
manipulation$3.prepend = manipulation$3.prependChild = manipulation$3.append = manipulation$3.appendChild = manipulation$3.replaceElement = manipulation$3.removeElement = void 0;
function removeElement$2(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation$3.removeElement = removeElement$2;
function replaceElement$2(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation$3.replaceElement = replaceElement$2;
function appendChild$2(parent, child) {
  removeElement$2(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation$3.appendChild = appendChild$2;
function append$2(elem, next) {
  removeElement$2(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation$3.append = append$2;
function prependChild$2(parent, child) {
  removeElement$2(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation$3.prependChild = prependChild$2;
function prepend$2(elem, prev) {
  removeElement$2(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation$3.prepend = prepend$2;
var querying$2 = {};
Object.defineProperty(querying$2, "__esModule", { value: true });
querying$2.findAll = querying$2.existsOne = querying$2.findOne = querying$2.findOneChild = querying$2.find = querying$2.filter = void 0;
var domhandler_1$d = lib$c;
function filter$3(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$4(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying$2.filter = filter$3;
function find$4(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$d.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$2.find = find$4;
function findOneChild$2(test2, nodes) {
  return nodes.find(test2);
}
querying$2.findOneChild = findOneChild$2;
function findOne$2(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i = 0; i < nodes.length && !elem; i++) {
    var node2 = nodes[i];
    if (!(0, domhandler_1$d.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne$2(test2, node2.children, true);
    }
  }
  return elem;
}
querying$2.findOne = findOne$2;
function existsOne$2(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$d.isTag)(checked2) && (test2(checked2) || existsOne$2(test2, checked2.children));
  });
}
querying$2.existsOne = existsOne$2;
function findAll$2(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$d.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$2.findAll = findAll$2;
var legacy$2 = {};
Object.defineProperty(legacy$2, "__esModule", { value: true });
legacy$2.getElementsByTagType = legacy$2.getElementsByTagName = legacy$2.getElementById = legacy$2.getElements = legacy$2.testElement = void 0;
var domhandler_1$c = lib$c;
var querying_js_1$2 = querying$2;
var Checks$2 = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1$c.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1$c.isTag;
    }
    return function(elem) {
      return (0, domhandler_1$c.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1$c.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1$c.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck$2(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1$c.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1$c.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs$2(a, b) {
  return function(elem) {
    return a(elem) || b(elem);
  };
}
function compileTest$2(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks$2, key2) ? Checks$2[key2](value) : getAttribCheck$2(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$2);
}
function testElement$2(options2, node2) {
  var test2 = compileTest$2(options2);
  return test2 ? test2(node2) : true;
}
legacy$2.testElement = testElement$2;
function getElements$2(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest$2(options2);
  return test2 ? (0, querying_js_1$2.filter)(test2, nodes, recurse, limit) : [];
}
legacy$2.getElements = getElements$2;
function getElementById$2(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1$2.findOne)(getAttribCheck$2("id", id2), nodes, recurse);
}
legacy$2.getElementById = getElementById$2;
function getElementsByTagName$2(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$2.filter)(Checks$2["tag_name"](tagName), nodes, recurse, limit);
}
legacy$2.getElementsByTagName = getElementsByTagName$2;
function getElementsByTagType$2(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$2.filter)(Checks$2["tag_type"](type), nodes, recurse, limit);
}
legacy$2.getElementsByTagType = getElementsByTagType$2;
var helpers$3 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$c;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i, arr) {
      return !arr.includes(node2, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers$3);
var feeds$2 = {};
Object.defineProperty(feeds$2, "__esModule", { value: true });
feeds$2.getFeed = void 0;
var stringify_js_1$2 = stringify$6;
var legacy_js_1$2 = legacy$2;
function getFeed$2(doc) {
  var feedRoot = getOneElement$2(isValidFeed$2, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed$2(feedRoot) : getRssFeed$2(feedRoot);
}
feeds$2.getFeed = getFeed$2;
function getAtomFeed$2(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1$2.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements$2(children) };
      addConditionally$2(entry, "id", "id", children);
      addConditionally$2(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement$2("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$2("summary", children) || fetch$2("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$2("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally$2(feed, "id", "id", childs);
  addConditionally$2(feed, "title", "title", childs);
  var href = (_a = getOneElement$2("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$2(feed, "description", "subtitle", childs);
  var updated = fetch$2("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$2(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed$2(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement$2("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1$2.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements$2(children) };
      addConditionally$2(entry, "id", "guid", children);
      addConditionally$2(entry, "title", "title", children);
      addConditionally$2(entry, "link", "link", children);
      addConditionally$2(entry, "description", "description", children);
      var pubDate = fetch$2("pubDate", children) || fetch$2("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally$2(feed, "title", "title", childs);
  addConditionally$2(feed, "link", "link", childs);
  addConditionally$2(feed, "description", "description", childs);
  var updated = fetch$2("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$2(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING$2 = ["url", "type", "lang"];
var MEDIA_KEYS_INT$2 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements$2(where) {
  return (0, legacy_js_1$2.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING$2; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT$2; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement$2(tagName, node2) {
  return (0, legacy_js_1$2.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$2(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1$2.textContent)((0, legacy_js_1$2.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally$2(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch$2(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed$2(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$6, exports2);
  __exportStar(traversal$2, exports2);
  __exportStar(manipulation$3, exports2);
  __exportStar(querying$2, exports2);
  __exportStar(legacy$2, exports2);
  __exportStar(helpers$3, exports2);
  __exportStar(feeds$2, exports2);
  var domhandler_12 = lib$c;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$d);
var boolbase = {
  trueFunc: function trueFunc() {
    return true;
  },
  falseFunc: function falseFunc() {
    return false;
  }
};
const boolbase$1 = /* @__PURE__ */ getDefaultExportFromCjs(boolbase);
var compile$2 = {};
var sort = {};
Object.defineProperty(sort, "__esModule", { value: true });
sort.isTraversal = void 0;
var css_what_1$2 = require$$0$1;
var procedure = /* @__PURE__ */ new Map([
  [css_what_1$2.SelectorType.Universal, 50],
  [css_what_1$2.SelectorType.Tag, 30],
  [css_what_1$2.SelectorType.Attribute, 1],
  [css_what_1$2.SelectorType.Pseudo, 0]
]);
function isTraversal(token2) {
  return !procedure.has(token2.type);
}
sort.isTraversal = isTraversal;
var attributes$2 = /* @__PURE__ */ new Map([
  [css_what_1$2.AttributeAction.Exists, 10],
  [css_what_1$2.AttributeAction.Equals, 8],
  [css_what_1$2.AttributeAction.Not, 7],
  [css_what_1$2.AttributeAction.Start, 6],
  [css_what_1$2.AttributeAction.End, 6],
  [css_what_1$2.AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  var procs = arr.map(getProcedure);
  for (var i = 1; i < arr.length; i++) {
    var procNew = procs[i];
    if (procNew < 0)
      continue;
    for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      var token2 = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token2;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
sort.default = sortByProcedure;
function getProcedure(token2) {
  var _a, _b;
  var proc2 = (_a = procedure.get(token2.type)) !== null && _a !== void 0 ? _a : -1;
  if (token2.type === css_what_1$2.SelectorType.Attribute) {
    proc2 = (_b = attributes$2.get(token2.action)) !== null && _b !== void 0 ? _b : 4;
    if (token2.action === css_what_1$2.AttributeAction.Equals && token2.name === "id") {
      proc2 = 9;
    }
    if (token2.ignoreCase) {
      proc2 >>= 1;
    }
  } else if (token2.type === css_what_1$2.SelectorType.Pseudo) {
    if (!token2.data) {
      proc2 = 3;
    } else if (token2.name === "has" || token2.name === "contains") {
      proc2 = 0;
    } else if (Array.isArray(token2.data)) {
      proc2 = Math.min.apply(Math, token2.data.map(function(d) {
        return Math.min.apply(Math, d.map(getProcedure));
      }));
      if (proc2 < 0) {
        proc2 = 0;
      }
    } else {
      proc2 = 2;
    }
  }
  return proc2;
}
var general = {};
var attributes$1 = {};
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(attributes$1, "__esModule", { value: true });
attributes$1.attributeRules = void 0;
var boolbase_1$1 = __importDefault$5(boolbase);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector2, options2) {
  return typeof selector2.ignoreCase === "boolean" ? selector2.ignoreCase : selector2.ignoreCase === "quirks" ? !!options2.quirksMode : !options2.xmlMode && caseInsensitiveAttributes.has(selector2.name);
}
attributes$1.attributeRules = {
  equals: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next(elem);
      };
    }
    return function(elem) {
      return adapter.getAttributeValue(elem, name2) === value && next(elem);
    };
  },
  hyphen: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    var len = value.length;
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function hyphen(elem) {
      var attr2 = adapter.getAttributeValue(elem, name2);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next(elem);
    };
  },
  element: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name, value = data2.value;
    if (/\s/.test(value)) {
      return boolbase_1$1.default.falseFunc;
    }
    var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data2, options2) ? "i" : "");
    return function element2(elem) {
      var attr2 = adapter.getAttributeValue(elem, name2);
      return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next(elem);
    };
  },
  exists: function(next, _a, _b) {
    var name2 = _a.name;
    var adapter = _b.adapter;
    return function(elem) {
      return adapter.hasAttrib(elem, name2) && next(elem);
    };
  },
  start: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    var len = value.length;
    if (len === 0) {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function(elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
    };
  },
  end: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    var len = -value.length;
    if (len === 0) {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var _a;
        return ((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
      };
    }
    return function(elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
    };
  },
  any: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name, value = data2.value;
    if (value === "") {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      var regex_1 = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex_1.test(attr2) && next(elem);
      };
    }
    return function(elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
    };
  },
  not: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    if (value === "") {
      return function(elem) {
        return !!adapter.getAttributeValue(elem, name2) && next(elem);
      };
    } else if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next(elem);
      };
    }
    return function(elem) {
      return adapter.getAttributeValue(elem, name2) !== value && next(elem);
    };
  }
};
var pseudoSelectors = {};
var filters = {};
const whitespace$1 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$6(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number2 = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number2 !== null && number2 !== void 0 ? number2 : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number2 = readNumber();
    } else {
      sign = number2 = 0;
    }
  }
  if (number2 === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number2];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace$1.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile$1(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return boolbase$1.falseFunc;
  if (a === -1)
    return (index2) => index2 <= b;
  if (a === 0)
    return (index2) => index2 === b;
  if (a === 1)
    return b < 0 ? boolbase$1.trueFunc : (index2) => index2 >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
}
function generate(parsed) {
  const a = parsed[0];
  let b = parsed[1] - 1;
  let n = 0;
  if (a < 0) {
    const aPos = -a;
    const minValue = (b % aPos + aPos) % aPos;
    return () => {
      const val2 = minValue + aPos * n++;
      return val2 > b ? null : val2;
    };
  }
  if (a === 0)
    return b < 0 ? (
      // There are no result  always return `null`
      () => null
    ) : (
      // Return `b` exactly once
      () => n++ === 0 ? b : null
    );
  if (b < 0) {
    b += a * Math.ceil(-b / a);
  }
  return () => a * n++ + b;
}
function nthCheck$1(formula) {
  return compile$1(parse$6(formula));
}
function sequence(formula) {
  return generate(parse$6(formula));
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile: compile$1,
  default: nthCheck$1,
  generate,
  parse: parse$6,
  sequence
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esm);
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.filters = void 0;
  var nth_check_1 = __importDefault2(require$$0);
  var boolbase_12 = __importDefault2(boolbase);
  function getChildFunc(next, adapter) {
    return function(elem) {
      var parent = adapter.getParent(elem);
      return parent != null && adapter.isTag(parent) && next(elem);
    };
  }
  exports2.filters = {
    contains: function(next, text2, _a) {
      var adapter = _a.adapter;
      return function contains2(elem) {
        return next(elem) && adapter.getText(elem).includes(text2);
      };
    },
    icontains: function(next, text2, _a) {
      var adapter = _a.adapter;
      var itext = text2.toLowerCase();
      return function icontains(elem) {
        return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
      };
    },
    // Location specific methods
    "nth-child": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthChild2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0; i < siblings2.length; i++) {
          if (equals(elem, siblings2[i]))
            break;
          if (adapter.isTag(siblings2[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-child": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastChild2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings2.length - 1; i >= 0; i--) {
          if (equals(elem, siblings2[i]))
            break;
          if (adapter.isTag(siblings2[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-of-type": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthOfType2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0; i < siblings2.length; i++) {
          var currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-of-type": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastOfType2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings2.length - 1; i >= 0; i--) {
          var currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    // TODO determine the actual root element
    root: function(next, _rule, _a) {
      var adapter = _a.adapter;
      return function(elem) {
        var parent = adapter.getParent(elem);
        return (parent == null || !adapter.isTag(parent)) && next(elem);
      };
    },
    scope: function(next, rule, options2, context) {
      var equals = options2.equals;
      if (!context || context.length === 0) {
        return exports2.filters["root"](next, rule, options2);
      }
      if (context.length === 1) {
        return function(elem) {
          return equals(context[0], elem) && next(elem);
        };
      }
      return function(elem) {
        return context.includes(elem) && next(elem);
      };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive")
  };
  function dynamicStatePseudo(name2) {
    return function dynamicPseudo(next, _rule, _a) {
      var adapter = _a.adapter;
      var func = adapter[name2];
      if (typeof func !== "function") {
        return boolbase_12.default.falseFunc;
      }
      return function active(elem) {
        return func(elem) && next(elem);
      };
    };
  }
})(filters);
var pseudos = {};
Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
pseudos.pseudos = {
  empty: function(elem, _a) {
    var adapter = _a.adapter;
    return !adapter.getChildren(elem).some(function(elem2) {
      return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
    });
  },
  "first-child": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    var firstChild2 = adapter.getSiblings(elem).find(function(elem2) {
      return adapter.isTag(elem2);
    });
    return firstChild2 != null && equals(elem, firstChild2);
  },
  "last-child": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var siblings2 = adapter.getSiblings(elem);
    for (var i = siblings2.length - 1; i >= 0; i--) {
      if (equals(elem, siblings2[i]))
        return true;
      if (adapter.isTag(siblings2[i]))
        break;
    }
    return false;
  },
  "first-of-type": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var siblings2 = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i = 0; i < siblings2.length; i++) {
      var currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var siblings2 = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i = siblings2.length - 1; i >= 0; i--) {
      var currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every(function(sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
    });
  },
  "only-child": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    return adapter.getSiblings(elem).every(function(sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling);
    });
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error("Pseudo-class :".concat(name2, " requires an argument"));
    }
  } else if (func.length === argIndex) {
    throw new Error("Pseudo-class :".concat(name2, " doesn't have any arguments"));
  }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;
var aliases = {};
Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
aliases.aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
var subselects = {};
(function(exports2) {
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.subselects = exports2.getNextSiblings = exports2.ensureIsTag = exports2.PLACEHOLDER_ELEMENT = void 0;
  var boolbase_12 = __importDefault2(boolbase);
  var sort_js_12 = sort;
  exports2.PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next, adapter) {
    if (next === boolbase_12.default.falseFunc)
      return boolbase_12.default.falseFunc;
    return function(elem) {
      return adapter.isTag(elem) && next(elem);
    };
  }
  exports2.ensureIsTag = ensureIsTag;
  function getNextSiblings(elem, adapter) {
    var siblings2 = adapter.getSiblings(elem);
    if (siblings2.length <= 1)
      return [];
    var elemIndex = siblings2.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings2.length - 1)
      return [];
    return siblings2.slice(elemIndex + 1).filter(adapter.isTag);
  }
  exports2.getNextSiblings = getNextSiblings;
  function copyOptions(options2) {
    return {
      xmlMode: !!options2.xmlMode,
      lowerCaseAttributeNames: !!options2.lowerCaseAttributeNames,
      lowerCaseTags: !!options2.lowerCaseTags,
      quirksMode: !!options2.quirksMode,
      cacheResults: !!options2.cacheResults,
      pseudos: options2.pseudos,
      adapter: options2.adapter,
      equals: options2.equals
    };
  }
  var is2 = function(next, token2, options2, context, compileToken2) {
    var func = compileToken2(token2, copyOptions(options2), context);
    return func === boolbase_12.default.trueFunc ? next : func === boolbase_12.default.falseFunc ? boolbase_12.default.falseFunc : function(elem) {
      return func(elem) && next(elem);
    };
  };
  exports2.subselects = {
    is: is2,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is2,
    where: is2,
    not: function(next, token2, options2, context, compileToken2) {
      var func = compileToken2(token2, copyOptions(options2), context);
      return func === boolbase_12.default.falseFunc ? next : func === boolbase_12.default.trueFunc ? boolbase_12.default.falseFunc : function(elem) {
        return !func(elem) && next(elem);
      };
    },
    has: function(next, subselect, options2, _context, compileToken2) {
      var adapter = options2.adapter;
      var opts = copyOptions(options2);
      opts.relativeSelector = true;
      var context = subselect.some(function(s2) {
        return s2.some(sort_js_12.isTraversal);
      }) ? (
        // Used as a placeholder. Will be replaced with the actual element.
        [exports2.PLACEHOLDER_ELEMENT]
      ) : void 0;
      var compiled = compileToken2(subselect, opts, context);
      if (compiled === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      var hasElement = ensureIsTag(compiled, adapter);
      if (context && compiled !== boolbase_12.default.trueFunc) {
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
        return function(elem) {
          if (!next(elem))
            return false;
          context[0] = elem;
          var childs = adapter.getChildren(elem);
          var nextElements = shouldTestNextSiblings_1 ? __spreadArray2(__spreadArray2([], childs, true), getNextSiblings(elem, adapter), true) : childs;
          return adapter.existsOne(hasElement, nextElements);
        };
      }
      return function(elem) {
        return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
      };
    }
  };
})(subselects);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.compilePseudoSelector = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
  var css_what_12 = require$$0$1;
  var filters_js_1 = filters;
  Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
    return filters_js_1.filters;
  } });
  var pseudos_js_1 = pseudos;
  Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
    return pseudos_js_1.pseudos;
  } });
  var aliases_js_1 = aliases;
  Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
    return aliases_js_1.aliases;
  } });
  var subselects_js_12 = subselects;
  function compilePseudoSelector(next, selector2, options2, context, compileToken2) {
    var _a;
    var name2 = selector2.name, data2 = selector2.data;
    if (Array.isArray(data2)) {
      if (!(name2 in subselects_js_12.subselects)) {
        throw new Error("Unknown pseudo-class :".concat(name2, "(").concat(data2, ")"));
      }
      return subselects_js_12.subselects[name2](next, data2, options2, context, compileToken2);
    }
    var userPseudo = (_a = options2.pseudos) === null || _a === void 0 ? void 0 : _a[name2];
    var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name2];
    if (typeof stringPseudo === "string") {
      if (data2 != null) {
        throw new Error("Pseudo ".concat(name2, " doesn't have any arguments"));
      }
      var alias = (0, css_what_12.parse)(stringPseudo);
      return subselects_js_12.subselects["is"](next, alias, options2, context, compileToken2);
    }
    if (typeof userPseudo === "function") {
      (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name2, data2, 1);
      return function(elem) {
        return userPseudo(elem, data2) && next(elem);
      };
    }
    if (name2 in filters_js_1.filters) {
      return filters_js_1.filters[name2](next, data2, options2, context);
    }
    if (name2 in pseudos_js_1.pseudos) {
      var pseudo_1 = pseudos_js_1.pseudos[name2];
      (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name2, data2, 2);
      return function(elem) {
        return pseudo_1(elem, options2, data2) && next(elem);
      };
    }
    throw new Error("Unknown pseudo-class :".concat(name2));
  }
  exports2.compilePseudoSelector = compilePseudoSelector;
})(pseudoSelectors);
Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_js_1 = attributes$1;
var index_js_1$1 = pseudoSelectors;
var css_what_1$1 = require$$0$1;
function getElementParent(node2, adapter) {
  var parent = adapter.getParent(node2);
  if (parent && adapter.isTag(parent)) {
    return parent;
  }
  return null;
}
function compileGeneralSelector(next, selector2, options2, context, compileToken2) {
  var adapter = options2.adapter, equals = options2.equals;
  switch (selector2.type) {
    case css_what_1$1.SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case css_what_1$1.SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case css_what_1$1.SelectorType.Attribute: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options2.xmlMode || options2.lowerCaseAttributeNames) {
        selector2.name = selector2.name.toLowerCase();
      }
      return attributes_js_1.attributeRules[selector2.action](next, selector2, options2);
    }
    case css_what_1$1.SelectorType.Pseudo: {
      return (0, index_js_1$1.compilePseudoSelector)(next, selector2, options2, context, compileToken2);
    }
    case css_what_1$1.SelectorType.Tag: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      var name_1 = selector2.name;
      if (!options2.xmlMode || options2.lowerCaseTags) {
        name_1 = name_1.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name_1 && next(elem);
      };
    }
    case css_what_1$1.SelectorType.Descendant: {
      if (options2.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          var current = elem;
          while (current = getElementParent(current, adapter)) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        var current = elem;
        while (current = getElementParent(current, adapter)) {
          if (!isFalseCache_1.has(current)) {
            if (adapter.isTag(current) && next(current)) {
              return true;
            }
            isFalseCache_1.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        var current = elem;
        do {
          if (next(current))
            return true;
        } while (current = getElementParent(current, adapter));
        return false;
      };
    }
    case css_what_1$1.SelectorType.Parent: {
      return function parent(elem) {
        return adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) && next(elem2);
        });
      };
    }
    case css_what_1$1.SelectorType.Child: {
      return function child(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(parent);
      };
    }
    case css_what_1$1.SelectorType.Sibling: {
      return function sibling(elem) {
        var siblings2 = adapter.getSiblings(elem);
        for (var i = 0; i < siblings2.length; i++) {
          var currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case css_what_1$1.SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          var previous = adapter.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var lastElement;
        for (var i = 0; i < siblings2.length; i++) {
          var currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case css_what_1$1.SelectorType.Universal: {
      if (selector2.namespace != null && selector2.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next;
    }
  }
}
general.compileGeneralSelector = compileGeneralSelector;
var __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$6(result, mod, k);
  }
  __setModuleDefault$6(result, mod);
  return result;
};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(compile$2, "__esModule", { value: true });
compile$2.compileToken = compile$2.compileUnsafe = compile$2.compile = void 0;
var css_what_1 = require$$0$1;
var boolbase_1 = __importDefault$4(boolbase);
var sort_js_1 = __importStar$6(sort);
var general_js_1 = general;
var subselects_js_1 = subselects;
function compile(selector2, options2, context) {
  var next = compileUnsafe(selector2, options2, context);
  return (0, subselects_js_1.ensureIsTag)(next, options2.adapter);
}
compile$2.compile = compile;
function compileUnsafe(selector2, options2, context) {
  var token2 = typeof selector2 === "string" ? (0, css_what_1.parse)(selector2) : selector2;
  return compileToken(token2, options2, context);
}
compile$2.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
  return t.type === css_what_1.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data2) {
    return data2.some(includesScopePseudo);
  }));
}
var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: css_what_1.SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token2, _a, context) {
  var adapter = _a.adapter;
  var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e) {
    var parent = adapter.isTag(e) && adapter.getParent(e);
    return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
  }));
  for (var _i = 0, token_1 = token2; _i < token_1.length; _i++) {
    var t = token_1[_i];
    if (t.length > 0 && (0, sort_js_1.isTraversal)(t[0]) && t[0].type !== css_what_1.SelectorType.Descendant)
      ;
    else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token2, options2, context) {
  var _a;
  token2.forEach(sort_js_1.default);
  context = (_a = options2.context) !== null && _a !== void 0 ? _a : context;
  var isArrayContext = Array.isArray(context);
  var finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options2.relativeSelector !== false) {
    absolutize(token2, options2, finalContext);
  } else if (token2.some(function(t) {
    return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
  })) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  var shouldTestNextSiblings = false;
  var query = token2.map(function(rules) {
    if (rules.length >= 2) {
      var first2 = rules[0], second = rules[1];
      if (first2.type !== css_what_1.SelectorType.Pseudo || first2.name !== "scope")
        ;
      else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options2, finalContext);
  }).reduce(reduceRules, boolbase_1.default.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
compile$2.compileToken = compileToken;
function compileRules(rules, options2, context) {
  var _a;
  return rules.reduce(function(previous, rule) {
    return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options2, context, compileToken);
  }, (_a = options2.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
}
function reduceRules(a, b) {
  if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
    return a;
  }
  if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
    return b;
  }
  return function combine2(elem) {
    return a(elem) || b(elem);
  };
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.aliases = exports2.pseudos = exports2.filters = exports2.is = exports2.selectOne = exports2.selectAll = exports2.prepareContext = exports2._compileToken = exports2._compileUnsafe = exports2.compile = void 0;
  var DomUtils = __importStar2(lib$d);
  var boolbase_12 = __importDefault2(boolbase);
  var compile_js_1 = compile$2;
  var subselects_js_12 = subselects;
  var defaultEquals = function(a, b) {
    return a === b;
  };
  var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals
  };
  function convertOptionFormats(options2) {
    var _a, _b, _c, _d;
    var opts = options2 !== null && options2 !== void 0 ? options2 : defaultOptions;
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
    (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
    return opts;
  }
  function wrapCompile(func) {
    return function addAdapter(selector2, options2, context) {
      var opts = convertOptionFormats(options2);
      return func(selector2, opts, context);
    };
  }
  exports2.compile = wrapCompile(compile_js_1.compile);
  exports2._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
  exports2._compileToken = wrapCompile(compile_js_1.compileToken);
  function getSelectorFunc(searchFunc) {
    return function select2(query, elements, options2) {
      var opts = convertOptionFormats(options2);
      if (typeof query !== "function") {
        query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
      }
      var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
      return searchFunc(query, filteredElements, opts);
    };
  }
  function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) {
      shouldTestNextSiblings = false;
    }
    if (shouldTestNextSiblings) {
      elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
  }
  exports2.prepareContext = prepareContext;
  function appendNextSiblings(elem, adapter) {
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i = 0; i < elemsLength; i++) {
      var nextSiblings = (0, subselects_js_12.getNextSiblings)(elems[i], adapter);
      elems.push.apply(elems, nextSiblings);
    }
    return elems;
  }
  exports2.selectAll = getSelectorFunc(function(query, elems, options2) {
    return query === boolbase_12.default.falseFunc || !elems || elems.length === 0 ? [] : options2.adapter.findAll(query, elems);
  });
  exports2.selectOne = getSelectorFunc(function(query, elems, options2) {
    return query === boolbase_12.default.falseFunc || !elems || elems.length === 0 ? null : options2.adapter.findOne(query, elems);
  });
  function is2(elem, query, options2) {
    var opts = convertOptionFormats(options2);
    return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
  }
  exports2.is = is2;
  exports2.default = exports2.selectAll;
  var index_js_12 = pseudoSelectors;
  Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
    return index_js_12.filters;
  } });
  Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
    return index_js_12.pseudos;
  } });
  Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
    return index_js_12.aliases;
  } });
})(lib$e);
var lib$9 = {};
var stringify$5 = {};
var lib$8 = {};
var node$2 = {};
var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$5 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$5 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$5.apply(this, arguments);
};
Object.defineProperty(node$2, "__esModule", { value: true });
node$2.cloneNode = node$2.hasChildren = node$2.isDocument = node$2.isDirective = node$2.isComment = node$2.isText = node$2.isCDATA = node$2.isTag = node$2.Element = node$2.Document = node$2.CDATA = node$2.NodeWithChildren = node$2.ProcessingInstruction = node$2.Comment = node$2.Text = node$2.DataNode = node$2.Node = void 0;
var domelementtype_1$4 = lib$i;
var Node$2 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$2(this, recursive);
    };
    return Node2;
  }()
);
node$2.Node = Node$2;
var DataNode$2 = (
  /** @class */
  function(_super) {
    __extends$3(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$2)
);
node$2.DataNode = DataNode$2;
var Text$2 = (
  /** @class */
  function(_super) {
    __extends$3(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$2)
);
node$2.Text = Text$2;
var Comment$2 = (
  /** @class */
  function(_super) {
    __extends$3(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$2)
);
node$2.Comment = Comment$2;
var ProcessingInstruction$2 = (
  /** @class */
  function(_super) {
    __extends$3(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$4.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$2)
);
node$2.ProcessingInstruction = ProcessingInstruction$2;
var NodeWithChildren$2 = (
  /** @class */
  function(_super) {
    __extends$3(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$2)
);
node$2.NodeWithChildren = NodeWithChildren$2;
var CDATA$2 = (
  /** @class */
  function(_super) {
    __extends$3(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$2)
);
node$2.CDATA = CDATA$2;
var Document$2 = (
  /** @class */
  function(_super) {
    __extends$3(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$2)
);
node$2.Document = Document$2;
var Element$2 = (
  /** @class */
  function(_super) {
    __extends$3(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$4.ElementType.Script : name2 === "style" ? domelementtype_1$4.ElementType.Style : domelementtype_1$4.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$2)
);
node$2.Element = Element$2;
function isTag$2(node2) {
  return (0, domelementtype_1$4.isTag)(node2);
}
node$2.isTag = isTag$2;
function isCDATA$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.CDATA;
}
node$2.isCDATA = isCDATA$2;
function isText$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Text;
}
node$2.isText = isText$2;
function isComment$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Comment;
}
node$2.isComment = isComment$2;
function isDirective$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Directive;
}
node$2.isDirective = isDirective$2;
function isDocument$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Root;
}
node$2.isDocument = isDocument$2;
function hasChildren$2(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$2.hasChildren = hasChildren$2;
function cloneNode$2(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$2(node2)) {
    result = new Text$2(node2.data);
  } else if (isComment$2(node2)) {
    result = new Comment$2(node2.data);
  } else if (isTag$2(node2)) {
    var children = recursive ? cloneChildren$2(node2.children) : [];
    var clone_1 = new Element$2(node2.name, __assign$5({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$5({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$5({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$2(node2)) {
    var children = recursive ? cloneChildren$2(node2.children) : [];
    var clone_2 = new CDATA$2(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$2(node2)) {
    var children = recursive ? cloneChildren$2(node2.children) : [];
    var clone_3 = new Document$2(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$2(node2)) {
    var instruction = new ProcessingInstruction$2(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$2.cloneNode = cloneNode$2;
function cloneChildren$2(childs) {
  var children = childs.map(function(child) {
    return cloneNode$2(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$2;
  __exportStar(node$2, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$8);
var lib$7 = {};
var lib$6 = {};
var decode$2 = {};
var decodeDataHtml$2 = {};
Object.defineProperty(decodeDataHtml$2, "__esModule", { value: true });
decodeDataHtml$2.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decodeDataXml$2 = {};
Object.defineProperty(decodeDataXml$2, "__esModule", { value: true });
decodeDataXml$2.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decode_codepoint$2 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$2);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$2);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$2);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$2);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$2;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$2);
var encode$1 = {};
var encodeHtml$1 = {};
Object.defineProperty(encodeHtml$1, "__esModule", { value: true });
function restoreDiff$1(arr) {
  for (var i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
encodeHtml$1.default = new Map(/* @__PURE__ */ restoreDiff$1([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff$1([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff$1([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff$1([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c, index2) {
      return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$2);
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode$1, "__esModule", { value: true });
encode$1.encodeNonAsciiHTML = encode$1.encodeHTML = void 0;
var encode_html_js_1$1 = __importDefault$3(encodeHtml$1);
var escape_js_1$2 = _escape$2;
var htmlReplacer$1 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML$1(data2) {
  return encodeHTMLTrieRe$1(htmlReplacer$1, data2);
}
encode$1.encodeHTML = encodeHTML$1;
function encodeNonAsciiHTML$1(data2) {
  return encodeHTMLTrieRe$1(escape_js_1$2.xmlReplacer, data2);
}
encode$1.encodeNonAsciiHTML = encodeNonAsciiHTML$1;
function encodeHTMLTrieRe$1(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i = match.index;
    ret += str.substring(lastIdx, i);
    var char = str.charCodeAt(i);
    var next = encode_html_js_1$1.default.get(char);
    if (typeof next === "object") {
      if (i + 1 < str.length) {
        var nextChar = str.charCodeAt(i + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i + 1;
    } else {
      var cp = (0, escape_js_1$2.getCodePoint)(str, i);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode$2;
  var encode_js_1 = encode$1;
  var escape_js_12 = _escape$2;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode2;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode2(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode2;
  var escape_js_2 = _escape$2;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode$1;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode$2;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib$6);
var foreignNames$1 = {};
Object.defineProperty(foreignNames$1, "__esModule", { value: true });
foreignNames$1.attributeNames = foreignNames$1.elementNames = void 0;
foreignNames$1.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames$1.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign$4 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$4 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$4.apply(this, arguments);
};
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$5(result, mod, k);
  }
  __setModuleDefault$5(result, mod);
  return result;
};
Object.defineProperty(lib$7, "__esModule", { value: true });
lib$7.render = void 0;
var ElementType$1 = __importStar$5(lib$i);
var entities_1$1 = lib$6;
var foreignNames_js_1$1 = foreignNames$1;
var unencodedElements$1 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes$1(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes$1(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes$1 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1$1.encodeXML : entities_1$1.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1$1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag$1 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$1(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i = 0; i < nodes.length; i++) {
    output += renderNode$1(nodes[i], options2);
  }
  return output;
}
lib$7.render = render$1;
lib$7.default = render$1;
function renderNode$1(node2, options2) {
  switch (node2.type) {
    case ElementType$1.Root:
      return render$1(node2.children, options2);
    case ElementType$1.Doctype:
    case ElementType$1.Directive:
      return renderDirective$1(node2);
    case ElementType$1.Comment:
      return renderComment$1(node2);
    case ElementType$1.CDATA:
      return renderCdata$1(node2);
    case ElementType$1.Script:
    case ElementType$1.Style:
    case ElementType$1.Tag:
      return renderTag$1(node2, options2);
    case ElementType$1.Text:
      return renderText$1(node2, options2);
  }
}
var foreignModeIntegrationPoints$1 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements$1 = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$1(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1$1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints$1.has(elem.parent.name)) {
      opts = __assign$4(__assign$4({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$1.has(elem.name)) {
    opts = __assign$4(__assign$4({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$1(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$1.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$1(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$1.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$1(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$1(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$1.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1$1.encodeXML)(data2) : (0, entities_1$1.escapeText)(data2);
  }
  return data2;
}
function renderCdata$1(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$1(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$5, "__esModule", { value: true });
stringify$5.innerText = stringify$5.textContent = stringify$5.getText = stringify$5.getInnerHTML = stringify$5.getOuterHTML = void 0;
var domhandler_1$b = lib$8;
var dom_serializer_1$1 = __importDefault$2(lib$7);
var domelementtype_1$3 = lib$i;
function getOuterHTML$1(node2, options2) {
  return (0, dom_serializer_1$1.default)(node2, options2);
}
stringify$5.getOuterHTML = getOuterHTML$1;
function getInnerHTML$1(node2, options2) {
  return (0, domhandler_1$b.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML$1(node3, options2);
  }).join("") : "";
}
stringify$5.getInnerHTML = getInnerHTML$1;
function getText$1(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$1).join("");
  if ((0, domhandler_1$b.isTag)(node2))
    return node2.name === "br" ? "\n" : getText$1(node2.children);
  if ((0, domhandler_1$b.isCDATA)(node2))
    return getText$1(node2.children);
  if ((0, domhandler_1$b.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.getText = getText$1;
function textContent$1(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent$1).join("");
  if ((0, domhandler_1$b.hasChildren)(node2) && !(0, domhandler_1$b.isComment)(node2)) {
    return textContent$1(node2.children);
  }
  if ((0, domhandler_1$b.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.textContent = textContent$1;
function innerText$1(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText$1).join("");
  if ((0, domhandler_1$b.hasChildren)(node2) && (node2.type === domelementtype_1$3.ElementType.Tag || (0, domhandler_1$b.isCDATA)(node2))) {
    return innerText$1(node2.children);
  }
  if ((0, domhandler_1$b.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.innerText = innerText$1;
var traversal$1 = {};
Object.defineProperty(traversal$1, "__esModule", { value: true });
traversal$1.prevElementSibling = traversal$1.nextElementSibling = traversal$1.getName = traversal$1.hasAttrib = traversal$1.getAttributeValue = traversal$1.getSiblings = traversal$1.getParent = traversal$1.getChildren = void 0;
var domhandler_1$a = lib$8;
function getChildren$1(elem) {
  return (0, domhandler_1$a.hasChildren)(elem) ? elem.children : [];
}
traversal$1.getChildren = getChildren$1;
function getParent$1(elem) {
  return elem.parent || null;
}
traversal$1.getParent = getParent$1;
function getSiblings$1(elem) {
  var _a, _b;
  var parent = getParent$1(elem);
  if (parent != null)
    return getChildren$1(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal$1.getSiblings = getSiblings$1;
function getAttributeValue$1(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal$1.getAttributeValue = getAttributeValue$1;
function hasAttrib$1(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal$1.hasAttrib = hasAttrib$1;
function getName$1(elem) {
  return elem.name;
}
traversal$1.getName = getName$1;
function nextElementSibling$1(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$a.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal$1.nextElementSibling = nextElementSibling$1;
function prevElementSibling$1(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$a.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal$1.prevElementSibling = prevElementSibling$1;
var manipulation$2 = {};
Object.defineProperty(manipulation$2, "__esModule", { value: true });
manipulation$2.prepend = manipulation$2.prependChild = manipulation$2.append = manipulation$2.appendChild = manipulation$2.replaceElement = manipulation$2.removeElement = void 0;
function removeElement$1(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation$2.removeElement = removeElement$1;
function replaceElement$1(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation$2.replaceElement = replaceElement$1;
function appendChild$1(parent, child) {
  removeElement$1(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation$2.appendChild = appendChild$1;
function append$1(elem, next) {
  removeElement$1(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation$2.append = append$1;
function prependChild$1(parent, child) {
  removeElement$1(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation$2.prependChild = prependChild$1;
function prepend$1(elem, prev) {
  removeElement$1(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation$2.prepend = prepend$1;
var querying$1 = {};
Object.defineProperty(querying$1, "__esModule", { value: true });
querying$1.findAll = querying$1.existsOne = querying$1.findOne = querying$1.findOneChild = querying$1.find = querying$1.filter = void 0;
var domhandler_1$9 = lib$8;
function filter$2(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$3(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying$1.filter = filter$2;
function find$3(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$9.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$1.find = find$3;
function findOneChild$1(test2, nodes) {
  return nodes.find(test2);
}
querying$1.findOneChild = findOneChild$1;
function findOne$1(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i = 0; i < nodes.length && !elem; i++) {
    var node2 = nodes[i];
    if (!(0, domhandler_1$9.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne$1(test2, node2.children, true);
    }
  }
  return elem;
}
querying$1.findOne = findOne$1;
function existsOne$1(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$9.isTag)(checked2) && (test2(checked2) || existsOne$1(test2, checked2.children));
  });
}
querying$1.existsOne = existsOne$1;
function findAll$1(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$9.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$1.findAll = findAll$1;
var legacy$1 = {};
Object.defineProperty(legacy$1, "__esModule", { value: true });
legacy$1.getElementsByTagType = legacy$1.getElementsByTagName = legacy$1.getElementById = legacy$1.getElements = legacy$1.testElement = void 0;
var domhandler_1$8 = lib$8;
var querying_js_1$1 = querying$1;
var Checks$1 = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1$8.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1$8.isTag;
    }
    return function(elem) {
      return (0, domhandler_1$8.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1$8.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1$8.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck$1(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1$8.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1$8.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs$1(a, b) {
  return function(elem) {
    return a(elem) || b(elem);
  };
}
function compileTest$1(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks$1, key2) ? Checks$1[key2](value) : getAttribCheck$1(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$1);
}
function testElement$1(options2, node2) {
  var test2 = compileTest$1(options2);
  return test2 ? test2(node2) : true;
}
legacy$1.testElement = testElement$1;
function getElements$1(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest$1(options2);
  return test2 ? (0, querying_js_1$1.filter)(test2, nodes, recurse, limit) : [];
}
legacy$1.getElements = getElements$1;
function getElementById$1(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1$1.findOne)(getAttribCheck$1("id", id2), nodes, recurse);
}
legacy$1.getElementById = getElementById$1;
function getElementsByTagName$1(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$1.filter)(Checks$1["tag_name"](tagName), nodes, recurse, limit);
}
legacy$1.getElementsByTagName = getElementsByTagName$1;
function getElementsByTagType$1(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$1.filter)(Checks$1["tag_type"](type), nodes, recurse, limit);
}
legacy$1.getElementsByTagType = getElementsByTagType$1;
var helpers$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$8;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i, arr) {
      return !arr.includes(node2, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers$2);
var feeds$1 = {};
Object.defineProperty(feeds$1, "__esModule", { value: true });
feeds$1.getFeed = void 0;
var stringify_js_1$1 = stringify$5;
var legacy_js_1$1 = legacy$1;
function getFeed$1(doc) {
  var feedRoot = getOneElement$1(isValidFeed$1, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed$1(feedRoot) : getRssFeed$1(feedRoot);
}
feeds$1.getFeed = getFeed$1;
function getAtomFeed$1(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1$1.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements$1(children) };
      addConditionally$1(entry, "id", "id", children);
      addConditionally$1(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement$1("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$1("summary", children) || fetch$1("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$1("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally$1(feed, "id", "id", childs);
  addConditionally$1(feed, "title", "title", childs);
  var href = (_a = getOneElement$1("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$1(feed, "description", "subtitle", childs);
  var updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$1(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed$1(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement$1("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1$1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements$1(children) };
      addConditionally$1(entry, "id", "guid", children);
      addConditionally$1(entry, "title", "title", children);
      addConditionally$1(entry, "link", "link", children);
      addConditionally$1(entry, "description", "description", children);
      var pubDate = fetch$1("pubDate", children) || fetch$1("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally$1(feed, "title", "title", childs);
  addConditionally$1(feed, "link", "link", childs);
  addConditionally$1(feed, "description", "description", childs);
  var updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$1(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING$1 = ["url", "type", "lang"];
var MEDIA_KEYS_INT$1 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements$1(where) {
  return (0, legacy_js_1$1.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING$1; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT$1; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement$1(tagName, node2) {
  return (0, legacy_js_1$1.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1$1.textContent)((0, legacy_js_1$1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally$1(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch$1(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed$1(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$5, exports2);
  __exportStar(traversal$1, exports2);
  __exportStar(manipulation$2, exports2);
  __exportStar(querying$1, exports2);
  __exportStar(legacy$1, exports2);
  __exportStar(helpers$2, exports2);
  __exportStar(feeds$1, exports2);
  var domhandler_12 = lib$8;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$9);
var helpers$1 = {};
var positionals = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getLimit = exports2.isFilter = exports2.filterNames = void 0;
  exports2.filterNames = /* @__PURE__ */ new Set([
    "first",
    "last",
    "eq",
    "gt",
    "nth",
    "lt",
    "even",
    "odd"
  ]);
  function isFilter(s2) {
    if (s2.type !== "pseudo")
      return false;
    if (exports2.filterNames.has(s2.name))
      return true;
    if (s2.name === "not" && Array.isArray(s2.data)) {
      return s2.data.some(function(s3) {
        return s3.some(isFilter);
      });
    }
    return false;
  }
  exports2.isFilter = isFilter;
  function getLimit(filter2, data2, partLimit) {
    var num = data2 != null ? parseInt(data2, 10) : NaN;
    switch (filter2) {
      case "first":
        return 1;
      case "nth":
      case "eq":
        return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
      case "lt":
        return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
      case "gt":
        return isFinite(num) ? Infinity : 0;
      case "odd":
        return 2 * partLimit;
      case "even":
        return 2 * partLimit - 1;
      case "last":
      case "not":
        return Infinity;
    }
  }
  exports2.getLimit = getLimit;
})(positionals);
Object.defineProperty(helpers$1, "__esModule", { value: true });
helpers$1.groupSelectors = helpers$1.getDocumentRoot = void 0;
var positionals_js_1 = positionals;
function getDocumentRoot(node2) {
  while (node2.parent)
    node2 = node2.parent;
  return node2;
}
helpers$1.getDocumentRoot = getDocumentRoot;
function groupSelectors(selectors) {
  var filteredSelectors = [];
  var plainSelectors = [];
  for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
    var selector2 = selectors_1[_i];
    if (selector2.some(positionals_js_1.isFilter)) {
      filteredSelectors.push(selector2);
    } else {
      plainSelectors.push(selector2);
    }
  }
  return [plainSelectors, filteredSelectors];
}
helpers$1.groupSelectors = groupSelectors;
(function(exports2) {
  var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign2 = Object.assign || function(t) {
      for (var s2, i = 1, n = arguments.length; i < n; i++) {
        s2 = arguments[i];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t[p2] = s2[p2];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.select = exports2.filter = exports2.some = exports2.is = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
  var css_what_12 = require$$0$1;
  var css_select_1 = lib$e;
  var DomUtils = __importStar2(lib$9);
  var boolbase$12 = __importStar2(boolbase);
  var helpers_js_1 = helpers$1;
  var positionals_js_12 = positionals;
  var css_select_2 = lib$e;
  Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
    return css_select_2.filters;
  } });
  Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
    return css_select_2.pseudos;
  } });
  Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
    return css_select_2.aliases;
  } });
  var UNIVERSAL_SELECTOR = {
    type: css_what_12.SelectorType.Universal,
    namespace: null
  };
  var SCOPE_PSEUDO = {
    type: css_what_12.SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  function is2(element2, selector2, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return some([element2], selector2, options2);
  }
  exports2.is = is2;
  function some(elements, selector2, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (typeof selector2 === "function")
      return elements.some(selector2);
    var _a = (0, helpers_js_1.groupSelectors)((0, css_what_12.parse)(selector2)), plain = _a[0], filtered = _a[1];
    return plain.length > 0 && elements.some((0, css_select_1._compileToken)(plain, options2)) || filtered.some(function(sel) {
      return filterBySelector(sel, elements, options2).length > 0;
    });
  }
  exports2.some = some;
  function filterByPosition(filter3, elems, data2, options2) {
    var num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
    switch (filter3) {
      case "first":
      case "lt":
        return elems;
      case "last":
        return elems.length > 0 ? [elems[elems.length - 1]] : elems;
      case "nth":
      case "eq":
        return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
      case "gt":
        return isFinite(num) ? elems.slice(num + 1) : [];
      case "even":
        return elems.filter(function(_, i) {
          return i % 2 === 0;
        });
      case "odd":
        return elems.filter(function(_, i) {
          return i % 2 === 1;
        });
      case "not": {
        var filtered_1 = new Set(filterParsed(data2, elems, options2));
        return elems.filter(function(e) {
          return !filtered_1.has(e);
        });
      }
    }
  }
  function filter2(selector2, elements, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return filterParsed((0, css_what_12.parse)(selector2), elements, options2);
  }
  exports2.filter = filter2;
  function filterParsed(selector2, elements, options2) {
    if (elements.length === 0)
      return [];
    var _a = (0, helpers_js_1.groupSelectors)(selector2), plainSelectors = _a[0], filteredSelectors = _a[1];
    var found;
    if (plainSelectors.length) {
      var filtered = filterElements(elements, plainSelectors, options2);
      if (filteredSelectors.length === 0) {
        return filtered;
      }
      if (filtered.length) {
        found = new Set(filtered);
      }
    }
    for (var i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
      var filteredSelector = filteredSelectors[i];
      var missing = found ? elements.filter(function(e) {
        return DomUtils.isTag(e) && !found.has(e);
      }) : elements;
      if (missing.length === 0)
        break;
      var filtered = filterBySelector(filteredSelector, elements, options2);
      if (filtered.length) {
        if (!found) {
          if (i === filteredSelectors.length - 1) {
            return filtered;
          }
          found = new Set(filtered);
        } else {
          filtered.forEach(function(el) {
            return found.add(el);
          });
        }
      }
    }
    return typeof found !== "undefined" ? found.size === elements.length ? elements : (
      // Filter elements to preserve order
      elements.filter(function(el) {
        return found.has(el);
      })
    ) : [];
  }
  function filterBySelector(selector2, elements, options2) {
    var _a;
    if (selector2.some(css_what_12.isTraversal)) {
      var root2 = (_a = options2.root) !== null && _a !== void 0 ? _a : (0, helpers_js_1.getDocumentRoot)(elements[0]);
      var opts = __assign2(__assign2({}, options2), { context: elements, relativeSelector: false });
      selector2.push(SCOPE_PSEUDO);
      return findFilterElements(root2, selector2, opts, true, elements.length);
    }
    return findFilterElements(elements, selector2, options2, false, elements.length);
  }
  function select2(selector2, root2, options2, limit) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (limit === void 0) {
      limit = Infinity;
    }
    if (typeof selector2 === "function") {
      return find2(root2, selector2);
    }
    var _a = (0, helpers_js_1.groupSelectors)((0, css_what_12.parse)(selector2)), plain = _a[0], filtered = _a[1];
    var results = filtered.map(function(sel) {
      return findFilterElements(root2, sel, options2, true, limit);
    });
    if (plain.length) {
      results.push(findElements(root2, plain, options2, limit));
    }
    if (results.length === 0) {
      return [];
    }
    if (results.length === 1) {
      return results[0];
    }
    return DomUtils.uniqueSort(results.reduce(function(a, b) {
      return __spreadArray2(__spreadArray2([], a, true), b, true);
    }));
  }
  exports2.select = select2;
  function findFilterElements(root2, selector2, options2, queryForSelector, totalLimit) {
    var filterIndex = selector2.findIndex(positionals_js_12.isFilter);
    var sub = selector2.slice(0, filterIndex);
    var filter3 = selector2[filterIndex];
    var partLimit = selector2.length - 1 === filterIndex ? totalLimit : Infinity;
    var limit = (0, positionals_js_12.getLimit)(filter3.name, filter3.data, partLimit);
    if (limit === 0)
      return [];
    var elemsNoLimit = sub.length === 0 && !Array.isArray(root2) ? DomUtils.getChildren(root2).filter(DomUtils.isTag) : sub.length === 0 ? (Array.isArray(root2) ? root2 : [root2]).filter(DomUtils.isTag) : queryForSelector || sub.some(css_what_12.isTraversal) ? findElements(root2, [sub], options2, limit) : filterElements(root2, [sub], options2);
    var elems = elemsNoLimit.slice(0, limit);
    var result = filterByPosition(filter3.name, elems, filter3.data, options2);
    if (result.length === 0 || selector2.length === filterIndex + 1) {
      return result;
    }
    var remainingSelector = selector2.slice(filterIndex + 1);
    var remainingHasTraversal = remainingSelector.some(css_what_12.isTraversal);
    if (remainingHasTraversal) {
      if ((0, css_what_12.isTraversal)(remainingSelector[0])) {
        var type = remainingSelector[0].type;
        if (type === css_what_12.SelectorType.Sibling || type === css_what_12.SelectorType.Adjacent) {
          result = (0, css_select_1.prepareContext)(result, DomUtils, true);
        }
        remainingSelector.unshift(UNIVERSAL_SELECTOR);
      }
      options2 = __assign2(__assign2({}, options2), {
        // Avoid absolutizing the selector
        relativeSelector: false,
        /*
         * Add a custom root func, to make sure traversals don't match elements
         * that aren't a part of the considered tree.
         */
        rootFunc: function(el) {
          return result.includes(el);
        }
      });
    } else if (options2.rootFunc && options2.rootFunc !== boolbase$12.trueFunc) {
      options2 = __assign2(__assign2({}, options2), { rootFunc: boolbase$12.trueFunc });
    }
    return remainingSelector.some(positionals_js_12.isFilter) ? findFilterElements(result, remainingSelector, options2, false, totalLimit) : remainingHasTraversal ? (
      // Query existing elements to resolve traversal.
      findElements(result, [remainingSelector], options2, totalLimit)
    ) : (
      // If we don't have any more traversals, simply filter elements.
      filterElements(result, [remainingSelector], options2)
    );
  }
  function findElements(root2, sel, options2, limit) {
    var query = (0, css_select_1._compileToken)(sel, options2, root2);
    return find2(root2, query, limit);
  }
  function find2(root2, query, limit) {
    if (limit === void 0) {
      limit = Infinity;
    }
    var elems = (0, css_select_1.prepareContext)(root2, DomUtils, query.shouldTestNextSiblings);
    return DomUtils.find(function(node2) {
      return DomUtils.isTag(node2) && query(node2);
    }, elems, true, limit);
  }
  function filterElements(elements, sel, options2) {
    var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);
    if (els.length === 0)
      return els;
    var query = (0, css_select_1._compileToken)(sel, options2);
    return query === boolbase$12.trueFunc ? els : els.filter(query);
  }
})(lib$f);
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$4(result, mod, k);
  }
  __setModuleDefault$4(result, mod);
  return result;
};
var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(traversing, "__esModule", { value: true });
traversing.addBack = traversing.add = traversing.end = traversing.slice = traversing.index = traversing.toArray = traversing.get = traversing.eq = traversing.last = traversing.first = traversing.has = traversing.not = traversing.is = traversing.filterArray = traversing.filter = traversing.map = traversing.each = traversing.contents = traversing.children = traversing.siblings = traversing.prevUntil = traversing.prevAll = traversing.prev = traversing.nextUntil = traversing.nextAll = traversing.next = traversing.closest = traversing.parentsUntil = traversing.parents = traversing.parent = traversing.find = void 0;
var domhandler_1$7 = lib$j;
var select = __importStar$4(lib$f);
var utils_js_1$4 = utils$2;
var static_js_1$1 = _static;
var domutils_1$2 = lib$k;
var reSiblingSelector = /^\s*[~+]/;
function find$2(selectorOrHaystack) {
  var _a;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  var context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    var haystack = (0, utils_js_1$4.isCheerio)(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    return this._make(haystack.filter(function(elem) {
      return context.some(function(node2) {
        return (0, static_js_1$1.contains)(node2, elem);
      });
    }));
  }
  var elems = reSiblingSelector.test(selectorOrHaystack) ? context : this.children().toArray();
  var options2 = {
    context,
    root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select.select(selectorOrHaystack, elems, options2));
}
traversing.find = find$2;
function _getMatcher(matchMap) {
  return function(fn) {
    var postFns = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      postFns[_i - 1] = arguments[_i];
    }
    return function(selector2) {
      var _a;
      var matched = matchMap(fn, this);
      if (selector2) {
        matched = filterArray(matched, selector2, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce(function(elems, fn2) {
          return fn2(elems);
        }, matched) : matched
      );
    };
  };
}
var _matcher = _getMatcher(function(fn, elems) {
  var _a;
  var ret = [];
  for (var i = 0; i < elems.length; i++) {
    var value = fn(elems[i]);
    ret.push(value);
  }
  return (_a = new Array()).concat.apply(_a, ret);
});
var _singleMatcher = _getMatcher(function(fn, elems) {
  var ret = [];
  for (var i = 0; i < elems.length; i++) {
    var value = fn(elems[i]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem) {
  var postFns = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    postFns[_i - 1] = arguments[_i];
  }
  var matches = null;
  var innerMatcher = _getMatcher(function(nextElem2, elems) {
    var matched = [];
    (0, utils_js_1$4.domEach)(elems, function(elem) {
      for (var next_1; next_1 = nextElem2(elem); elem = next_1) {
        if (matches === null || matches === void 0 ? void 0 : matches(next_1, matched.length))
          break;
        matched.push(next_1);
      }
    });
    return matched;
  }).apply(void 0, __spreadArray$2([nextElem], postFns, false));
  return function(selector2, filterSelector) {
    var _this = this;
    matches = typeof selector2 === "string" ? function(elem) {
      return select.is(elem, selector2, _this.options);
    } : selector2 ? getFilterFn(selector2) : null;
    var ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
traversing.parent = _singleMatcher(function(_a) {
  var parent = _a.parent;
  return parent && !(0, domhandler_1$7.isDocument)(parent) ? parent : null;
}, _removeDuplicates);
traversing.parents = _matcher(function(elem) {
  var matched = [];
  while (elem.parent && !(0, domhandler_1$7.isDocument)(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, domutils_1$2.uniqueSort, function(elems) {
  return elems.reverse();
});
traversing.parentsUntil = _matchUntil(function(_a) {
  var parent = _a.parent;
  return parent && !(0, domhandler_1$7.isDocument)(parent) ? parent : null;
}, domutils_1$2.uniqueSort, function(elems) {
  return elems.reverse();
});
function closest(selector2) {
  var _a;
  var set = [];
  if (!selector2) {
    return this._make(set);
  }
  var selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]
  };
  var selectFn = typeof selector2 === "string" ? function(elem) {
    return select.is(elem, selector2, selectOpts);
  } : getFilterFn(selector2);
  (0, utils_js_1$4.domEach)(this, function(elem) {
    while (elem && (0, utils_js_1$4.isTag)(elem)) {
      if (selectFn(elem, 0)) {
        if (!set.includes(elem)) {
          set.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set);
}
traversing.closest = closest;
traversing.next = _singleMatcher(function(elem) {
  return (0, domutils_1$2.nextElementSibling)(elem);
});
traversing.nextAll = _matcher(function(elem) {
  var matched = [];
  while (elem.next) {
    elem = elem.next;
    if ((0, utils_js_1$4.isTag)(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
traversing.nextUntil = _matchUntil(function(el) {
  return (0, domutils_1$2.nextElementSibling)(el);
}, _removeDuplicates);
traversing.prev = _singleMatcher(function(elem) {
  return (0, domutils_1$2.prevElementSibling)(elem);
});
traversing.prevAll = _matcher(function(elem) {
  var matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if ((0, utils_js_1$4.isTag)(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
traversing.prevUntil = _matchUntil(function(el) {
  return (0, domutils_1$2.prevElementSibling)(el);
}, _removeDuplicates);
traversing.siblings = _matcher(function(elem) {
  return (0, domutils_1$2.getSiblings)(elem).filter(function(el) {
    return (0, utils_js_1$4.isTag)(el) && el !== elem;
  });
}, domutils_1$2.uniqueSort);
traversing.children = _matcher(function(elem) {
  return (0, domutils_1$2.getChildren)(elem).filter(utils_js_1$4.isTag);
}, _removeDuplicates);
function contents() {
  var elems = this.toArray().reduce(function(newElems, elem) {
    return (0, domhandler_1$7.hasChildren)(elem) ? newElems.concat(elem.children) : newElems;
  }, []);
  return this._make(elems);
}
traversing.contents = contents;
function each(fn) {
  var i = 0;
  var len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false)
    ++i;
  return this;
}
traversing.each = each;
function map(fn) {
  var elems = [];
  for (var i = 0; i < this.length; i++) {
    var el = this[i];
    var val2 = fn.call(el, i, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
traversing.map = map;
function getFilterFn(match) {
  if (typeof match === "function") {
    return function(el, i) {
      return match.call(el, i, el);
    };
  }
  if ((0, utils_js_1$4.isCheerio)(match)) {
    return function(el) {
      return Array.prototype.includes.call(match, el);
    };
  }
  return function(el) {
    return match === el;
  };
}
function filter$1(match) {
  var _a;
  return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));
}
traversing.filter = filter$1;
function filterArray(nodes, match, xmlMode, root2) {
  return typeof match === "string" ? select.filter(match, nodes, { xmlMode, root: root2 }) : nodes.filter(getFilterFn(match));
}
traversing.filterArray = filterArray;
function is$1(selector2) {
  var nodes = this.toArray();
  return typeof selector2 === "string" ? select.some(nodes.filter(utils_js_1$4.isTag), selector2, this.options) : selector2 ? nodes.some(getFilterFn(selector2)) : false;
}
traversing.is = is$1;
function not$1(match) {
  var nodes = this.toArray();
  if (typeof match === "string") {
    var matches_1 = new Set(select.filter(match, nodes, this.options));
    nodes = nodes.filter(function(el) {
      return !matches_1.has(el);
    });
  } else {
    var filterFn_1 = getFilterFn(match);
    nodes = nodes.filter(function(el, i) {
      return !filterFn_1(el, i);
    });
  }
  return this._make(nodes);
}
traversing.not = not$1;
function has$1(selectorOrHaystack) {
  var _this = this;
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    ":has(".concat(selectorOrHaystack, ")")
  ) : function(_, el) {
    return _this._make(el).find(selectorOrHaystack).length > 0;
  });
}
traversing.has = has$1;
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
traversing.first = first;
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
traversing.last = last;
function eq(i) {
  var _a;
  i = +i;
  if (i === 0 && this.length <= 1)
    return this;
  if (i < 0)
    i = this.length + i;
  return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);
}
traversing.eq = eq;
function get(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
traversing.get = get;
function toArray() {
  return Array.prototype.slice.call(this);
}
traversing.toArray = toArray;
function index$1(selectorOrNeedle) {
  var $haystack;
  var needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = (0, utils_js_1$4.isCheerio)(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
traversing.index = index$1;
function slice(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
traversing.slice = slice;
function end() {
  var _a;
  return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);
}
traversing.end = end;
function add$1(other, context) {
  var selection = this._make(other, context);
  var contents2 = (0, domutils_1$2.uniqueSort)(__spreadArray$2(__spreadArray$2([], this.get(), true), selection.get(), true));
  return this._make(contents2);
}
traversing.add = add$1;
function addBack(selector2) {
  return this.prevObject ? this.add(selector2 ? this.prevObject.filter(selector2) : this.prevObject) : this;
}
traversing.addBack = addBack;
var manipulation$1 = {};
var parse$5 = {};
Object.defineProperty(parse$5, "__esModule", { value: true });
parse$5.update = parse$5.getParse = void 0;
var domutils_1$1 = lib$k;
var domhandler_1$6 = lib$j;
function getParse(parser2) {
  return function parse2(content, options2, isDocument2, context) {
    if (typeof dist.Buffer !== "undefined" && dist.Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser2(content, options2, isDocument2, context);
    }
    var doc = content;
    if (!Array.isArray(doc) && (0, domhandler_1$6.isDocument)(doc)) {
      return doc;
    }
    var root2 = new domhandler_1$6.Document([]);
    update(doc, root2);
    return root2;
  };
}
parse$5.getParse = getParse;
function update(newChilds, parent) {
  var arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent) {
    parent.children = arr;
  } else {
    parent = null;
  }
  for (var i = 0; i < arr.length; i++) {
    var node2 = arr[i];
    if (node2.parent && node2.parent.children !== arr) {
      (0, domutils_1$1.removeElement)(node2);
    }
    if (parent) {
      node2.prev = arr[i - 1] || null;
      node2.next = arr[i + 1] || null;
    } else {
      node2.prev = node2.next = null;
    }
    node2.parent = parent;
  }
  return parent;
}
parse$5.update = update;
var __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(manipulation$1, "__esModule", { value: true });
manipulation$1.clone = manipulation$1.text = manipulation$1.toString = manipulation$1.html = manipulation$1.empty = manipulation$1.replaceWith = manipulation$1.remove = manipulation$1.insertBefore = manipulation$1.before = manipulation$1.insertAfter = manipulation$1.after = manipulation$1.wrapAll = manipulation$1.unwrap = manipulation$1.wrapInner = manipulation$1.wrap = manipulation$1.prepend = manipulation$1.append = manipulation$1.prependTo = manipulation$1.appendTo = manipulation$1._makeDomArray = void 0;
var domhandler_1$5 = lib$j;
var parse_js_1 = parse$5;
var static_js_1 = _static;
var utils_js_1$3 = utils$2;
var domutils_1 = lib$k;
function _makeDomArray(elem, clone2) {
  var _this = this;
  if (elem == null) {
    return [];
  }
  if ((0, utils_js_1$3.isCheerio)(elem)) {
    return clone2 ? (0, utils_js_1$3.cloneDom)(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce(function(newElems, el) {
      return newElems.concat(_this._makeDomArray(el, clone2));
    }, []);
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone2 ? (0, utils_js_1$3.cloneDom)([elem]) : [elem];
}
manipulation$1._makeDomArray = _makeDomArray;
function _insert(concatenator) {
  return function() {
    var _this = this;
    var elems = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      elems[_i] = arguments[_i];
    }
    var lastIdx = this.length - 1;
    return (0, utils_js_1$3.domEach)(this, function(el, i) {
      if (!(0, domhandler_1$5.hasChildren)(el))
        return;
      var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, _this._render(el.children)) : elems;
      var dom = _this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
  var _a, _b;
  var spliceArgs = __spreadArray$1([
    spliceIdx,
    spliceCount
  ], newElems, true);
  var prev = spliceIdx === 0 ? null : array[spliceIdx - 1];
  var next = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (var idx = 0; idx < newElems.length; ++idx) {
    var node2 = newElems[idx];
    var oldParent = node2.parent;
    if (oldParent) {
      var oldSiblings = oldParent.children;
      var prevIdx = oldSiblings.indexOf(node2);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node2.parent = parent;
    if (node2.prev) {
      node2.prev.next = (_a = node2.next) !== null && _a !== void 0 ? _a : null;
    }
    if (node2.next) {
      node2.next.prev = (_b = node2.prev) !== null && _b !== void 0 ? _b : null;
    }
    node2.prev = idx === 0 ? prev : newElems[idx - 1];
    node2.next = idx === newElems.length - 1 ? next : newElems[idx + 1];
  }
  if (prev) {
    prev.next = newElems[0];
  }
  if (next) {
    next.prev = newElems[newElems.length - 1];
  }
  return array.splice.apply(array, spliceArgs);
}
function appendTo(target) {
  var appendTarget = (0, utils_js_1$3.isCheerio)(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
manipulation$1.appendTo = appendTo;
function prependTo(target) {
  var prependTarget = (0, utils_js_1$3.isCheerio)(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
manipulation$1.prependTo = prependTo;
manipulation$1.append = _insert(function(dom, children, parent) {
  uniqueSplice(children, children.length, 0, dom, parent);
});
manipulation$1.prepend = _insert(function(dom, children, parent) {
  uniqueSplice(children, 0, 0, dom, parent);
});
function _wrap(insert) {
  return function(wrapper) {
    var lastIdx = this.length - 1;
    var lastParent = this.parents().last();
    for (var i = 0; i < this.length; i++) {
      var el = this[i];
      var wrap_1 = typeof wrapper === "function" ? wrapper.call(el, i, el) : typeof wrapper === "string" && !(0, utils_js_1$3.isHtml)(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
      var wrapperDom = this._makeDomArray(wrap_1, i < lastIdx)[0];
      if (!wrapperDom || !(0, domhandler_1$5.hasChildren)(wrapperDom))
        continue;
      var elInsertLocation = wrapperDom;
      var j = 0;
      while (j < elInsertLocation.children.length) {
        var child = elInsertLocation.children[j];
        if ((0, utils_js_1$3.isTag)(child)) {
          elInsertLocation = child;
          j = 0;
        } else {
          j++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
manipulation$1.wrap = _wrap(function(el, elInsertLocation, wrapperDom) {
  var parent = el.parent;
  if (!parent)
    return;
  var siblings2 = parent.children;
  var index2 = siblings2.indexOf(el);
  (0, parse_js_1.update)([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent);
});
manipulation$1.wrapInner = _wrap(function(el, elInsertLocation, wrapperDom) {
  if (!(0, domhandler_1$5.hasChildren)(el))
    return;
  (0, parse_js_1.update)(el.children, elInsertLocation);
  (0, parse_js_1.update)(wrapperDom, el);
});
function unwrap(selector2) {
  var _this = this;
  this.parent(selector2).not("body").each(function(_, el) {
    _this._make(el).replaceWith(el.children);
  });
  return this;
}
manipulation$1.unwrap = unwrap;
function wrapAll(wrapper) {
  var el = this[0];
  if (el) {
    var wrap_2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
    var elInsertLocation = void 0;
    for (var i = 0; i < wrap_2.length; i++) {
      if (wrap_2[i].type === "tag")
        elInsertLocation = wrap_2[i];
    }
    var j = 0;
    while (elInsertLocation && j < elInsertLocation.children.length) {
      var child = elInsertLocation.children[j];
      if (child.type === "tag") {
        elInsertLocation = child;
        j = 0;
      } else {
        j++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
manipulation$1.wrapAll = wrapAll;
function after() {
  var _this = this;
  var elems = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    elems[_i] = arguments[_i];
  }
  var lastIdx = this.length - 1;
  return (0, utils_js_1$3.domEach)(this, function(el, i) {
    var parent = el.parent;
    if (!(0, domhandler_1$5.hasChildren)(el) || !parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, _this._render(el.children)) : elems;
    var dom = _this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, parent);
  });
}
manipulation$1.after = after;
function insertAfter(target) {
  var _this = this;
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  var clones = [];
  this._makeDomArray(target).forEach(function(el) {
    var clonedSelf = _this.clone().toArray();
    var parent = el.parent;
    if (!parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent);
    clones.push.apply(clones, clonedSelf);
  });
  return this._make(clones);
}
manipulation$1.insertAfter = insertAfter;
function before() {
  var _this = this;
  var elems = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    elems[_i] = arguments[_i];
  }
  var lastIdx = this.length - 1;
  return (0, utils_js_1$3.domEach)(this, function(el, i) {
    var parent = el.parent;
    if (!(0, domhandler_1$5.hasChildren)(el) || !parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, _this._render(el.children)) : elems;
    var dom = _this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, parent);
  });
}
manipulation$1.before = before;
function insertBefore(target) {
  var _this = this;
  var targetArr = this._make(target);
  this.remove();
  var clones = [];
  (0, utils_js_1$3.domEach)(targetArr, function(el) {
    var clonedSelf = _this.clone().toArray();
    var parent = el.parent;
    if (!parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent);
    clones.push.apply(clones, clonedSelf);
  });
  return this._make(clones);
}
manipulation$1.insertBefore = insertBefore;
function remove(selector2) {
  var elems = selector2 ? this.filter(selector2) : this;
  (0, utils_js_1$3.domEach)(elems, function(el) {
    (0, domutils_1.removeElement)(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
manipulation$1.remove = remove;
function replaceWith(content) {
  var _this = this;
  return (0, utils_js_1$3.domEach)(this, function(el, i) {
    var parent = el.parent;
    if (!parent) {
      return;
    }
    var siblings2 = parent.children;
    var cont = typeof content === "function" ? content.call(el, i, el) : content;
    var dom = _this._makeDomArray(cont);
    (0, parse_js_1.update)(dom, null);
    var index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom, parent);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
manipulation$1.replaceWith = replaceWith;
function empty$4() {
  return (0, utils_js_1$3.domEach)(this, function(el) {
    if (!(0, domhandler_1$5.hasChildren)(el))
      return;
    el.children.forEach(function(child) {
      child.next = child.prev = child.parent = null;
    });
    el.children.length = 0;
  });
}
manipulation$1.empty = empty$4;
function html$5(str) {
  var _this = this;
  if (str === void 0) {
    var el = this[0];
    if (!el || !(0, domhandler_1$5.hasChildren)(el))
      return null;
    return this._render(el.children);
  }
  return (0, utils_js_1$3.domEach)(this, function(el2) {
    if (!(0, domhandler_1$5.hasChildren)(el2))
      return;
    el2.children.forEach(function(child) {
      child.next = child.prev = child.parent = null;
    });
    var content = (0, utils_js_1$3.isCheerio)(str) ? str.toArray() : _this._parse("".concat(str), _this.options, false, el2).children;
    (0, parse_js_1.update)(content, el2);
  });
}
manipulation$1.html = html$5;
function toString$1() {
  return this._render(this);
}
manipulation$1.toString = toString$1;
function text$1(str) {
  var _this = this;
  if (str === void 0) {
    return (0, static_js_1.text)(this);
  }
  if (typeof str === "function") {
    return (0, utils_js_1$3.domEach)(this, function(el, i) {
      return _this._make(el).text(str.call(el, i, (0, static_js_1.text)([el])));
    });
  }
  return (0, utils_js_1$3.domEach)(this, function(el) {
    if (!(0, domhandler_1$5.hasChildren)(el))
      return;
    el.children.forEach(function(child) {
      child.next = child.prev = child.parent = null;
    });
    var textNode = new domhandler_1$5.Text("".concat(str));
    (0, parse_js_1.update)(textNode, el);
  });
}
manipulation$1.text = text$1;
function clone() {
  return this._make((0, utils_js_1$3.cloneDom)(this.get()));
}
manipulation$1.clone = clone;
var css$1 = {};
Object.defineProperty(css$1, "__esModule", { value: true });
css$1.css = void 0;
var utils_js_1$2 = utils$2;
function css(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return (0, utils_js_1$2.domEach)(this, function(el, i) {
      if ((0, utils_js_1$2.isTag)(el)) {
        setCss(el, prop2, val2, i);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
css$1.css = css;
function setCss(el, prop2, value, idx) {
  if (typeof prop2 === "string") {
    var styles = getCss(el);
    var val2 = typeof value === "function" ? value.call(el, idx, styles[prop2]) : value;
    if (val2 === "") {
      delete styles[prop2];
    } else if (val2 != null) {
      styles[prop2] = val2;
    }
    el.attribs["style"] = stringify$4(styles);
  } else if (typeof prop2 === "object") {
    Object.keys(prop2).forEach(function(k, i) {
      setCss(el, k, prop2[k], i);
    });
  }
}
function getCss(el, prop2) {
  if (!el || !(0, utils_js_1$2.isTag)(el))
    return;
  var styles = parse$4(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles[prop2];
  }
  if (Array.isArray(prop2)) {
    var newStyles_1 = {};
    prop2.forEach(function(item) {
      if (styles[item] != null) {
        newStyles_1[item] = styles[item];
      }
    });
    return newStyles_1;
  }
  return styles;
}
function stringify$4(obj) {
  return Object.keys(obj).reduce(function(str, prop2) {
    return "".concat(str).concat(str ? " " : "").concat(prop2, ": ").concat(obj[prop2], ";");
  }, "");
}
function parse$4(styles) {
  styles = (styles || "").trim();
  if (!styles)
    return {};
  var obj = {};
  var key2;
  for (var _i = 0, _a = styles.split(";"); _i < _a.length; _i++) {
    var str = _a[_i];
    var n = str.indexOf(":");
    if (n < 1 || n === str.length - 1) {
      var trimmed = str.trimEnd();
      if (trimmed.length > 0 && key2 !== void 0) {
        obj[key2] += ";".concat(trimmed);
      }
    } else {
      key2 = str.slice(0, n).trim();
      obj[key2] = str.slice(n + 1).trim();
    }
  }
  return obj;
}
var forms = {};
Object.defineProperty(forms, "__esModule", { value: true });
forms.serializeArray = forms.serialize = void 0;
var utils_js_1$1 = utils$2;
var submittableSelector = "input,select,textarea,keygen";
var r20 = /%20/g;
var rCRLF = /\r?\n/g;
function serialize$1() {
  var arr = this.serializeArray();
  var retArr = arr.map(function(data2) {
    return "".concat(encodeURIComponent(data2.name), "=").concat(encodeURIComponent(data2.value));
  });
  return retArr.join("&").replace(r20, "+");
}
forms.serialize = serialize$1;
function serializeArray() {
  var _this = this;
  return this.map(function(_, elem) {
    var $elem = _this._make(elem);
    if ((0, utils_js_1$1.isTag)(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
  ).map(function(_, elem) {
    var _a;
    var $elem = _this._make(elem);
    var name2 = $elem.attr("name");
    var value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : "";
    if (Array.isArray(value)) {
      return value.map(function(val2) {
        return { name: name2, value: val2.replace(rCRLF, "\r\n") };
      });
    }
    return { name: name2, value: value.replace(rCRLF, "\r\n") };
  }).toArray();
}
forms.serializeArray = serializeArray;
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$3(result, mod, k);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
Object.defineProperty(cheerio$1, "__esModule", { value: true });
cheerio$1.Cheerio = void 0;
var Attributes = __importStar$3(attributes$3);
var Traversing = __importStar$3(traversing);
var Manipulation = __importStar$3(manipulation$1);
var Css = __importStar$3(css$1);
var Forms = __importStar$3(forms);
var Cheerio = (
  /** @class */
  function() {
    function Cheerio2(elements, root2, options2) {
      this.length = 0;
      this.options = options2;
      this._root = root2;
      if (elements) {
        for (var idx = 0; idx < elements.length; idx++) {
          this[idx] = elements[idx];
        }
        this.length = elements.length;
      }
    }
    return Cheerio2;
  }()
);
cheerio$1.Cheerio = Cheerio;
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$3 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$3 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
Object.defineProperty(load, "__esModule", { value: true });
load.getLoad = void 0;
var options_js_1 = __importStar$2(options);
var staticMethods = __importStar$2(_static);
var cheerio_js_1 = cheerio$1;
var utils_js_1 = utils$2;
function getLoad(parse2, render2) {
  return function load2(content, options2, isDocument2) {
    if (isDocument2 === void 0) {
      isDocument2 = true;
    }
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    var internalOpts = __assign$3(__assign$3({}, options_js_1.default), (0, options_js_1.flatten)(options2));
    var initialRoot = parse2(content, internalOpts, isDocument2, null);
    var LoadedCheerio = (
      /** @class */
      function(_super) {
        __extends$2(LoadedCheerio2, _super);
        function LoadedCheerio2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        LoadedCheerio2.prototype._make = function(selector2, context) {
          var cheerio2 = initialize(selector2, context);
          cheerio2.prevObject = this;
          return cheerio2;
        };
        LoadedCheerio2.prototype._parse = function(content2, options3, isDocument3, context) {
          return parse2(content2, options3, isDocument3, context);
        };
        LoadedCheerio2.prototype._render = function(dom) {
          return render2(dom, this.options);
        };
        return LoadedCheerio2;
      }(cheerio_js_1.Cheerio)
    );
    function initialize(selector2, context, root2, opts) {
      if (root2 === void 0) {
        root2 = initialRoot;
      }
      if (selector2 && (0, utils_js_1.isCheerio)(selector2))
        return selector2;
      var options3 = __assign$3(__assign$3({}, internalOpts), (0, options_js_1.flatten)(opts));
      var r = typeof root2 === "string" ? [parse2(root2, options3, false, null)] : "length" in root2 ? root2 : [root2];
      var rootInstance = (0, utils_js_1.isCheerio)(r) ? r : new LoadedCheerio(r, null, options3);
      rootInstance._root = rootInstance;
      if (!selector2) {
        return new LoadedCheerio(void 0, rootInstance, options3);
      }
      var elements = typeof selector2 === "string" && (0, utils_js_1.isHtml)(selector2) ? (
        // $(<html>)
        parse2(selector2, options3, false, null).children
      ) : isNode(selector2) ? (
        // $(dom)
        [selector2]
      ) : Array.isArray(selector2) ? (
        // $([dom])
        selector2
      ) : void 0;
      var instance = new LoadedCheerio(elements, rootInstance, options3);
      if (elements) {
        return instance;
      }
      if (typeof selector2 !== "string") {
        throw new Error("Unexpected type of selector");
      }
      var search2 = selector2;
      var searchContext = !context ? (
        // If we don't have a context, maybe we have a root, from loading
        rootInstance
      ) : typeof context === "string" ? (0, utils_js_1.isHtml)(context) ? (
        // $('li', '<ul>...</ul>')
        new LoadedCheerio([parse2(context, options3, false, null)], rootInstance, options3)
      ) : (
        // $('li', 'ul')
        (search2 = "".concat(context, " ").concat(search2), rootInstance)
      ) : (0, utils_js_1.isCheerio)(context) ? (
        // $('li', $)
        context
      ) : (
        // $('li', node), $('li', [nodes])
        new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options3)
      );
      if (!searchContext)
        return instance;
      return searchContext.find(search2);
    }
    Object.assign(initialize, staticMethods, {
      load: load2,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
load.getLoad = getLoad;
function isNode(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}
var parse5Adapter = {};
var cjs$1 = {};
var parser$2 = {};
var tokenizer = {};
var preprocessor = {};
var unicode$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isUndefinedCodePoint = exports2.isControlCodePoint = exports2.getSurrogatePairCodePoint = exports2.isSurrogatePair = exports2.isSurrogate = exports2.SEQUENCES = exports2.CODE_POINTS = exports2.REPLACEMENT_CHARACTER = void 0;
  const UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
    65534,
    65535,
    131070,
    131071,
    196606,
    196607,
    262142,
    262143,
    327678,
    327679,
    393214,
    393215,
    458750,
    458751,
    524286,
    524287,
    589822,
    589823,
    655358,
    655359,
    720894,
    720895,
    786430,
    786431,
    851966,
    851967,
    917502,
    917503,
    983038,
    983039,
    1048574,
    1048575,
    1114110,
    1114111
  ]);
  exports2.REPLACEMENT_CHARACTER = "";
  (function(CODE_POINTS) {
    CODE_POINTS[CODE_POINTS["EOF"] = -1] = "EOF";
    CODE_POINTS[CODE_POINTS["NULL"] = 0] = "NULL";
    CODE_POINTS[CODE_POINTS["TABULATION"] = 9] = "TABULATION";
    CODE_POINTS[CODE_POINTS["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
    CODE_POINTS[CODE_POINTS["LINE_FEED"] = 10] = "LINE_FEED";
    CODE_POINTS[CODE_POINTS["FORM_FEED"] = 12] = "FORM_FEED";
    CODE_POINTS[CODE_POINTS["SPACE"] = 32] = "SPACE";
    CODE_POINTS[CODE_POINTS["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
    CODE_POINTS[CODE_POINTS["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
    CODE_POINTS[CODE_POINTS["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
    CODE_POINTS[CODE_POINTS["AMPERSAND"] = 38] = "AMPERSAND";
    CODE_POINTS[CODE_POINTS["APOSTROPHE"] = 39] = "APOSTROPHE";
    CODE_POINTS[CODE_POINTS["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
    CODE_POINTS[CODE_POINTS["SOLIDUS"] = 47] = "SOLIDUS";
    CODE_POINTS[CODE_POINTS["DIGIT_0"] = 48] = "DIGIT_0";
    CODE_POINTS[CODE_POINTS["DIGIT_9"] = 57] = "DIGIT_9";
    CODE_POINTS[CODE_POINTS["SEMICOLON"] = 59] = "SEMICOLON";
    CODE_POINTS[CODE_POINTS["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
    CODE_POINTS[CODE_POINTS["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
    CODE_POINTS[CODE_POINTS["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
    CODE_POINTS[CODE_POINTS["QUESTION_MARK"] = 63] = "QUESTION_MARK";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
    CODE_POINTS[CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
    CODE_POINTS[CODE_POINTS["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
    CODE_POINTS[CODE_POINTS["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
  })(exports2.CODE_POINTS || (exports2.CODE_POINTS = {}));
  exports2.SEQUENCES = {
    DASH_DASH: "--",
    CDATA_START: "[CDATA[",
    DOCTYPE: "doctype",
    SCRIPT: "script",
    PUBLIC: "public",
    SYSTEM: "system"
  };
  function isSurrogate(cp) {
    return cp >= 55296 && cp <= 57343;
  }
  exports2.isSurrogate = isSurrogate;
  function isSurrogatePair(cp) {
    return cp >= 56320 && cp <= 57343;
  }
  exports2.isSurrogatePair = isSurrogatePair;
  function getSurrogatePairCodePoint(cp1, cp2) {
    return (cp1 - 55296) * 1024 + 9216 + cp2;
  }
  exports2.getSurrogatePairCodePoint = getSurrogatePairCodePoint;
  function isControlCodePoint(cp) {
    return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
  }
  exports2.isControlCodePoint = isControlCodePoint;
  function isUndefinedCodePoint(cp) {
    return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
  }
  exports2.isUndefinedCodePoint = isUndefinedCodePoint;
})(unicode$1);
var errorCodes = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ERR = void 0;
  (function(ERR) {
    ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
    ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
    ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
    ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
    ERR["endTagWithAttributes"] = "end-tag-with-attributes";
    ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
    ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
    ERR["unexpectedNullCharacter"] = "unexpected-null-character";
    ERR["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
    ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
    ERR["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
    ERR["missingEndTagName"] = "missing-end-tag-name";
    ERR["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
    ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
    ERR["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
    ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
    ERR["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
    ERR["eofBeforeTagName"] = "eof-before-tag-name";
    ERR["eofInTag"] = "eof-in-tag";
    ERR["missingAttributeValue"] = "missing-attribute-value";
    ERR["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
    ERR["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
    ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
    ERR["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
    ERR["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
    ERR["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
    ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
    ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
    ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
    ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
    ERR["cdataInHtmlContent"] = "cdata-in-html-content";
    ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
    ERR["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
    ERR["eofInDoctype"] = "eof-in-doctype";
    ERR["nestedComment"] = "nested-comment";
    ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
    ERR["eofInComment"] = "eof-in-comment";
    ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
    ERR["eofInCdata"] = "eof-in-cdata";
    ERR["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
    ERR["nullCharacterReference"] = "null-character-reference";
    ERR["surrogateCharacterReference"] = "surrogate-character-reference";
    ERR["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
    ERR["controlCharacterReference"] = "control-character-reference";
    ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
    ERR["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
    ERR["missingDoctypeName"] = "missing-doctype-name";
    ERR["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
    ERR["duplicateAttribute"] = "duplicate-attribute";
    ERR["nonConformingDoctype"] = "non-conforming-doctype";
    ERR["missingDoctype"] = "missing-doctype";
    ERR["misplacedDoctype"] = "misplaced-doctype";
    ERR["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
    ERR["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
    ERR["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
    ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
    ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
    ERR["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
    ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
    ERR["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
  })(exports2.ERR || (exports2.ERR = {}));
})(errorCodes);
Object.defineProperty(preprocessor, "__esModule", { value: true });
preprocessor.Preprocessor = void 0;
const unicode_js_1$1 = unicode$1;
const error_codes_js_1$2 = errorCodes;
const DEFAULT_BUFFER_WATERLINE = 1 << 16;
class Preprocessor {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code2) {
    const { line, col, offset } = this;
    return {
      code: code2,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset
    };
  }
  _err(code2) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code2));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if ((0, unicode_js_1$1.isSurrogatePair)(nextCp)) {
        this.pos++;
        this._addGap();
        return (0, unicode_js_1$1.getSurrogatePairCodePoint)(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return unicode_js_1$1.CODE_POINTS.EOF;
    }
    this._err(error_codes_js_1$2.ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 32;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return unicode_js_1$1.CODE_POINTS.EOF;
    }
    const code2 = this.html.charCodeAt(pos);
    return code2 === unicode_js_1$1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1$1.CODE_POINTS.LINE_FEED : code2;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return unicode_js_1$1.CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === unicode_js_1$1.CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return unicode_js_1$1.CODE_POINTS.LINE_FEED;
    }
    if (cp === unicode_js_1$1.CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if ((0, unicode_js_1$1.isSurrogate)(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === unicode_js_1$1.CODE_POINTS.LINE_FEED || cp === unicode_js_1$1.CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if ((0, unicode_js_1$1.isControlCodePoint)(cp)) {
      this._err(error_codes_js_1$2.ERR.controlCharacterInInputStream);
    } else if ((0, unicode_js_1$1.isUndefinedCodePoint)(cp)) {
      this._err(error_codes_js_1$2.ERR.noncharacterInInputStream);
    }
  }
  retreat(count2) {
    this.pos -= count2;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
}
preprocessor.Preprocessor = Preprocessor;
var token = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getTokenAttr = exports2.TokenType = void 0;
  (function(TokenType) {
    TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
    TokenType[TokenType["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
    TokenType[TokenType["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
    TokenType[TokenType["START_TAG"] = 3] = "START_TAG";
    TokenType[TokenType["END_TAG"] = 4] = "END_TAG";
    TokenType[TokenType["COMMENT"] = 5] = "COMMENT";
    TokenType[TokenType["DOCTYPE"] = 6] = "DOCTYPE";
    TokenType[TokenType["EOF"] = 7] = "EOF";
    TokenType[TokenType["HIBERNATION"] = 8] = "HIBERNATION";
  })(exports2.TokenType || (exports2.TokenType = {}));
  function getTokenAttr(token2, attrName) {
    for (let i = token2.attrs.length - 1; i >= 0; i--) {
      if (token2.attrs[i].name === attrName) {
        return token2.attrs[i].value;
      }
    }
    return null;
  }
  exports2.getTokenAttr = getTokenAttr;
})(token);
var decode$1 = {};
var decodeDataHtml$1 = {};
Object.defineProperty(decodeDataHtml$1, "__esModule", { value: true });
decodeDataHtml$1.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decodeDataXml$1 = {};
Object.defineProperty(decodeDataXml$1, "__esModule", { value: true });
decodeDataXml$1.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decode_codepoint$1 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$1);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$1);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$1);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$1;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$1);
var html$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasUnescapedText = exports2.isNumberedHeader = exports2.SPECIAL_ELEMENTS = exports2.getTagID = exports2.TAG_ID = exports2.TAG_NAMES = exports2.DOCUMENT_MODE = exports2.ATTRS = exports2.NS = void 0;
  var NS;
  (function(NS2) {
    NS2["HTML"] = "http://www.w3.org/1999/xhtml";
    NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
    NS2["SVG"] = "http://www.w3.org/2000/svg";
    NS2["XLINK"] = "http://www.w3.org/1999/xlink";
    NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
    NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
  })(NS = exports2.NS || (exports2.NS = {}));
  (function(ATTRS) {
    ATTRS["TYPE"] = "type";
    ATTRS["ACTION"] = "action";
    ATTRS["ENCODING"] = "encoding";
    ATTRS["PROMPT"] = "prompt";
    ATTRS["NAME"] = "name";
    ATTRS["COLOR"] = "color";
    ATTRS["FACE"] = "face";
    ATTRS["SIZE"] = "size";
  })(exports2.ATTRS || (exports2.ATTRS = {}));
  (function(DOCUMENT_MODE) {
    DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
    DOCUMENT_MODE["QUIRKS"] = "quirks";
    DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
  })(exports2.DOCUMENT_MODE || (exports2.DOCUMENT_MODE = {}));
  var TAG_NAMES;
  (function(TAG_NAMES2) {
    TAG_NAMES2["A"] = "a";
    TAG_NAMES2["ADDRESS"] = "address";
    TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
    TAG_NAMES2["APPLET"] = "applet";
    TAG_NAMES2["AREA"] = "area";
    TAG_NAMES2["ARTICLE"] = "article";
    TAG_NAMES2["ASIDE"] = "aside";
    TAG_NAMES2["B"] = "b";
    TAG_NAMES2["BASE"] = "base";
    TAG_NAMES2["BASEFONT"] = "basefont";
    TAG_NAMES2["BGSOUND"] = "bgsound";
    TAG_NAMES2["BIG"] = "big";
    TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
    TAG_NAMES2["BODY"] = "body";
    TAG_NAMES2["BR"] = "br";
    TAG_NAMES2["BUTTON"] = "button";
    TAG_NAMES2["CAPTION"] = "caption";
    TAG_NAMES2["CENTER"] = "center";
    TAG_NAMES2["CODE"] = "code";
    TAG_NAMES2["COL"] = "col";
    TAG_NAMES2["COLGROUP"] = "colgroup";
    TAG_NAMES2["DD"] = "dd";
    TAG_NAMES2["DESC"] = "desc";
    TAG_NAMES2["DETAILS"] = "details";
    TAG_NAMES2["DIALOG"] = "dialog";
    TAG_NAMES2["DIR"] = "dir";
    TAG_NAMES2["DIV"] = "div";
    TAG_NAMES2["DL"] = "dl";
    TAG_NAMES2["DT"] = "dt";
    TAG_NAMES2["EM"] = "em";
    TAG_NAMES2["EMBED"] = "embed";
    TAG_NAMES2["FIELDSET"] = "fieldset";
    TAG_NAMES2["FIGCAPTION"] = "figcaption";
    TAG_NAMES2["FIGURE"] = "figure";
    TAG_NAMES2["FONT"] = "font";
    TAG_NAMES2["FOOTER"] = "footer";
    TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
    TAG_NAMES2["FORM"] = "form";
    TAG_NAMES2["FRAME"] = "frame";
    TAG_NAMES2["FRAMESET"] = "frameset";
    TAG_NAMES2["H1"] = "h1";
    TAG_NAMES2["H2"] = "h2";
    TAG_NAMES2["H3"] = "h3";
    TAG_NAMES2["H4"] = "h4";
    TAG_NAMES2["H5"] = "h5";
    TAG_NAMES2["H6"] = "h6";
    TAG_NAMES2["HEAD"] = "head";
    TAG_NAMES2["HEADER"] = "header";
    TAG_NAMES2["HGROUP"] = "hgroup";
    TAG_NAMES2["HR"] = "hr";
    TAG_NAMES2["HTML"] = "html";
    TAG_NAMES2["I"] = "i";
    TAG_NAMES2["IMG"] = "img";
    TAG_NAMES2["IMAGE"] = "image";
    TAG_NAMES2["INPUT"] = "input";
    TAG_NAMES2["IFRAME"] = "iframe";
    TAG_NAMES2["KEYGEN"] = "keygen";
    TAG_NAMES2["LABEL"] = "label";
    TAG_NAMES2["LI"] = "li";
    TAG_NAMES2["LINK"] = "link";
    TAG_NAMES2["LISTING"] = "listing";
    TAG_NAMES2["MAIN"] = "main";
    TAG_NAMES2["MALIGNMARK"] = "malignmark";
    TAG_NAMES2["MARQUEE"] = "marquee";
    TAG_NAMES2["MATH"] = "math";
    TAG_NAMES2["MENU"] = "menu";
    TAG_NAMES2["META"] = "meta";
    TAG_NAMES2["MGLYPH"] = "mglyph";
    TAG_NAMES2["MI"] = "mi";
    TAG_NAMES2["MO"] = "mo";
    TAG_NAMES2["MN"] = "mn";
    TAG_NAMES2["MS"] = "ms";
    TAG_NAMES2["MTEXT"] = "mtext";
    TAG_NAMES2["NAV"] = "nav";
    TAG_NAMES2["NOBR"] = "nobr";
    TAG_NAMES2["NOFRAMES"] = "noframes";
    TAG_NAMES2["NOEMBED"] = "noembed";
    TAG_NAMES2["NOSCRIPT"] = "noscript";
    TAG_NAMES2["OBJECT"] = "object";
    TAG_NAMES2["OL"] = "ol";
    TAG_NAMES2["OPTGROUP"] = "optgroup";
    TAG_NAMES2["OPTION"] = "option";
    TAG_NAMES2["P"] = "p";
    TAG_NAMES2["PARAM"] = "param";
    TAG_NAMES2["PLAINTEXT"] = "plaintext";
    TAG_NAMES2["PRE"] = "pre";
    TAG_NAMES2["RB"] = "rb";
    TAG_NAMES2["RP"] = "rp";
    TAG_NAMES2["RT"] = "rt";
    TAG_NAMES2["RTC"] = "rtc";
    TAG_NAMES2["RUBY"] = "ruby";
    TAG_NAMES2["S"] = "s";
    TAG_NAMES2["SCRIPT"] = "script";
    TAG_NAMES2["SECTION"] = "section";
    TAG_NAMES2["SELECT"] = "select";
    TAG_NAMES2["SOURCE"] = "source";
    TAG_NAMES2["SMALL"] = "small";
    TAG_NAMES2["SPAN"] = "span";
    TAG_NAMES2["STRIKE"] = "strike";
    TAG_NAMES2["STRONG"] = "strong";
    TAG_NAMES2["STYLE"] = "style";
    TAG_NAMES2["SUB"] = "sub";
    TAG_NAMES2["SUMMARY"] = "summary";
    TAG_NAMES2["SUP"] = "sup";
    TAG_NAMES2["TABLE"] = "table";
    TAG_NAMES2["TBODY"] = "tbody";
    TAG_NAMES2["TEMPLATE"] = "template";
    TAG_NAMES2["TEXTAREA"] = "textarea";
    TAG_NAMES2["TFOOT"] = "tfoot";
    TAG_NAMES2["TD"] = "td";
    TAG_NAMES2["TH"] = "th";
    TAG_NAMES2["THEAD"] = "thead";
    TAG_NAMES2["TITLE"] = "title";
    TAG_NAMES2["TR"] = "tr";
    TAG_NAMES2["TRACK"] = "track";
    TAG_NAMES2["TT"] = "tt";
    TAG_NAMES2["U"] = "u";
    TAG_NAMES2["UL"] = "ul";
    TAG_NAMES2["SVG"] = "svg";
    TAG_NAMES2["VAR"] = "var";
    TAG_NAMES2["WBR"] = "wbr";
    TAG_NAMES2["XMP"] = "xmp";
  })(TAG_NAMES = exports2.TAG_NAMES || (exports2.TAG_NAMES = {}));
  var TAG_ID;
  (function(TAG_ID2) {
    TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
    TAG_ID2[TAG_ID2["A"] = 1] = "A";
    TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
    TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
    TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
    TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
    TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
    TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
    TAG_ID2[TAG_ID2["B"] = 8] = "B";
    TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
    TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
    TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
    TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
    TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
    TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
    TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
    TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
    TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
    TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
    TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
    TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
    TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
    TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
    TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
    TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
    TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
    TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
    TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
    TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
    TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
    TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
    TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
    TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
    TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
    TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
    TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
    TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
    TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
    TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
    TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
    TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
    TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
    TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
    TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
    TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
    TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
    TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
    TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
    TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
    TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
    TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
    TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
    TAG_ID2[TAG_ID2["I"] = 52] = "I";
    TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
    TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
    TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
    TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
    TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
    TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
    TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
    TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
    TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
    TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
    TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
    TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
    TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
    TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
    TAG_ID2[TAG_ID2["META"] = 67] = "META";
    TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
    TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
    TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
    TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
    TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
    TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
    TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
    TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
    TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
    TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
    TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
    TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
    TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
    TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
    TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
    TAG_ID2[TAG_ID2["P"] = 83] = "P";
    TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
    TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
    TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
    TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
    TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
    TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
    TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
    TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
    TAG_ID2[TAG_ID2["S"] = 92] = "S";
    TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
    TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
    TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
    TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
    TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
    TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
    TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
    TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
    TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
    TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
    TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
    TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
    TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
    TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
    TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
    TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
    TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
    TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
    TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
    TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
    TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
    TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
    TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
    TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
    TAG_ID2[TAG_ID2["U"] = 117] = "U";
    TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
    TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
    TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
    TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
    TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
  })(TAG_ID = exports2.TAG_ID || (exports2.TAG_ID = {}));
  const TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
    [TAG_NAMES.A, TAG_ID.A],
    [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
    [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
    [TAG_NAMES.APPLET, TAG_ID.APPLET],
    [TAG_NAMES.AREA, TAG_ID.AREA],
    [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
    [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
    [TAG_NAMES.B, TAG_ID.B],
    [TAG_NAMES.BASE, TAG_ID.BASE],
    [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
    [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
    [TAG_NAMES.BIG, TAG_ID.BIG],
    [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
    [TAG_NAMES.BODY, TAG_ID.BODY],
    [TAG_NAMES.BR, TAG_ID.BR],
    [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
    [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
    [TAG_NAMES.CENTER, TAG_ID.CENTER],
    [TAG_NAMES.CODE, TAG_ID.CODE],
    [TAG_NAMES.COL, TAG_ID.COL],
    [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
    [TAG_NAMES.DD, TAG_ID.DD],
    [TAG_NAMES.DESC, TAG_ID.DESC],
    [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
    [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
    [TAG_NAMES.DIR, TAG_ID.DIR],
    [TAG_NAMES.DIV, TAG_ID.DIV],
    [TAG_NAMES.DL, TAG_ID.DL],
    [TAG_NAMES.DT, TAG_ID.DT],
    [TAG_NAMES.EM, TAG_ID.EM],
    [TAG_NAMES.EMBED, TAG_ID.EMBED],
    [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
    [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
    [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
    [TAG_NAMES.FONT, TAG_ID.FONT],
    [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
    [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
    [TAG_NAMES.FORM, TAG_ID.FORM],
    [TAG_NAMES.FRAME, TAG_ID.FRAME],
    [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
    [TAG_NAMES.H1, TAG_ID.H1],
    [TAG_NAMES.H2, TAG_ID.H2],
    [TAG_NAMES.H3, TAG_ID.H3],
    [TAG_NAMES.H4, TAG_ID.H4],
    [TAG_NAMES.H5, TAG_ID.H5],
    [TAG_NAMES.H6, TAG_ID.H6],
    [TAG_NAMES.HEAD, TAG_ID.HEAD],
    [TAG_NAMES.HEADER, TAG_ID.HEADER],
    [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
    [TAG_NAMES.HR, TAG_ID.HR],
    [TAG_NAMES.HTML, TAG_ID.HTML],
    [TAG_NAMES.I, TAG_ID.I],
    [TAG_NAMES.IMG, TAG_ID.IMG],
    [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
    [TAG_NAMES.INPUT, TAG_ID.INPUT],
    [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
    [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
    [TAG_NAMES.LABEL, TAG_ID.LABEL],
    [TAG_NAMES.LI, TAG_ID.LI],
    [TAG_NAMES.LINK, TAG_ID.LINK],
    [TAG_NAMES.LISTING, TAG_ID.LISTING],
    [TAG_NAMES.MAIN, TAG_ID.MAIN],
    [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
    [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
    [TAG_NAMES.MATH, TAG_ID.MATH],
    [TAG_NAMES.MENU, TAG_ID.MENU],
    [TAG_NAMES.META, TAG_ID.META],
    [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
    [TAG_NAMES.MI, TAG_ID.MI],
    [TAG_NAMES.MO, TAG_ID.MO],
    [TAG_NAMES.MN, TAG_ID.MN],
    [TAG_NAMES.MS, TAG_ID.MS],
    [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
    [TAG_NAMES.NAV, TAG_ID.NAV],
    [TAG_NAMES.NOBR, TAG_ID.NOBR],
    [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
    [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
    [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
    [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
    [TAG_NAMES.OL, TAG_ID.OL],
    [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
    [TAG_NAMES.OPTION, TAG_ID.OPTION],
    [TAG_NAMES.P, TAG_ID.P],
    [TAG_NAMES.PARAM, TAG_ID.PARAM],
    [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
    [TAG_NAMES.PRE, TAG_ID.PRE],
    [TAG_NAMES.RB, TAG_ID.RB],
    [TAG_NAMES.RP, TAG_ID.RP],
    [TAG_NAMES.RT, TAG_ID.RT],
    [TAG_NAMES.RTC, TAG_ID.RTC],
    [TAG_NAMES.RUBY, TAG_ID.RUBY],
    [TAG_NAMES.S, TAG_ID.S],
    [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
    [TAG_NAMES.SECTION, TAG_ID.SECTION],
    [TAG_NAMES.SELECT, TAG_ID.SELECT],
    [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
    [TAG_NAMES.SMALL, TAG_ID.SMALL],
    [TAG_NAMES.SPAN, TAG_ID.SPAN],
    [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
    [TAG_NAMES.STRONG, TAG_ID.STRONG],
    [TAG_NAMES.STYLE, TAG_ID.STYLE],
    [TAG_NAMES.SUB, TAG_ID.SUB],
    [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
    [TAG_NAMES.SUP, TAG_ID.SUP],
    [TAG_NAMES.TABLE, TAG_ID.TABLE],
    [TAG_NAMES.TBODY, TAG_ID.TBODY],
    [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
    [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
    [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
    [TAG_NAMES.TD, TAG_ID.TD],
    [TAG_NAMES.TH, TAG_ID.TH],
    [TAG_NAMES.THEAD, TAG_ID.THEAD],
    [TAG_NAMES.TITLE, TAG_ID.TITLE],
    [TAG_NAMES.TR, TAG_ID.TR],
    [TAG_NAMES.TRACK, TAG_ID.TRACK],
    [TAG_NAMES.TT, TAG_ID.TT],
    [TAG_NAMES.U, TAG_ID.U],
    [TAG_NAMES.UL, TAG_ID.UL],
    [TAG_NAMES.SVG, TAG_ID.SVG],
    [TAG_NAMES.VAR, TAG_ID.VAR],
    [TAG_NAMES.WBR, TAG_ID.WBR],
    [TAG_NAMES.XMP, TAG_ID.XMP]
  ]);
  function getTagID(tagName) {
    var _a;
    return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0 ? _a : TAG_ID.UNKNOWN;
  }
  exports2.getTagID = getTagID;
  const $ = TAG_ID;
  exports2.SPECIAL_ELEMENTS = {
    [NS.HTML]: /* @__PURE__ */ new Set([
      $.ADDRESS,
      $.APPLET,
      $.AREA,
      $.ARTICLE,
      $.ASIDE,
      $.BASE,
      $.BASEFONT,
      $.BGSOUND,
      $.BLOCKQUOTE,
      $.BODY,
      $.BR,
      $.BUTTON,
      $.CAPTION,
      $.CENTER,
      $.COL,
      $.COLGROUP,
      $.DD,
      $.DETAILS,
      $.DIR,
      $.DIV,
      $.DL,
      $.DT,
      $.EMBED,
      $.FIELDSET,
      $.FIGCAPTION,
      $.FIGURE,
      $.FOOTER,
      $.FORM,
      $.FRAME,
      $.FRAMESET,
      $.H1,
      $.H2,
      $.H3,
      $.H4,
      $.H5,
      $.H6,
      $.HEAD,
      $.HEADER,
      $.HGROUP,
      $.HR,
      $.HTML,
      $.IFRAME,
      $.IMG,
      $.INPUT,
      $.LI,
      $.LINK,
      $.LISTING,
      $.MAIN,
      $.MARQUEE,
      $.MENU,
      $.META,
      $.NAV,
      $.NOEMBED,
      $.NOFRAMES,
      $.NOSCRIPT,
      $.OBJECT,
      $.OL,
      $.P,
      $.PARAM,
      $.PLAINTEXT,
      $.PRE,
      $.SCRIPT,
      $.SECTION,
      $.SELECT,
      $.SOURCE,
      $.STYLE,
      $.SUMMARY,
      $.TABLE,
      $.TBODY,
      $.TD,
      $.TEMPLATE,
      $.TEXTAREA,
      $.TFOOT,
      $.TH,
      $.THEAD,
      $.TITLE,
      $.TR,
      $.TRACK,
      $.UL,
      $.WBR,
      $.XMP
    ]),
    [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
    [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
    [NS.XLINK]: /* @__PURE__ */ new Set(),
    [NS.XML]: /* @__PURE__ */ new Set(),
    [NS.XMLNS]: /* @__PURE__ */ new Set()
  };
  function isNumberedHeader(tn) {
    return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
  }
  exports2.isNumberedHeader = isNumberedHeader;
  const UNESCAPED_TEXT = /* @__PURE__ */ new Set([
    TAG_NAMES.STYLE,
    TAG_NAMES.SCRIPT,
    TAG_NAMES.XMP,
    TAG_NAMES.IFRAME,
    TAG_NAMES.NOEMBED,
    TAG_NAMES.NOFRAMES,
    TAG_NAMES.PLAINTEXT
  ]);
  function hasUnescapedText(tn, scriptingEnabled) {
    return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
  }
  exports2.hasUnescapedText = hasUnescapedText;
})(html$4);
Object.defineProperty(tokenizer, "__esModule", { value: true });
tokenizer.Tokenizer = tokenizer.TokenizerMode = void 0;
const preprocessor_js_1 = preprocessor;
const unicode_js_1 = unicode$1;
const token_js_1$1 = token;
const decode_js_1$1 = decode$1;
const error_codes_js_1$1 = errorCodes;
const html_js_1$4 = html$4;
const C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var State;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
  State2[State2["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
  State2[State2["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
  State2[State2["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State || (State = {}));
tokenizer.TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.DIGIT_0 && cp <= unicode_js_1.CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === unicode_js_1.CODE_POINTS.SPACE || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.TABULATION || cp === unicode_js_1.CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd(nextCp) {
  return nextCp === unicode_js_1.CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === unicode_js_1.CODE_POINTS.SOLIDUS || cp === unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN;
}
let Tokenizer$1 = class Tokenizer {
  constructor(options2, handler) {
    this.options = options2;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new preprocessor_js_1.Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code2) {
    var _a, _b;
    (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code2));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count2) {
    this.consumedAfterSnapshot -= count2;
    this.preprocessor.retreat(count2);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count2) {
    this.consumedAfterSnapshot += count2;
    for (let i = 0; i < count2; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: token_js_1$1.TokenType.START_TAG,
      tagName: "",
      tagID: html_js_1$4.TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: token_js_1$1.TokenType.END_TAG,
      tagName: "",
      tagID: html_js_1$4.TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: token_js_1$1.TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: token_js_1$1.TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a;
    var _b;
    const token2 = this.currentToken;
    if ((0, token_js_1$1.getTokenAttr)(token2, this.currentAttr.name) === null) {
      token2.attrs.push(this.currentAttr);
      if (token2.location && this.currentLocation) {
        const attrLocations = (_a = (_b = token2.location).attrs) !== null && _a !== void 0 ? _a : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(error_codes_js_1$1.ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = (0, html_js_1$4.getTagID)(ct.tagName);
    if (ct.type === token_js_1$1.TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(error_codes_js_1$1.ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(error_codes_js_1$1.ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case token_js_1$1.TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case token_js_1$1.TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case token_js_1$1.TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location2 = this.getCurrentLocation(0);
    if (location2) {
      location2.endLine = location2.startLine;
      location2.endCol = location2.startCol;
      location2.endOffset = location2.startOffset;
    }
    this._emitCurrentCharacterToken(location2);
    this.handler.onEof({ type: token_js_1$1.TokenType.EOF, location: location2 });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace(cp) ? token_js_1$1.TokenType.WHITESPACE_CHARACTER : cp === unicode_js_1.CODE_POINTS.NULL ? token_js_1$1.TokenType.NULL_CHARACTER : token_js_1$1.TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(token_js_1$1.TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i = 0, current = decode_js_1$1.htmlDecodeTree[0]; i >= 0; cp = this._consume()) {
      i = (0, decode_js_1$1.determineBranch)(decode_js_1$1.htmlDecodeTree, current, i + 1, cp);
      if (i < 0)
        break;
      excess += 1;
      current = decode_js_1$1.htmlDecodeTree[i];
      const masked = current & decode_js_1$1.BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (cp !== unicode_js_1.CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))) {
          result = [unicode_js_1.CODE_POINTS.AMPERSAND];
          i += valueLength;
        } else {
          result = valueLength === 0 ? [decode_js_1$1.htmlDecodeTree[i] & ~decode_js_1$1.BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_js_1$1.htmlDecodeTree[++i]] : [decode_js_1$1.htmlDecodeTree[++i], decode_js_1$1.htmlDecodeTree[++i]];
          excess = 0;
          withoutSemicolon = cp !== unicode_js_1.CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(error_codes_js_1$1.ERR.missingSemicolonAfterCharacterReference);
    }
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.DATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.RCDATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case unicode_js_1.CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case unicode_js_1.CODE_POINTS.QUESTION_MARK: {
          this._err(error_codes_js_1$1.ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case unicode_js_1.CODE_POINTS.EOF: {
          this._err(error_codes_js_1$1.ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(error_codes_js_1$1.ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(error_codes_js_1$1.ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case unicode_js_1.CODE_POINTS.EOF: {
          this._err(error_codes_js_1$1.ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(error_codes_js_1$1.ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.tagName += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token2 = this.currentToken;
    token2.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
        this._err(error_codes_js_1$1.ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
      case unicode_js_1.CODE_POINTS.SOLIDUS:
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.name += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
      case unicode_js_1.CODE_POINTS.GRAVE_ACCENT: {
        this._err(error_codes_js_1$1.ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        const token2 = this.currentToken;
        token2.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.data += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token2.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(unicode_js_1.SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(unicode_js_1.SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(error_codes_js_1$1.ERR.cdataInHtmlContent);
        this._createCommentToken(unicode_js_1.SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(error_codes_js_1$1.ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token2 = this.currentToken;
        this.emitCurrentComment(token2);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        token2.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.data += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
        token2.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        token2.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN && cp !== unicode_js_1.CODE_POINTS.EOF) {
      this._err(error_codes_js_1$1.ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        token2.data += "-";
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        token2.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token2 = this.currentToken;
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case unicode_js_1.CODE_POINTS.SPACE:
        case unicode_js_1.CODE_POINTS.LINE_FEED:
        case unicode_js_1.CODE_POINTS.TABULATION:
        case unicode_js_1.CODE_POINTS.FORM_FEED: {
          break;
        }
        case unicode_js_1.CODE_POINTS.NULL: {
          this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
          this._createDoctypeToken(unicode_js_1.REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(error_codes_js_1$1.ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token2 = this.currentToken;
          token2.forceQuirks = true;
          this.emitCurrentDoctype(token2);
          this.state = State.DATA;
          break;
        }
        case unicode_js_1.CODE_POINTS.EOF: {
          this._err(error_codes_js_1$1.ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token2 = this.currentToken;
          token2.forceQuirks = true;
          this.emitCurrentDoctype(token2);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.name += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(error_codes_js_1$1.ERR.invalidCharacterSequenceAfterDoctypeName);
          token2.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === unicode_js_1.CODE_POINTS.NUMBER_SIGN) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric(cp)) {
      this.state = State.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    if (this._ensureHibernation())
      ;
    else if (matchResult) {
      for (let i = 0; i < matchResult.length; i++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this.state = State.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
        this._err(error_codes_js_1$1.ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (cp === unicode_js_1.CODE_POINTS.LATIN_SMALL_X || cp === unicode_js_1.CODE_POINTS.LATIN_CAPITAL_X) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;
    } else if (isAsciiDigit(cp)) {
      this.state = State.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(error_codes_js_1$1.ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(error_codes_js_1$1.ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 55;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 87;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 48;
    } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(error_codes_js_1$1.ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 48;
    } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(error_codes_js_1$1.ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === unicode_js_1.CODE_POINTS.NULL) {
      this._err(error_codes_js_1$1.ERR.nullCharacterReference);
      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(error_codes_js_1$1.ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if ((0, unicode_js_1.isSurrogate)(this.charRefCode)) {
      this._err(error_codes_js_1$1.ERR.surrogateCharacterReference);
      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if ((0, unicode_js_1.isUndefinedCodePoint)(this.charRefCode)) {
      this._err(error_codes_js_1$1.ERR.noncharacterCharacterReference);
    } else if ((0, unicode_js_1.isControlCodePoint)(this.charRefCode) || this.charRefCode === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
      this._err(error_codes_js_1$1.ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      if (replacement !== void 0) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};
tokenizer.Tokenizer = Tokenizer$1;
var openElementStack = {};
Object.defineProperty(openElementStack, "__esModule", { value: true });
openElementStack.OpenElementStack = void 0;
const html_js_1$3 = html$4;
const IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([html_js_1$3.TAG_ID.DD, html_js_1$3.TAG_ID.DT, html_js_1$3.TAG_ID.LI, html_js_1$3.TAG_ID.OPTGROUP, html_js_1$3.TAG_ID.OPTION, html_js_1$3.TAG_ID.P, html_js_1$3.TAG_ID.RB, html_js_1$3.TAG_ID.RP, html_js_1$3.TAG_ID.RT, html_js_1$3.TAG_ID.RTC]);
const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  html_js_1$3.TAG_ID.CAPTION,
  html_js_1$3.TAG_ID.COLGROUP,
  html_js_1$3.TAG_ID.TBODY,
  html_js_1$3.TAG_ID.TD,
  html_js_1$3.TAG_ID.TFOOT,
  html_js_1$3.TAG_ID.TH,
  html_js_1$3.TAG_ID.THEAD,
  html_js_1$3.TAG_ID.TR
]);
const SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
  [html_js_1$3.TAG_ID.APPLET, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.CAPTION, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.HTML, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.MARQUEE, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.OBJECT, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TABLE, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TD, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TH, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.ANNOTATION_XML, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MI, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MN, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MO, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MS, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MTEXT, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.DESC, html_js_1$3.NS.SVG],
  [html_js_1$3.TAG_ID.FOREIGN_OBJECT, html_js_1$3.NS.SVG],
  [html_js_1$3.TAG_ID.TITLE, html_js_1$3.NS.SVG]
]);
const NAMED_HEADERS = [html_js_1$3.TAG_ID.H1, html_js_1$3.TAG_ID.H2, html_js_1$3.TAG_ID.H3, html_js_1$3.TAG_ID.H4, html_js_1$3.TAG_ID.H5, html_js_1$3.TAG_ID.H6];
const TABLE_ROW_CONTEXT = [html_js_1$3.TAG_ID.TR, html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.TAG_ID.HTML];
const TABLE_BODY_CONTEXT = [html_js_1$3.TAG_ID.TBODY, html_js_1$3.TAG_ID.TFOOT, html_js_1$3.TAG_ID.THEAD, html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.TAG_ID.HTML];
const TABLE_CONTEXT = [html_js_1$3.TAG_ID.TABLE, html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.TAG_ID.HTML];
const TABLE_CELLS = [html_js_1$3.TAG_ID.TD, html_js_1$3.TAG_ID.TH];
class OpenElementStack {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = html_js_1$3.TAG_ID.UNKNOWN;
    this.current = document;
  }
  //Index of element
  _indexOf(element2) {
    return this.items.lastIndexOf(element2, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === html_js_1$3.TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === html_js_1$3.NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element2, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element2;
    this.current = element2;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element2, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== html_js_1$3.NS.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element2) {
    const idx = this._indexOf(element2);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, html_js_1$3.NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, html_js_1$3.NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, html_js_1$3.NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, html_js_1$3.NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, html_js_1$3.NS.HTML);
  }
  remove(element2) {
    const idx = this._indexOf(element2);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element2, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === html_js_1$3.TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element2) {
    return this._indexOf(element2) > -1;
  }
  getCommonAncestor(element2) {
    const elementIdx = this._indexOf(element2) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === html_js_1$3.TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if ((0, html_js_1$3.isNumberedHeader)(tn) && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if ((tn === html_js_1$3.TAG_ID.UL || tn === html_js_1$3.TAG_ID.OL) && ns === html_js_1$3.NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if (tn === html_js_1$3.TAG_ID.BUTTON && ns === html_js_1$3.NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== html_js_1$3.NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === html_js_1$3.TAG_ID.TABLE || tn === html_js_1$3.TAG_ID.TEMPLATE || tn === html_js_1$3.TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== html_js_1$3.NS.HTML) {
        continue;
      }
      if (tn === html_js_1$3.TAG_ID.TBODY || tn === html_js_1$3.TAG_ID.THEAD || tn === html_js_1$3.TAG_ID.TFOOT) {
        return true;
      }
      if (tn === html_js_1$3.TAG_ID.TABLE || tn === html_js_1$3.TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== html_js_1$3.NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== html_js_1$3.TAG_ID.OPTION && tn !== html_js_1$3.TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
}
openElementStack.OpenElementStack = OpenElementStack;
var formattingElementList = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.FormattingElementList = exports2.EntryType = void 0;
  const NOAH_ARK_CAPACITY = 3;
  var EntryType;
  (function(EntryType2) {
    EntryType2[EntryType2["Marker"] = 0] = "Marker";
    EntryType2[EntryType2["Element"] = 1] = "Element";
  })(EntryType = exports2.EntryType || (exports2.EntryType = {}));
  const MARKER = { type: EntryType.Marker };
  class FormattingElementList {
    constructor(treeAdapter) {
      this.treeAdapter = treeAdapter;
      this.entries = [];
      this.bookmark = null;
    }
    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement, neAttrs) {
      const candidates = [];
      const neAttrsLength = neAttrs.length;
      const neTagName = this.treeAdapter.getTagName(newElement);
      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        if (entry.type === EntryType.Marker) {
          break;
        }
        const { element: element2 } = entry;
        if (this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI) {
          const elementAttrs = this.treeAdapter.getAttrList(element2);
          if (elementAttrs.length === neAttrsLength) {
            candidates.push({ idx: i, attrs: elementAttrs });
          }
        }
      }
      return candidates;
    }
    _ensureNoahArkCondition(newElement) {
      if (this.entries.length < NOAH_ARK_CAPACITY)
        return;
      const neAttrs = this.treeAdapter.getAttrList(newElement);
      const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
      if (candidates.length < NOAH_ARK_CAPACITY)
        return;
      const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
      let validCandidates = 0;
      for (let i = 0; i < candidates.length; i++) {
        const candidate = candidates[i];
        if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
          validCandidates += 1;
          if (validCandidates >= NOAH_ARK_CAPACITY) {
            this.entries.splice(candidate.idx, 1);
          }
        }
      }
    }
    //Mutations
    insertMarker() {
      this.entries.unshift(MARKER);
    }
    pushElement(element2, token2) {
      this._ensureNoahArkCondition(element2);
      this.entries.unshift({
        type: EntryType.Element,
        element: element2,
        token: token2
      });
    }
    insertElementAfterBookmark(element2, token2) {
      const bookmarkIdx = this.entries.indexOf(this.bookmark);
      this.entries.splice(bookmarkIdx, 0, {
        type: EntryType.Element,
        element: element2,
        token: token2
      });
    }
    removeEntry(entry) {
      const entryIndex = this.entries.indexOf(entry);
      if (entryIndex >= 0) {
        this.entries.splice(entryIndex, 1);
      }
    }
    /**
     * Clears the list of formatting elements up to the last marker.
     *
     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
     */
    clearToLastMarker() {
      const markerIdx = this.entries.indexOf(MARKER);
      if (markerIdx >= 0) {
        this.entries.splice(0, markerIdx + 1);
      } else {
        this.entries.length = 0;
      }
    }
    //Search
    getElementEntryInScopeWithTagName(tagName) {
      const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
      return entry && entry.type === EntryType.Element ? entry : null;
    }
    getElementEntry(element2) {
      return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element2);
    }
  }
  exports2.FormattingElementList = FormattingElementList;
})(formattingElementList);
var _default = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.defaultTreeAdapter = void 0;
  const html_js_12 = html$4;
  function createTextNode(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  }
  exports2.defaultTreeAdapter = {
    //Node construction
    createDocument() {
      return {
        nodeName: "#document",
        mode: html_js_12.DOCUMENT_MODE.NO_QUIRKS,
        childNodes: []
      };
    },
    createDocumentFragment() {
      return {
        nodeName: "#document-fragment",
        childNodes: []
      };
    },
    createElement(tagName, namespaceURI, attrs) {
      return {
        nodeName: tagName,
        tagName,
        attrs,
        namespaceURI,
        childNodes: [],
        parentNode: null
      };
    },
    createCommentNode(data2) {
      return {
        nodeName: "#comment",
        data: data2,
        parentNode: null
      };
    },
    //Tree mutation
    appendChild(parentNode, newNode) {
      parentNode.childNodes.push(newNode);
      newNode.parentNode = parentNode;
    },
    insertBefore(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
      parentNode.childNodes.splice(insertionIdx, 0, newNode);
      newNode.parentNode = parentNode;
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(document, name2, publicId, systemId) {
      const doctypeNode = document.childNodes.find((node2) => node2.nodeName === "#documentType");
      if (doctypeNode) {
        doctypeNode.name = name2;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
      } else {
        const node2 = {
          nodeName: "#documentType",
          name: name2,
          publicId,
          systemId,
          parentNode: null
        };
        exports2.defaultTreeAdapter.appendChild(document, node2);
      }
    },
    setDocumentMode(document, mode) {
      document.mode = mode;
    },
    getDocumentMode(document) {
      return document.mode;
    },
    detachNode(node2) {
      if (node2.parentNode) {
        const idx = node2.parentNode.childNodes.indexOf(node2);
        node2.parentNode.childNodes.splice(idx, 1);
        node2.parentNode = null;
      }
    },
    insertText(parentNode, text2) {
      if (parentNode.childNodes.length > 0) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
        if (exports2.defaultTreeAdapter.isTextNode(prevNode)) {
          prevNode.value += text2;
          return;
        }
      }
      exports2.defaultTreeAdapter.appendChild(parentNode, createTextNode(text2));
    },
    insertTextBefore(parentNode, text2, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode && exports2.defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text2;
      } else {
        exports2.defaultTreeAdapter.insertBefore(parentNode, createTextNode(text2), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
      for (let j = 0; j < attrs.length; j++) {
        if (!recipientAttrsMap.has(attrs[j].name)) {
          recipient.attrs.push(attrs[j]);
        }
      }
    },
    //Tree traversing
    getFirstChild(node2) {
      return node2.childNodes[0];
    },
    getChildNodes(node2) {
      return node2.childNodes;
    },
    getParentNode(node2) {
      return node2.parentNode;
    },
    getAttrList(element2) {
      return element2.attrs;
    },
    //Node data
    getTagName(element2) {
      return element2.tagName;
    },
    getNamespaceURI(element2) {
      return element2.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.value;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.data;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode.name;
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode.publicId;
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode.systemId;
    },
    //Node types
    isTextNode(node2) {
      return node2.nodeName === "#text";
    },
    isCommentNode(node2) {
      return node2.nodeName === "#comment";
    },
    isDocumentTypeNode(node2) {
      return node2.nodeName === "#documentType";
    },
    isElementNode(node2) {
      return Object.prototype.hasOwnProperty.call(node2, "tagName");
    },
    // Source code location
    setNodeSourceCodeLocation(node2, location2) {
      node2.sourceCodeLocation = location2;
    },
    getNodeSourceCodeLocation(node2) {
      return node2.sourceCodeLocation;
    },
    updateNodeSourceCodeLocation(node2, endLocation) {
      node2.sourceCodeLocation = Object.assign(Object.assign({}, node2.sourceCodeLocation), endLocation);
    }
  };
})(_default);
var doctype$2 = {};
Object.defineProperty(doctype$2, "__esModule", { value: true });
doctype$2.getDocumentMode = doctype$2.isConforming = void 0;
const html_js_1$2 = html$4;
const VALID_DOCTYPE_NAME = "html";
const VALID_SYSTEM_ID = "about:legacy-compat";
const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
const QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token2) {
  return token2.name === VALID_DOCTYPE_NAME && token2.publicId === null && (token2.systemId === null || token2.systemId === VALID_SYSTEM_ID);
}
doctype$2.isConforming = isConforming;
function getDocumentMode(token2) {
  if (token2.name !== VALID_DOCTYPE_NAME) {
    return html_js_1$2.DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token2;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return html_js_1$2.DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token2;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return html_js_1$2.DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return html_js_1$2.DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return html_js_1$2.DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return html_js_1$2.DOCUMENT_MODE.NO_QUIRKS;
}
doctype$2.getDocumentMode = getDocumentMode;
var foreignContent$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isIntegrationPoint = exports2.adjustTokenSVGTagName = exports2.adjustTokenXMLAttrs = exports2.adjustTokenSVGAttrs = exports2.adjustTokenMathMLAttrs = exports2.causesExit = exports2.SVG_TAG_NAMES_ADJUSTMENT_MAP = void 0;
  const html_js_12 = html$4;
  const MIME_TYPES = {
    TEXT_HTML: "text/html",
    APPLICATION_XML: "application/xhtml+xml"
  };
  const DEFINITION_URL_ATTR = "definitionurl";
  const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
  const SVG_ATTRS_ADJUSTMENT_MAP = new Map([
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((attr2) => [attr2.toLowerCase(), attr2]));
  const XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
    ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: html_js_12.NS.XLINK }],
    ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: html_js_12.NS.XLINK }],
    ["xlink:href", { prefix: "xlink", name: "href", namespace: html_js_12.NS.XLINK }],
    ["xlink:role", { prefix: "xlink", name: "role", namespace: html_js_12.NS.XLINK }],
    ["xlink:show", { prefix: "xlink", name: "show", namespace: html_js_12.NS.XLINK }],
    ["xlink:title", { prefix: "xlink", name: "title", namespace: html_js_12.NS.XLINK }],
    ["xlink:type", { prefix: "xlink", name: "type", namespace: html_js_12.NS.XLINK }],
    ["xml:base", { prefix: "xml", name: "base", namespace: html_js_12.NS.XML }],
    ["xml:lang", { prefix: "xml", name: "lang", namespace: html_js_12.NS.XML }],
    ["xml:space", { prefix: "xml", name: "space", namespace: html_js_12.NS.XML }],
    ["xmlns", { prefix: "", name: "xmlns", namespace: html_js_12.NS.XMLNS }],
    ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: html_js_12.NS.XMLNS }]
  ]);
  exports2.SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((tn) => [tn.toLowerCase(), tn]));
  const EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
    html_js_12.TAG_ID.B,
    html_js_12.TAG_ID.BIG,
    html_js_12.TAG_ID.BLOCKQUOTE,
    html_js_12.TAG_ID.BODY,
    html_js_12.TAG_ID.BR,
    html_js_12.TAG_ID.CENTER,
    html_js_12.TAG_ID.CODE,
    html_js_12.TAG_ID.DD,
    html_js_12.TAG_ID.DIV,
    html_js_12.TAG_ID.DL,
    html_js_12.TAG_ID.DT,
    html_js_12.TAG_ID.EM,
    html_js_12.TAG_ID.EMBED,
    html_js_12.TAG_ID.H1,
    html_js_12.TAG_ID.H2,
    html_js_12.TAG_ID.H3,
    html_js_12.TAG_ID.H4,
    html_js_12.TAG_ID.H5,
    html_js_12.TAG_ID.H6,
    html_js_12.TAG_ID.HEAD,
    html_js_12.TAG_ID.HR,
    html_js_12.TAG_ID.I,
    html_js_12.TAG_ID.IMG,
    html_js_12.TAG_ID.LI,
    html_js_12.TAG_ID.LISTING,
    html_js_12.TAG_ID.MENU,
    html_js_12.TAG_ID.META,
    html_js_12.TAG_ID.NOBR,
    html_js_12.TAG_ID.OL,
    html_js_12.TAG_ID.P,
    html_js_12.TAG_ID.PRE,
    html_js_12.TAG_ID.RUBY,
    html_js_12.TAG_ID.S,
    html_js_12.TAG_ID.SMALL,
    html_js_12.TAG_ID.SPAN,
    html_js_12.TAG_ID.STRONG,
    html_js_12.TAG_ID.STRIKE,
    html_js_12.TAG_ID.SUB,
    html_js_12.TAG_ID.SUP,
    html_js_12.TAG_ID.TABLE,
    html_js_12.TAG_ID.TT,
    html_js_12.TAG_ID.U,
    html_js_12.TAG_ID.UL,
    html_js_12.TAG_ID.VAR
  ]);
  function causesExit(startTagToken) {
    const tn = startTagToken.tagID;
    const isFontWithAttrs = tn === html_js_12.TAG_ID.FONT && startTagToken.attrs.some(({ name: name2 }) => name2 === html_js_12.ATTRS.COLOR || name2 === html_js_12.ATTRS.SIZE || name2 === html_js_12.ATTRS.FACE);
    return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
  }
  exports2.causesExit = causesExit;
  function adjustTokenMathMLAttrs(token2) {
    for (let i = 0; i < token2.attrs.length; i++) {
      if (token2.attrs[i].name === DEFINITION_URL_ATTR) {
        token2.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
        break;
      }
    }
  }
  exports2.adjustTokenMathMLAttrs = adjustTokenMathMLAttrs;
  function adjustTokenSVGAttrs(token2) {
    for (let i = 0; i < token2.attrs.length; i++) {
      const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token2.attrs[i].name);
      if (adjustedAttrName != null) {
        token2.attrs[i].name = adjustedAttrName;
      }
    }
  }
  exports2.adjustTokenSVGAttrs = adjustTokenSVGAttrs;
  function adjustTokenXMLAttrs(token2) {
    for (let i = 0; i < token2.attrs.length; i++) {
      const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token2.attrs[i].name);
      if (adjustedAttrEntry) {
        token2.attrs[i].prefix = adjustedAttrEntry.prefix;
        token2.attrs[i].name = adjustedAttrEntry.name;
        token2.attrs[i].namespace = adjustedAttrEntry.namespace;
      }
    }
  }
  exports2.adjustTokenXMLAttrs = adjustTokenXMLAttrs;
  function adjustTokenSVGTagName(token2) {
    const adjustedTagName = exports2.SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token2.tagName);
    if (adjustedTagName != null) {
      token2.tagName = adjustedTagName;
      token2.tagID = (0, html_js_12.getTagID)(token2.tagName);
    }
  }
  exports2.adjustTokenSVGTagName = adjustTokenSVGTagName;
  function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === html_js_12.NS.MATHML && (tn === html_js_12.TAG_ID.MI || tn === html_js_12.TAG_ID.MO || tn === html_js_12.TAG_ID.MN || tn === html_js_12.TAG_ID.MS || tn === html_js_12.TAG_ID.MTEXT);
  }
  function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === html_js_12.NS.MATHML && tn === html_js_12.TAG_ID.ANNOTATION_XML) {
      for (let i = 0; i < attrs.length; i++) {
        if (attrs[i].name === html_js_12.ATTRS.ENCODING) {
          const value = attrs[i].value.toLowerCase();
          return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
        }
      }
    }
    return ns === html_js_12.NS.SVG && (tn === html_js_12.TAG_ID.FOREIGN_OBJECT || tn === html_js_12.TAG_ID.DESC || tn === html_js_12.TAG_ID.TITLE);
  }
  function isIntegrationPoint(tn, ns, attrs, foreignNS) {
    return (!foreignNS || foreignNS === html_js_12.NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === html_js_12.NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
  }
  exports2.isIntegrationPoint = isIntegrationPoint;
})(foreignContent$1);
Object.defineProperty(parser$2, "__esModule", { value: true });
parser$2.Parser = void 0;
const index_js_1 = tokenizer;
const open_element_stack_js_1 = openElementStack;
const formatting_element_list_js_1 = formattingElementList;
const default_js_1$1 = _default;
const doctype$1 = doctype$2;
const foreignContent = foreignContent$1;
const error_codes_js_1 = errorCodes;
const unicode = unicode$1;
const html_js_1$1 = html$4;
const token_js_1 = token;
const HIDDEN_INPUT_TYPE = "hidden";
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
const TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([html_js_1$1.TAG_ID.TABLE, html_js_1$1.TAG_ID.TBODY, html_js_1$1.TAG_ID.TFOOT, html_js_1$1.TAG_ID.THEAD, html_js_1$1.TAG_ID.TR]);
const defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: default_js_1$1.defaultTreeAdapter,
  onParseError: null
};
let Parser$2 = class Parser {
  constructor(options2, document, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = Object.assign(Object.assign({}, defaultParserOptions), options2);
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
    this.tokenizer = new index_js_1.Tokenizer(this.options, this);
    this.activeFormattingElements = new formatting_element_list_js_1.FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? (0, html_js_1$1.getTagID)(this.treeAdapter.getTagName(fragmentContext)) : html_js_1$1.TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new open_element_stack_js_1.OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html2, options2) {
    const parser2 = new this(options2);
    parser2.tokenizer.write(html2, true);
    return parser2.document;
  }
  static getFragmentParser(fragmentContext, options2) {
    const opts = Object.assign(Object.assign({}, defaultParserOptions), options2);
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(html_js_1$1.TAG_NAMES.TEMPLATE, html_js_1$1.NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", html_js_1$1.NS.HTML, []);
    const parser2 = new this(opts, documentMock, fragmentContext);
    if (parser2.fragmentContextID === html_js_1$1.TAG_ID.TEMPLATE) {
      parser2.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser2._initTokenizerForFragmentParsing();
    parser2._insertFakeRootElement();
    parser2._resetInsertionMode();
    parser2._findFormInFragmentContext();
    return parser2;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token2, code2, beforeToken) {
    var _a;
    if (!this.onParseError)
      return;
    const loc = (_a = token2.location) !== null && _a !== void 0 ? _a : BASE_LOC;
    const err = {
      code: code2,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  onItemPush(node2, tid, isTop) {
    var _a, _b;
    (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a, node2);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node2, tid);
  }
  onItemPop(node2, isTop) {
    var _a, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node2, this.currentToken);
    }
    (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a, node2, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === html_js_1$1.NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, html_js_1$1.NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node2 = this.fragmentContext;
    while (node2) {
      if (this.treeAdapter.getTagName(node2) === html_js_1$1.TAG_NAMES.FORM) {
        this.formElement = node2;
        break;
      }
      node2 = this.treeAdapter.getParentNode(node2);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== html_js_1$1.NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case html_js_1$1.TAG_ID.TITLE:
      case html_js_1$1.TAG_ID.TEXTAREA: {
        this.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
        break;
      }
      case html_js_1$1.TAG_ID.STYLE:
      case html_js_1$1.TAG_ID.XMP:
      case html_js_1$1.TAG_ID.IFRAME:
      case html_js_1$1.TAG_ID.NOEMBED:
      case html_js_1$1.TAG_ID.NOFRAMES:
      case html_js_1$1.TAG_ID.NOSCRIPT: {
        this.tokenizer.state = index_js_1.TokenizerMode.RAWTEXT;
        break;
      }
      case html_js_1$1.TAG_ID.SCRIPT: {
        this.tokenizer.state = index_js_1.TokenizerMode.SCRIPT_DATA;
        break;
      }
      case html_js_1$1.TAG_ID.PLAINTEXT: {
        this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
        break;
      }
    }
  }
  //Tree mutation
  _setDocumentType(token2) {
    const name2 = token2.name || "";
    const publicId = token2.publicId || "";
    const systemId = token2.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    if (token2.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node2) => this.treeAdapter.isDocumentTypeNode(node2));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token2.location);
      }
    }
  }
  _attachElementToTree(element2, location2) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location2 && Object.assign(Object.assign({}, location2), { startTag: location2 });
      this.treeAdapter.setNodeSourceCodeLocation(element2, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element2);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent, element2);
    }
  }
  _appendElement(token2, namespaceURI) {
    const element2 = this.treeAdapter.createElement(token2.tagName, namespaceURI, token2.attrs);
    this._attachElementToTree(element2, token2.location);
  }
  _insertElement(token2, namespaceURI) {
    const element2 = this.treeAdapter.createElement(token2.tagName, namespaceURI, token2.attrs);
    this._attachElementToTree(element2, token2.location);
    this.openElements.push(element2, token2.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element2 = this.treeAdapter.createElement(tagName, html_js_1$1.NS.HTML, []);
    this._attachElementToTree(element2, null);
    this.openElements.push(element2, tagID);
  }
  _insertTemplate(token2) {
    const tmpl = this.treeAdapter.createElement(token2.tagName, html_js_1$1.NS.HTML, token2.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token2.location);
    this.openElements.push(tmpl, token2.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element2 = this.treeAdapter.createElement(html_js_1$1.TAG_NAMES.HTML, html_js_1$1.NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element2, null);
    this.treeAdapter.appendChild(this.openElements.current, element2);
    this.openElements.push(element2, html_js_1$1.TAG_ID.HTML);
  }
  _appendCommentNode(token2, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token2.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token2.location);
    }
  }
  _insertCharacters(token2) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token2.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token2.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token2.chars);
    }
    if (!token2.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token2.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token2.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element2, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element2) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element2);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === token_js_1.TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: Object.assign({}, ctLoc),
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element2, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token2) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token2.tagID === html_js_1$1.TAG_ID.SVG && this.treeAdapter.getTagName(current) === html_js_1$1.TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === html_js_1$1.NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token2.tagID === html_js_1$1.TAG_ID.MGLYPH || token2.tagID === html_js_1$1.TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, html_js_1$1.NS.HTML)
    );
  }
  _processToken(token2) {
    switch (token2.type) {
      case token_js_1.TokenType.CHARACTER: {
        this.onCharacter(token2);
        break;
      }
      case token_js_1.TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token2);
        break;
      }
      case token_js_1.TokenType.COMMENT: {
        this.onComment(token2);
        break;
      }
      case token_js_1.TokenType.DOCTYPE: {
        this.onDoctype(token2);
        break;
      }
      case token_js_1.TokenType.START_TAG: {
        this._processStartTag(token2);
        break;
      }
      case token_js_1.TokenType.END_TAG: {
        this.onEndTag(token2);
        break;
      }
      case token_js_1.TokenType.EOF: {
        this.onEof(token2);
        break;
      }
      case token_js_1.TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token2);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element2, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element2);
    const attrs = this.treeAdapter.getAttrList(element2);
    return foreignContent.isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === formatting_element_list_js_1.EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(html_js_1$1.TAG_ID.P);
    this.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
        case html_js_1$1.TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case html_js_1$1.TAG_ID.TBODY:
        case html_js_1$1.TAG_ID.THEAD:
        case html_js_1$1.TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case html_js_1$1.TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case html_js_1$1.TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case html_js_1$1.TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case html_js_1$1.TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case html_js_1$1.TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case html_js_1$1.TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i);
          return;
        }
        case html_js_1$1.TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case html_js_1$1.TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case html_js_1$1.TAG_ID.TD:
        case html_js_1$1.TAG_ID.TH: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case html_js_1$1.TAG_ID.HEAD: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === html_js_1$1.TAG_ID.TEMPLATE) {
          break;
        } else if (tn === html_js_1$1.TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case html_js_1$1.TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === html_js_1$1.NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case html_js_1$1.TAG_ID.TABLE: {
          const parent = this.treeAdapter.getParentNode(openElement);
          if (parent) {
            return { parent, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element2) {
    const location2 = this._findFosterParentingLocation();
    if (location2.beforeElement) {
      this.treeAdapter.insertBefore(location2.parent, element2, location2.beforeElement);
    } else {
      this.treeAdapter.appendChild(location2.parent, element2);
    }
  }
  //Special elements
  _isSpecialElement(element2, id2) {
    const ns = this.treeAdapter.getNamespaceURI(element2);
    return html_js_1$1.SPECIAL_ELEMENTS[ns].has(id2);
  }
  onCharacter(token2) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token2);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token2);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token2);
        break;
      }
    }
  }
  onNullCharacter(token2) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token2);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token2);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token2);
        break;
      }
    }
  }
  onComment(token2) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token2);
        break;
      }
    }
  }
  onDoctype(token2) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token2, error_codes_js_1.ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
    }
  }
  onStartTag(token2) {
    this.skipNextNewLine = false;
    this.currentToken = token2;
    this._processStartTag(token2);
    if (token2.selfClosing && !token2.ackSelfClosing) {
      this._err(token2, error_codes_js_1.ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token2) {
    if (this.shouldProcessStartTagTokenInForeignContent(token2)) {
      startTagInForeignContent(this, token2);
    } else {
      this._startTagOutsideForeignContent(token2);
    }
  }
  _startTagOutsideForeignContent(token2) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token2);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token2);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token2);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token2);
        break;
      }
    }
  }
  onEndTag(token2) {
    this.skipNextNewLine = false;
    this.currentToken = token2;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token2);
    } else {
      this._endTagOutsideForeignContent(token2);
    }
  }
  _endTagOutsideForeignContent(token2) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token2);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token2);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token2);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token2);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token2);
        break;
      }
    }
  }
  onEof(token2) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token2);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token2);
        break;
      }
    }
  }
  onWhitespaceCharacter(token2) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token2.chars.charCodeAt(0) === unicode.CODE_POINTS.LINE_FEED) {
        if (token2.chars.length === 1) {
          return;
        }
        token2.chars = token2.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token2);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token2);
        break;
      }
    }
  }
};
parser$2.Parser = Parser$2;
function aaObtainFormattingElementEntry(p2, token2) {
  let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(token2.tagName);
  if (formattingElementEntry) {
    if (!p2.openElements.contains(formattingElementEntry.element)) {
      p2.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p2.openElements.hasInScope(token2.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p2, token2);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p2, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p2.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element2 = p2.openElements.items[idx];
    if (element2 === formattingElementEntry.element) {
      break;
    }
    if (p2._isSpecialElement(element2, p2.openElements.tagIDs[idx])) {
      furthestBlock = element2;
    }
  }
  if (!furthestBlock) {
    p2.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p2.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p2, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element2 = nextElement; element2 !== formattingElement; i++, element2 = nextElement) {
    nextElement = p2.openElements.getCommonAncestor(element2);
    const elementEntry = p2.activeFormattingElements.getElementEntry(element2);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p2.activeFormattingElements.removeEntry(elementEntry);
      }
      p2.openElements.remove(element2);
    } else {
      element2 = aaRecreateElementFromEntry(p2, elementEntry);
      if (lastElement === furthestBlock) {
        p2.activeFormattingElements.bookmark = elementEntry;
      }
      p2.treeAdapter.detachNode(lastElement);
      p2.treeAdapter.appendChild(element2, lastElement);
      lastElement = element2;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p2, elementEntry) {
  const ns = p2.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p2.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p2.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
  const tn = p2.treeAdapter.getTagName(commonAncestor);
  const tid = (0, html_js_1$1.getTagID)(tn);
  if (p2._isElementCausesFosterParenting(tid)) {
    p2._fosterParentElement(lastElement);
  } else {
    const ns = p2.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === html_js_1$1.TAG_ID.TEMPLATE && ns === html_js_1$1.NS.HTML) {
      commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
    }
    p2.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
  const ns = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token: token2 } = formattingElementEntry;
  const newElement = p2.treeAdapter.createElement(token2.tagName, ns, token2.attrs);
  p2._adoptNodes(furthestBlock, newElement);
  p2.treeAdapter.appendChild(furthestBlock, newElement);
  p2.activeFormattingElements.insertElementAfterBookmark(newElement, token2);
  p2.activeFormattingElements.removeEntry(formattingElementEntry);
  p2.openElements.remove(formattingElementEntry.element);
  p2.openElements.insertAfter(furthestBlock, newElement, token2.tagID);
}
function callAdoptionAgency(p2, token2) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p2, token2);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p2.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
    p2.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
    aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p2, token2) {
  p2._appendCommentNode(token2, p2.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p2, token2) {
  p2._appendCommentNode(token2, p2.openElements.items[0]);
}
function appendCommentToDocument(p2, token2) {
  p2._appendCommentNode(token2, p2.document);
}
function stopParsing(p2, token2) {
  p2.stopped = true;
  if (token2.location) {
    const target = p2.fragmentContext ? 0 : 2;
    for (let i = p2.openElements.stackTop; i >= target; i--) {
      p2._setEndLocation(p2.openElements.items[i], token2);
    }
    if (!p2.fragmentContext && p2.openElements.stackTop >= 0) {
      const htmlElement = p2.openElements.items[0];
      const htmlLocation = p2.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p2._setEndLocation(htmlElement, token2);
        if (p2.openElements.stackTop >= 1) {
          const bodyElement = p2.openElements.items[1];
          const bodyLocation = p2.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p2._setEndLocation(bodyElement, token2);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p2, token2) {
  p2._setDocumentType(token2);
  const mode = token2.forceQuirks ? html_js_1$1.DOCUMENT_MODE.QUIRKS : doctype$1.getDocumentMode(token2);
  if (!doctype$1.isConforming(token2)) {
    p2._err(token2, error_codes_js_1.ERR.nonConformingDoctype);
  }
  p2.treeAdapter.setDocumentMode(p2.document, mode);
  p2.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p2, token2) {
  p2._err(token2, error_codes_js_1.ERR.missingDoctype, true);
  p2.treeAdapter.setDocumentMode(p2.document, html_js_1$1.DOCUMENT_MODE.QUIRKS);
  p2.insertionMode = InsertionMode.BEFORE_HTML;
  p2._processToken(token2);
}
function startTagBeforeHtml(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    p2.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p2, token2);
  }
}
function endTagBeforeHtml(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.HTML || tn === html_js_1$1.TAG_ID.HEAD || tn === html_js_1$1.TAG_ID.BODY || tn === html_js_1$1.TAG_ID.BR) {
    tokenBeforeHtml(p2, token2);
  }
}
function tokenBeforeHtml(p2, token2) {
  p2._insertFakeRootElement();
  p2.insertionMode = InsertionMode.BEFORE_HEAD;
  p2._processToken(token2);
}
function startTagBeforeHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HEAD: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.headElement = p2.openElements.current;
      p2.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p2, token2);
    }
  }
}
function endTagBeforeHead(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.HEAD || tn === html_js_1$1.TAG_ID.BODY || tn === html_js_1$1.TAG_ID.HTML || tn === html_js_1$1.TAG_ID.BR) {
    tokenBeforeHead(p2, token2);
  } else {
    p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p2, token2) {
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.HEAD, html_js_1$1.TAG_ID.HEAD);
  p2.headElement = p2.openElements.current;
  p2.insertionMode = InsertionMode.IN_HEAD;
  p2._processToken(token2);
}
function startTagInHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META: {
      p2._appendElement(token2, html_js_1$1.NS.HTML);
      token2.ackSelfClosing = true;
      break;
    }
    case html_js_1$1.TAG_ID.TITLE: {
      p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RCDATA);
      break;
    }
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      if (p2.options.scriptingEnabled) {
        p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
      } else {
        p2._insertElement(token2, html_js_1$1.NS.HTML);
        p2.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.STYLE: {
      p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
      break;
    }
    case html_js_1$1.TAG_ID.SCRIPT: {
      p2._switchToTextParsing(token2, index_js_1.TokenizerMode.SCRIPT_DATA);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      p2._insertTemplate(token2);
      p2.activeFormattingElements.insertMarker();
      p2.framesetOk = false;
      p2.insertionMode = InsertionMode.IN_TEMPLATE;
      p2.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case html_js_1$1.TAG_ID.HEAD: {
      p2._err(token2, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p2, token2);
    }
  }
}
function endTagInHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HEAD: {
      p2.openElements.pop();
      p2.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.BR:
    case html_js_1$1.TAG_ID.HTML: {
      tokenInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    default: {
      p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p2, token2) {
  if (p2.openElements.tmplCount > 0) {
    p2.openElements.generateImpliedEndTagsThoroughly();
    if (p2.openElements.currentTagId !== html_js_1$1.TAG_ID.TEMPLATE) {
      p2._err(token2, error_codes_js_1.ERR.closingOfElementWithOpenChildElements);
    }
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TEMPLATE);
    p2.activeFormattingElements.clearToLastMarker();
    p2.tmplInsertionModeStack.shift();
    p2._resetInsertionMode();
  } else {
    p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p2, token2) {
  p2.openElements.pop();
  p2.insertionMode = InsertionMode.AFTER_HEAD;
  p2._processToken(token2);
}
function startTagInHeadNoScript(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.HEAD:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.STYLE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      p2._err(token2, error_codes_js_1.ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p2, token2);
    }
  }
}
function endTagInHeadNoScript(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      p2.openElements.pop();
      p2.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case html_js_1$1.TAG_ID.BR: {
      tokenInHeadNoScript(p2, token2);
      break;
    }
    default: {
      p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p2, token2) {
  const errCode = token2.type === token_js_1.TokenType.EOF ? error_codes_js_1.ERR.openElementsLeftAfterEof : error_codes_js_1.ERR.disallowedContentInNoscriptInHead;
  p2._err(token2, errCode);
  p2.openElements.pop();
  p2.insertionMode = InsertionMode.IN_HEAD;
  p2._processToken(token2);
}
function startTagAfterHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.framesetOk = false;
      p2.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case html_js_1$1.TAG_ID.FRAMESET: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.TEMPLATE:
    case html_js_1$1.TAG_ID.TITLE: {
      p2._err(token2, error_codes_js_1.ERR.abandonedHeadElementChild);
      p2.openElements.push(p2.headElement, html_js_1$1.TAG_ID.HEAD);
      startTagInHead(p2, token2);
      p2.openElements.remove(p2.headElement);
      break;
    }
    case html_js_1$1.TAG_ID.HEAD: {
      p2._err(token2, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p2, token2);
    }
  }
}
function endTagAfterHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.BR: {
      tokenAfterHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    default: {
      p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p2, token2) {
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.BODY, html_js_1$1.TAG_ID.BODY);
  p2.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p2, token2);
}
function modeInBody(p2, token2) {
  switch (token2.type) {
    case token_js_1.TokenType.CHARACTER: {
      characterInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.COMMENT: {
      appendComment(p2, token2);
      break;
    }
    case token_js_1.TokenType.START_TAG: {
      startTagInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.END_TAG: {
      endTagInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.EOF: {
      eofInBody(p2, token2);
      break;
    }
  }
}
function whitespaceCharacterInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertCharacters(token2);
}
function characterInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertCharacters(token2);
  p2.framesetOk = false;
}
function htmlStartTagInBody(p2, token2) {
  if (p2.openElements.tmplCount === 0) {
    p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token2.attrs);
  }
}
function bodyStartTagInBody(p2, token2) {
  const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p2.openElements.tmplCount === 0) {
    p2.framesetOk = false;
    p2.treeAdapter.adoptAttributes(bodyElement, token2.attrs);
  }
}
function framesetStartTagInBody(p2, token2) {
  const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
  if (p2.framesetOk && bodyElement) {
    p2.treeAdapter.detachNode(bodyElement);
    p2.openElements.popAllUpToHtmlElement();
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    p2.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function numberedHeaderStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  if ((0, html_js_1$1.isNumberedHeader)(p2.openElements.currentTagId)) {
    p2.openElements.pop();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function preStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.skipNextNewLine = true;
  p2.framesetOk = false;
}
function formStartTagInBody(p2, token2) {
  const inTemplate = p2.openElements.tmplCount > 0;
  if (!p2.formElement || inTemplate) {
    if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
      p2._closePElement();
    }
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    if (!inTemplate) {
      p2.formElement = p2.openElements.current;
    }
  }
}
function listItemStartTagInBody(p2, token2) {
  p2.framesetOk = false;
  const tn = token2.tagID;
  for (let i = p2.openElements.stackTop; i >= 0; i--) {
    const elementId = p2.openElements.tagIDs[i];
    if (tn === html_js_1$1.TAG_ID.LI && elementId === html_js_1$1.TAG_ID.LI || (tn === html_js_1$1.TAG_ID.DD || tn === html_js_1$1.TAG_ID.DT) && (elementId === html_js_1$1.TAG_ID.DD || elementId === html_js_1$1.TAG_ID.DT)) {
      p2.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p2.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== html_js_1$1.TAG_ID.ADDRESS && elementId !== html_js_1$1.TAG_ID.DIV && elementId !== html_js_1$1.TAG_ID.P && p2._isSpecialElement(p2.openElements.items[i], elementId)) {
      break;
    }
  }
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function plaintextStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.BUTTON)) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.BUTTON);
  }
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
}
function aStartTagInBody(p2, token2) {
  const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(html_js_1$1.TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p2, token2);
    p2.openElements.remove(activeElementEntry.element);
    p2.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
}
function bStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
}
function nobrStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.NOBR)) {
    callAdoptionAgency(p2, token2);
    p2._reconstructActiveFormattingElements();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
}
function appletStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.insertMarker();
  p2.framesetOk = false;
}
function tableStartTagInBody(p2, token2) {
  if (p2.treeAdapter.getDocumentMode(p2.document) !== html_js_1$1.DOCUMENT_MODE.QUIRKS && p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  p2.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  token2.ackSelfClosing = true;
}
function isHiddenInput(token2) {
  const inputType = (0, token_js_1.getTokenAttr)(token2, html_js_1$1.ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  if (!isHiddenInput(token2)) {
    p2.framesetOk = false;
  }
  token2.ackSelfClosing = true;
}
function paramStartTagInBody(p2, token2) {
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  token2.ackSelfClosing = true;
}
function hrStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  token2.ackSelfClosing = true;
}
function imageStartTagInBody(p2, token2) {
  token2.tagName = html_js_1$1.TAG_NAMES.IMG;
  token2.tagID = html_js_1$1.TAG_ID.IMG;
  areaStartTagInBody(p2, token2);
}
function textareaStartTagInBody(p2, token2) {
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.skipNextNewLine = true;
  p2.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
  p2.originalInsertionMode = p2.insertionMode;
  p2.framesetOk = false;
  p2.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._reconstructActiveFormattingElements();
  p2.framesetOk = false;
  p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p2, token2) {
  p2.framesetOk = false;
  p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody(p2, token2) {
  p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  p2.insertionMode = p2.insertionMode === InsertionMode.IN_TABLE || p2.insertionMode === InsertionMode.IN_CAPTION || p2.insertionMode === InsertionMode.IN_TABLE_BODY || p2.insertionMode === InsertionMode.IN_ROW || p2.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p2, token2) {
  if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
    p2.openElements.pop();
  }
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function rbStartTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.RUBY)) {
    p2.openElements.generateImpliedEndTags();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function rtStartTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.RUBY)) {
    p2.openElements.generateImpliedEndTagsWithExclusion(html_js_1$1.TAG_ID.RTC);
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function mathStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  foreignContent.adjustTokenMathMLAttrs(token2);
  foreignContent.adjustTokenXMLAttrs(token2);
  if (token2.selfClosing) {
    p2._appendElement(token2, html_js_1$1.NS.MATHML);
  } else {
    p2._insertElement(token2, html_js_1$1.NS.MATHML);
  }
  token2.ackSelfClosing = true;
}
function svgStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  foreignContent.adjustTokenSVGAttrs(token2);
  foreignContent.adjustTokenXMLAttrs(token2);
  if (token2.selfClosing) {
    p2._appendElement(token2, html_js_1$1.NS.SVG);
  } else {
    p2._insertElement(token2, html_js_1$1.NS.SVG);
  }
  token2.ackSelfClosing = true;
}
function genericStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function startTagInBody(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.I:
    case html_js_1$1.TAG_ID.S:
    case html_js_1$1.TAG_ID.B:
    case html_js_1$1.TAG_ID.U:
    case html_js_1$1.TAG_ID.EM:
    case html_js_1$1.TAG_ID.TT:
    case html_js_1$1.TAG_ID.BIG:
    case html_js_1$1.TAG_ID.CODE:
    case html_js_1$1.TAG_ID.FONT:
    case html_js_1$1.TAG_ID.SMALL:
    case html_js_1$1.TAG_ID.STRIKE:
    case html_js_1$1.TAG_ID.STRONG: {
      bStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.A: {
      aStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.H1:
    case html_js_1$1.TAG_ID.H2:
    case html_js_1$1.TAG_ID.H3:
    case html_js_1$1.TAG_ID.H4:
    case html_js_1$1.TAG_ID.H5:
    case html_js_1$1.TAG_ID.H6: {
      numberedHeaderStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.P:
    case html_js_1$1.TAG_ID.DL:
    case html_js_1$1.TAG_ID.OL:
    case html_js_1$1.TAG_ID.UL:
    case html_js_1$1.TAG_ID.DIV:
    case html_js_1$1.TAG_ID.DIR:
    case html_js_1$1.TAG_ID.NAV:
    case html_js_1$1.TAG_ID.MAIN:
    case html_js_1$1.TAG_ID.MENU:
    case html_js_1$1.TAG_ID.ASIDE:
    case html_js_1$1.TAG_ID.CENTER:
    case html_js_1$1.TAG_ID.FIGURE:
    case html_js_1$1.TAG_ID.FOOTER:
    case html_js_1$1.TAG_ID.HEADER:
    case html_js_1$1.TAG_ID.HGROUP:
    case html_js_1$1.TAG_ID.DIALOG:
    case html_js_1$1.TAG_ID.DETAILS:
    case html_js_1$1.TAG_ID.ADDRESS:
    case html_js_1$1.TAG_ID.ARTICLE:
    case html_js_1$1.TAG_ID.SECTION:
    case html_js_1$1.TAG_ID.SUMMARY:
    case html_js_1$1.TAG_ID.FIELDSET:
    case html_js_1$1.TAG_ID.BLOCKQUOTE:
    case html_js_1$1.TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.LI:
    case html_js_1$1.TAG_ID.DD:
    case html_js_1$1.TAG_ID.DT: {
      listItemStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BR:
    case html_js_1$1.TAG_ID.IMG:
    case html_js_1$1.TAG_ID.WBR:
    case html_js_1$1.TAG_ID.AREA:
    case html_js_1$1.TAG_ID.EMBED:
    case html_js_1$1.TAG_ID.KEYGEN: {
      areaStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HR: {
      hrStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.RB:
    case html_js_1$1.TAG_ID.RTC: {
      rbStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.RT:
    case html_js_1$1.TAG_ID.RP: {
      rtStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.PRE:
    case html_js_1$1.TAG_ID.LISTING: {
      preStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.XMP: {
      xmpStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.SVG: {
      svgStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HTML: {
      htmlStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.TITLE:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY: {
      bodyStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FORM: {
      formStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOBR: {
      nobrStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.MATH: {
      mathStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      tableStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.INPUT: {
      inputStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.PARAM:
    case html_js_1$1.TAG_ID.TRACK:
    case html_js_1$1.TAG_ID.SOURCE: {
      paramStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.IMAGE: {
      imageStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BUTTON: {
      buttonStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.APPLET:
    case html_js_1$1.TAG_ID.OBJECT:
    case html_js_1$1.TAG_ID.MARQUEE: {
      appletStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.IFRAME: {
      iframeStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.SELECT: {
      selectStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.OPTION:
    case html_js_1$1.TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOEMBED: {
      noembedStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FRAMESET: {
      framesetStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      if (p2.options.scriptingEnabled) {
        noembedStartTagInBody(p2, token2);
      } else {
        genericStartTagInBody(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TR:
    case html_js_1$1.TAG_ID.HEAD:
    case html_js_1$1.TAG_ID.FRAME:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p2, token2);
    }
  }
}
function bodyEndTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.BODY)) {
    p2.insertionMode = InsertionMode.AFTER_BODY;
    if (p2.options.sourceCodeLocationInfo) {
      const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p2._setEndLocation(bodyElement, token2);
      }
    }
  }
}
function htmlEndTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.BODY)) {
    p2.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p2, token2);
  }
}
function addressEndTagInBody(p2, token2) {
  const tn = token2.tagID;
  if (p2.openElements.hasInScope(tn)) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p2) {
  const inTemplate = p2.openElements.tmplCount > 0;
  const { formElement } = p2;
  if (!inTemplate) {
    p2.formElement = null;
  }
  if ((formElement || inTemplate) && p2.openElements.hasInScope(html_js_1$1.TAG_ID.FORM)) {
    p2.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.FORM);
    } else if (formElement) {
      p2.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p2) {
  if (!p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._insertFakeElement(html_js_1$1.TAG_NAMES.P, html_js_1$1.TAG_ID.P);
  }
  p2._closePElement();
}
function liEndTagInBody(p2) {
  if (p2.openElements.hasInListItemScope(html_js_1$1.TAG_ID.LI)) {
    p2.openElements.generateImpliedEndTagsWithExclusion(html_js_1$1.TAG_ID.LI);
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.LI);
  }
}
function ddEndTagInBody(p2, token2) {
  const tn = token2.tagID;
  if (p2.openElements.hasInScope(tn)) {
    p2.openElements.generateImpliedEndTagsWithExclusion(tn);
    p2.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p2) {
  if (p2.openElements.hasNumberedHeaderInScope()) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p2, token2) {
  const tn = token2.tagID;
  if (p2.openElements.hasInScope(tn)) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilTagNamePopped(tn);
    p2.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p2) {
  p2._reconstructActiveFormattingElements();
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.BR, html_js_1$1.TAG_ID.BR);
  p2.openElements.pop();
  p2.framesetOk = false;
}
function genericEndTagInBody(p2, token2) {
  const tn = token2.tagName;
  const tid = token2.tagID;
  for (let i = p2.openElements.stackTop; i > 0; i--) {
    const element2 = p2.openElements.items[i];
    const elementId = p2.openElements.tagIDs[i];
    if (tid === elementId && (tid !== html_js_1$1.TAG_ID.UNKNOWN || p2.treeAdapter.getTagName(element2) === tn)) {
      p2.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p2.openElements.stackTop >= i)
        p2.openElements.shortenToLength(i);
      break;
    }
    if (p2._isSpecialElement(element2, elementId)) {
      break;
    }
  }
}
function endTagInBody(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.A:
    case html_js_1$1.TAG_ID.B:
    case html_js_1$1.TAG_ID.I:
    case html_js_1$1.TAG_ID.S:
    case html_js_1$1.TAG_ID.U:
    case html_js_1$1.TAG_ID.EM:
    case html_js_1$1.TAG_ID.TT:
    case html_js_1$1.TAG_ID.BIG:
    case html_js_1$1.TAG_ID.CODE:
    case html_js_1$1.TAG_ID.FONT:
    case html_js_1$1.TAG_ID.NOBR:
    case html_js_1$1.TAG_ID.SMALL:
    case html_js_1$1.TAG_ID.STRIKE:
    case html_js_1$1.TAG_ID.STRONG: {
      callAdoptionAgency(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.P: {
      pEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.DL:
    case html_js_1$1.TAG_ID.UL:
    case html_js_1$1.TAG_ID.OL:
    case html_js_1$1.TAG_ID.DIR:
    case html_js_1$1.TAG_ID.DIV:
    case html_js_1$1.TAG_ID.NAV:
    case html_js_1$1.TAG_ID.PRE:
    case html_js_1$1.TAG_ID.MAIN:
    case html_js_1$1.TAG_ID.MENU:
    case html_js_1$1.TAG_ID.ASIDE:
    case html_js_1$1.TAG_ID.BUTTON:
    case html_js_1$1.TAG_ID.CENTER:
    case html_js_1$1.TAG_ID.FIGURE:
    case html_js_1$1.TAG_ID.FOOTER:
    case html_js_1$1.TAG_ID.HEADER:
    case html_js_1$1.TAG_ID.HGROUP:
    case html_js_1$1.TAG_ID.DIALOG:
    case html_js_1$1.TAG_ID.ADDRESS:
    case html_js_1$1.TAG_ID.ARTICLE:
    case html_js_1$1.TAG_ID.DETAILS:
    case html_js_1$1.TAG_ID.SECTION:
    case html_js_1$1.TAG_ID.SUMMARY:
    case html_js_1$1.TAG_ID.LISTING:
    case html_js_1$1.TAG_ID.FIELDSET:
    case html_js_1$1.TAG_ID.BLOCKQUOTE:
    case html_js_1$1.TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.LI: {
      liEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.DD:
    case html_js_1$1.TAG_ID.DT: {
      ddEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.H1:
    case html_js_1$1.TAG_ID.H2:
    case html_js_1$1.TAG_ID.H3:
    case html_js_1$1.TAG_ID.H4:
    case html_js_1$1.TAG_ID.H5:
    case html_js_1$1.TAG_ID.H6: {
      numberedHeaderEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.BR: {
      brEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY: {
      bodyEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HTML: {
      htmlEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FORM: {
      formEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.APPLET:
    case html_js_1$1.TAG_ID.OBJECT:
    case html_js_1$1.TAG_ID.MARQUEE: {
      appletEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    default: {
      genericEndTagInBody(p2, token2);
    }
  }
}
function eofInBody(p2, token2) {
  if (p2.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p2, token2);
  } else {
    stopParsing(p2, token2);
  }
}
function endTagInText(p2, token2) {
  var _a;
  if (token2.tagID === html_js_1$1.TAG_ID.SCRIPT) {
    (_a = p2.scriptHandler) === null || _a === void 0 ? void 0 : _a.call(p2, p2.openElements.current);
  }
  p2.openElements.pop();
  p2.insertionMode = p2.originalInsertionMode;
}
function eofInText(p2, token2) {
  p2._err(token2, error_codes_js_1.ERR.eofInElementThatCanContainOnlyText);
  p2.openElements.pop();
  p2.insertionMode = p2.originalInsertionMode;
  p2.onEof(token2);
}
function characterInTable(p2, token2) {
  if (TABLE_STRUCTURE_TAGS.has(p2.openElements.currentTagId)) {
    p2.pendingCharacterTokens.length = 0;
    p2.hasNonWhitespacePendingCharacterToken = false;
    p2.originalInsertionMode = p2.insertionMode;
    p2.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token2.type) {
      case token_js_1.TokenType.CHARACTER: {
        characterInTableText(p2, token2);
        break;
      }
      case token_js_1.TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p2, token2);
        break;
      }
    }
  } else {
    tokenInTable(p2, token2);
  }
}
function captionStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2.activeFormattingElements.insertMarker();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.COLGROUP, html_js_1$1.TAG_ID.COLGROUP);
  p2.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p2, token2);
}
function tbodyStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.TBODY, html_js_1$1.TAG_ID.TBODY);
  p2.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p2, token2);
}
function tableStartTagInTable(p2, token2) {
  if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TABLE)) {
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TABLE);
    p2._resetInsertionMode();
    p2._processStartTag(token2);
  }
}
function inputStartTagInTable(p2, token2) {
  if (isHiddenInput(token2)) {
    p2._appendElement(token2, html_js_1$1.NS.HTML);
  } else {
    tokenInTable(p2, token2);
  }
  token2.ackSelfClosing = true;
}
function formStartTagInTable(p2, token2) {
  if (!p2.formElement && p2.openElements.tmplCount === 0) {
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    p2.formElement = p2.openElements.current;
    p2.openElements.pop();
  }
}
function startTagInTable(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TR: {
      tdStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      colStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FORM: {
      formStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      tableStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      tbodyStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.INPUT: {
      inputStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION: {
      captionStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p2, token2);
      break;
    }
    default: {
      tokenInTable(p2, token2);
    }
  }
}
function endTagInTable(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TABLE)) {
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TABLE);
        p2._resetInsertionMode();
      }
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p2, token2);
    }
  }
}
function tokenInTable(p2, token2) {
  const savedFosterParentingState = p2.fosterParentingEnabled;
  p2.fosterParentingEnabled = true;
  modeInBody(p2, token2);
  p2.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p2, token2) {
  p2.pendingCharacterTokens.push(token2);
}
function characterInTableText(p2, token2) {
  p2.pendingCharacterTokens.push(token2);
  p2.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p2, token2) {
  let i = 0;
  if (p2.hasNonWhitespacePendingCharacterToken) {
    for (; i < p2.pendingCharacterTokens.length; i++) {
      tokenInTable(p2, p2.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p2.pendingCharacterTokens.length; i++) {
      p2._insertCharacters(p2.pendingCharacterTokens[i]);
    }
  }
  p2.insertionMode = p2.originalInsertionMode;
  p2._processToken(token2);
}
const TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([html_js_1$1.TAG_ID.CAPTION, html_js_1$1.TAG_ID.COL, html_js_1$1.TAG_ID.COLGROUP, html_js_1$1.TAG_ID.TBODY, html_js_1$1.TAG_ID.TD, html_js_1$1.TAG_ID.TFOOT, html_js_1$1.TAG_ID.TH, html_js_1$1.TAG_ID.THEAD, html_js_1$1.TAG_ID.TR]);
function startTagInCaption(p2, token2) {
  const tn = token2.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.CAPTION)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.CAPTION);
      p2.activeFormattingElements.clearToLastMarker();
      p2.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p2, token2);
    }
  } else {
    startTagInBody(p2, token2);
  }
}
function endTagInCaption(p2, token2) {
  const tn = token2.tagID;
  switch (tn) {
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.CAPTION)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.CAPTION);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = InsertionMode.IN_TABLE;
        if (tn === html_js_1$1.TAG_ID.TABLE) {
          endTagInTable(p2, token2);
        }
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p2, token2);
    }
  }
}
function startTagInColumnGroup(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      p2._appendElement(token2, html_js_1$1.NS.HTML);
      token2.ackSelfClosing = true;
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
    default: {
      tokenInColumnGroup(p2, token2);
    }
  }
}
function endTagInColumnGroup(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.COLGROUP: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.COLGROUP) {
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p2, token2);
    }
  }
}
function tokenInColumnGroup(p2, token2) {
  if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.COLGROUP) {
    p2.openElements.pop();
    p2.insertionMode = InsertionMode.IN_TABLE;
    p2._processToken(token2);
  }
}
function startTagInTableBody(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TR: {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TD: {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertFakeElement(html_js_1$1.TAG_NAMES.TR, html_js_1$1.TAG_ID.TR);
      p2.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p2, token2);
      }
      break;
    }
    default: {
      startTagInTable(p2, token2);
    }
  }
}
function endTagInTableBody(p2, token2) {
  const tn = token2.tagID;
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p2, token2);
    }
  }
}
function startTagInRow(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TD: {
      p2.openElements.clearBackToTableRowContext();
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.insertionMode = InsertionMode.IN_CELL;
      p2.activeFormattingElements.insertMarker();
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p2, token2);
      }
      break;
    }
    default: {
      startTagInTable(p2, token2);
    }
  }
}
function endTagInRow(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TR: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      if (p2.openElements.hasInTableScope(token2.tagID) || p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p2, token2);
    }
  }
}
function startTagInCell(p2, token2) {
  const tn = token2.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TD) || p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TH)) {
      p2._closeTableCell();
      startTagInRow(p2, token2);
    }
  } else {
    startTagInBody(p2, token2);
  }
}
function endTagInCell(p2, token2) {
  const tn = token2.tagID;
  switch (tn) {
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH: {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TABLE:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      if (p2.openElements.hasInTableScope(tn)) {
        p2._closeTableCell();
        endTagInRow(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p2, token2);
    }
  }
}
function startTagInSelect(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.OPTION: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
        p2.openElements.pop();
      }
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      break;
    }
    case html_js_1$1.TAG_ID.OPTGROUP: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTGROUP) {
        p2.openElements.pop();
      }
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      break;
    }
    case html_js_1$1.TAG_ID.INPUT:
    case html_js_1$1.TAG_ID.KEYGEN:
    case html_js_1$1.TAG_ID.TEXTAREA:
    case html_js_1$1.TAG_ID.SELECT: {
      if (p2.openElements.hasInSelectScope(html_js_1$1.TAG_ID.SELECT)) {
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
        p2._resetInsertionMode();
        if (token2.tagID !== html_js_1$1.TAG_ID.SELECT) {
          p2._processStartTag(token2);
        }
      }
      break;
    }
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function endTagInSelect(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.OPTGROUP: {
      if (p2.openElements.stackTop > 0 && p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION && p2.openElements.tagIDs[p2.openElements.stackTop - 1] === html_js_1$1.TAG_ID.OPTGROUP) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTGROUP) {
        p2.openElements.pop();
      }
      break;
    }
    case html_js_1$1.TAG_ID.OPTION: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
        p2.openElements.pop();
      }
      break;
    }
    case html_js_1$1.TAG_ID.SELECT: {
      if (p2.openElements.hasInSelectScope(html_js_1$1.TAG_ID.SELECT)) {
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
        p2._resetInsertionMode();
      }
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
  }
}
function startTagInSelectInTable(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.CAPTION || tn === html_js_1$1.TAG_ID.TABLE || tn === html_js_1$1.TAG_ID.TBODY || tn === html_js_1$1.TAG_ID.TFOOT || tn === html_js_1$1.TAG_ID.THEAD || tn === html_js_1$1.TAG_ID.TR || tn === html_js_1$1.TAG_ID.TD || tn === html_js_1$1.TAG_ID.TH) {
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
    p2._resetInsertionMode();
    p2._processStartTag(token2);
  } else {
    startTagInSelect(p2, token2);
  }
}
function endTagInSelectInTable(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.CAPTION || tn === html_js_1$1.TAG_ID.TABLE || tn === html_js_1$1.TAG_ID.TBODY || tn === html_js_1$1.TAG_ID.TFOOT || tn === html_js_1$1.TAG_ID.THEAD || tn === html_js_1$1.TAG_ID.TR || tn === html_js_1$1.TAG_ID.TD || tn === html_js_1$1.TAG_ID.TH) {
    if (p2.openElements.hasInTableScope(tn)) {
      p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
      p2._resetInsertionMode();
      p2.onEndTag(token2);
    }
  } else {
    endTagInSelect(p2, token2);
  }
}
function startTagInTemplate(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.TEMPLATE:
    case html_js_1$1.TAG_ID.TITLE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p2.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p2.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TR: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p2.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p2.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p2, token2);
      break;
    }
    default: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p2.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p2, token2);
    }
  }
}
function endTagInTemplate(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.TEMPLATE) {
    templateEndTagInHead(p2, token2);
  }
}
function eofInTemplate(p2, token2) {
  if (p2.openElements.tmplCount > 0) {
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TEMPLATE);
    p2.activeFormattingElements.clearToLastMarker();
    p2.tmplInsertionModeStack.shift();
    p2._resetInsertionMode();
    p2.onEof(token2);
  } else {
    stopParsing(p2, token2);
  }
}
function startTagAfterBody(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    startTagInBody(p2, token2);
  } else {
    tokenAfterBody(p2, token2);
  }
}
function endTagAfterBody(p2, token2) {
  var _a;
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    if (!p2.fragmentContext) {
      p2.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p2.options.sourceCodeLocationInfo && p2.openElements.tagIDs[0] === html_js_1$1.TAG_ID.HTML) {
      p2._setEndLocation(p2.openElements.items[0], token2);
      const bodyElement = p2.openElements.items[1];
      if (bodyElement && !((_a = p2.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a === void 0 ? void 0 : _a.endTag)) {
        p2._setEndLocation(bodyElement, token2);
      }
    }
  } else {
    tokenAfterBody(p2, token2);
  }
}
function tokenAfterBody(p2, token2) {
  p2.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p2, token2);
}
function startTagInFrameset(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FRAMESET: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      break;
    }
    case html_js_1$1.TAG_ID.FRAME: {
      p2._appendElement(token2, html_js_1$1.NS.HTML);
      token2.ackSelfClosing = true;
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function endTagInFrameset(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
    p2.openElements.pop();
    if (!p2.fragmentContext && p2.openElements.currentTagId !== html_js_1$1.TAG_ID.FRAMESET) {
      p2.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function endTagAfterFrameset(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    p2.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    startTagInBody(p2, token2);
  } else {
    tokenAfterAfterBody(p2, token2);
  }
}
function tokenAfterAfterBody(p2, token2) {
  p2.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p2, token2);
}
function startTagAfterAfterFrameset(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function nullCharacterInForeignContent(p2, token2) {
  token2.chars = unicode.REPLACEMENT_CHARACTER;
  p2._insertCharacters(token2);
}
function characterInForeignContent(p2, token2) {
  p2._insertCharacters(token2);
  p2.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p2) {
  while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== html_js_1$1.NS.HTML && !p2._isIntegrationPoint(p2.openElements.currentTagId, p2.openElements.current)) {
    p2.openElements.pop();
  }
}
function startTagInForeignContent(p2, token2) {
  if (foreignContent.causesExit(token2)) {
    popUntilHtmlOrIntegrationPoint(p2);
    p2._startTagOutsideForeignContent(token2);
  } else {
    const current = p2._getAdjustedCurrentElement();
    const currentNs = p2.treeAdapter.getNamespaceURI(current);
    if (currentNs === html_js_1$1.NS.MATHML) {
      foreignContent.adjustTokenMathMLAttrs(token2);
    } else if (currentNs === html_js_1$1.NS.SVG) {
      foreignContent.adjustTokenSVGTagName(token2);
      foreignContent.adjustTokenSVGAttrs(token2);
    }
    foreignContent.adjustTokenXMLAttrs(token2);
    if (token2.selfClosing) {
      p2._appendElement(token2, currentNs);
    } else {
      p2._insertElement(token2, currentNs);
    }
    token2.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.P || token2.tagID === html_js_1$1.TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p2);
    p2._endTagOutsideForeignContent(token2);
    return;
  }
  for (let i = p2.openElements.stackTop; i > 0; i--) {
    const element2 = p2.openElements.items[i];
    if (p2.treeAdapter.getNamespaceURI(element2) === html_js_1$1.NS.HTML) {
      p2._endTagOutsideForeignContent(token2);
      break;
    }
    const tagName = p2.treeAdapter.getTagName(element2);
    if (tagName.toLowerCase() === token2.tagName) {
      token2.tagName = tagName;
      p2.openElements.shortenToLength(i);
      break;
    }
  }
}
var serializer = {};
var _escape$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c, index2) {
      return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$1);
Object.defineProperty(serializer, "__esModule", { value: true });
serializer.serializeOuter = serializer.serialize = void 0;
const html_js_1 = html$4;
const escape_js_1$1 = _escape$1;
const default_js_1 = _default;
const VOID_ELEMENTS = /* @__PURE__ */ new Set([
  html_js_1.TAG_NAMES.AREA,
  html_js_1.TAG_NAMES.BASE,
  html_js_1.TAG_NAMES.BASEFONT,
  html_js_1.TAG_NAMES.BGSOUND,
  html_js_1.TAG_NAMES.BR,
  html_js_1.TAG_NAMES.COL,
  html_js_1.TAG_NAMES.EMBED,
  html_js_1.TAG_NAMES.FRAME,
  html_js_1.TAG_NAMES.HR,
  html_js_1.TAG_NAMES.IMG,
  html_js_1.TAG_NAMES.INPUT,
  html_js_1.TAG_NAMES.KEYGEN,
  html_js_1.TAG_NAMES.LINK,
  html_js_1.TAG_NAMES.META,
  html_js_1.TAG_NAMES.PARAM,
  html_js_1.TAG_NAMES.SOURCE,
  html_js_1.TAG_NAMES.TRACK,
  html_js_1.TAG_NAMES.WBR
]);
function isVoidElement(node2, options2) {
  return options2.treeAdapter.isElementNode(node2) && options2.treeAdapter.getNamespaceURI(node2) === html_js_1.NS.HTML && VOID_ELEMENTS.has(options2.treeAdapter.getTagName(node2));
}
const defaultOpts = { treeAdapter: default_js_1.defaultTreeAdapter, scriptingEnabled: true };
function serialize(node2, options2) {
  const opts = Object.assign(Object.assign({}, defaultOpts), options2);
  if (isVoidElement(node2, opts)) {
    return "";
  }
  return serializeChildNodes(node2, opts);
}
serializer.serialize = serialize;
function serializeOuter(node2, options2) {
  const opts = Object.assign(Object.assign({}, defaultOpts), options2);
  return serializeNode(node2, opts);
}
serializer.serializeOuter = serializeOuter;
function serializeChildNodes(parentNode, options2) {
  let html2 = "";
  const container = options2.treeAdapter.isElementNode(parentNode) && options2.treeAdapter.getTagName(parentNode) === html_js_1.TAG_NAMES.TEMPLATE && options2.treeAdapter.getNamespaceURI(parentNode) === html_js_1.NS.HTML ? options2.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options2.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html2 += serializeNode(currentNode, options2);
    }
  }
  return html2;
}
function serializeNode(node2, options2) {
  if (options2.treeAdapter.isElementNode(node2)) {
    return serializeElement(node2, options2);
  }
  if (options2.treeAdapter.isTextNode(node2)) {
    return serializeTextNode(node2, options2);
  }
  if (options2.treeAdapter.isCommentNode(node2)) {
    return serializeCommentNode(node2, options2);
  }
  if (options2.treeAdapter.isDocumentTypeNode(node2)) {
    return serializeDocumentTypeNode(node2, options2);
  }
  return "";
}
function serializeElement(node2, options2) {
  const tn = options2.treeAdapter.getTagName(node2);
  return `<${tn}${serializeAttributes$1(node2, options2)}>${isVoidElement(node2, options2) ? "" : `${serializeChildNodes(node2, options2)}</${tn}>`}`;
}
function serializeAttributes$1(node2, { treeAdapter }) {
  let html2 = "";
  for (const attr2 of treeAdapter.getAttrList(node2)) {
    html2 += " ";
    if (!attr2.namespace) {
      html2 += attr2.name;
    } else
      switch (attr2.namespace) {
        case html_js_1.NS.XML: {
          html2 += `xml:${attr2.name}`;
          break;
        }
        case html_js_1.NS.XMLNS: {
          if (attr2.name !== "xmlns") {
            html2 += "xmlns:";
          }
          html2 += attr2.name;
          break;
        }
        case html_js_1.NS.XLINK: {
          html2 += `xlink:${attr2.name}`;
          break;
        }
        default: {
          html2 += `${attr2.prefix}:${attr2.name}`;
        }
      }
    html2 += `="${(0, escape_js_1$1.escapeAttribute)(attr2.value)}"`;
  }
  return html2;
}
function serializeTextNode(node2, options2) {
  const { treeAdapter } = options2;
  const content = treeAdapter.getTextNodeContent(node2);
  const parent = treeAdapter.getParentNode(node2);
  const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
  return parentTn && treeAdapter.getNamespaceURI(parent) === html_js_1.NS.HTML && (0, html_js_1.hasUnescapedText)(parentTn, options2.scriptingEnabled) ? content : (0, escape_js_1$1.escapeText)(content);
}
function serializeCommentNode(node2, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node2)}-->`;
}
function serializeDocumentTypeNode(node2, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node2)}>`;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.parseFragment = exports2.parse = exports2.TokenizerMode = exports2.Tokenizer = exports2.Token = exports2.html = exports2.foreignContent = exports2.ErrorCodes = exports2.serializeOuter = exports2.serialize = exports2.Parser = exports2.defaultTreeAdapter = void 0;
  const index_js_12 = parser$2;
  var default_js_12 = _default;
  Object.defineProperty(exports2, "defaultTreeAdapter", { enumerable: true, get: function() {
    return default_js_12.defaultTreeAdapter;
  } });
  var index_js_2 = parser$2;
  Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
    return index_js_2.Parser;
  } });
  var index_js_3 = serializer;
  Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
    return index_js_3.serialize;
  } });
  Object.defineProperty(exports2, "serializeOuter", { enumerable: true, get: function() {
    return index_js_3.serializeOuter;
  } });
  var error_codes_js_12 = errorCodes;
  Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
    return error_codes_js_12.ERR;
  } });
  exports2.foreignContent = foreignContent$1;
  exports2.html = html$4;
  exports2.Token = token;
  var index_js_4 = tokenizer;
  Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
    return index_js_4.Tokenizer;
  } });
  Object.defineProperty(exports2, "TokenizerMode", { enumerable: true, get: function() {
    return index_js_4.TokenizerMode;
  } });
  function parse2(html2, options2) {
    return index_js_12.Parser.parse(html2, options2);
  }
  exports2.parse = parse2;
  function parseFragment(fragmentContext, html2, options2) {
    if (typeof fragmentContext === "string") {
      options2 = html2;
      html2 = fragmentContext;
      fragmentContext = null;
    }
    const parser2 = index_js_12.Parser.getFragmentParser(fragmentContext, options2);
    parser2.tokenizer.write(html2, true);
    return parser2.getFragment();
  }
  exports2.parseFragment = parseFragment;
})(cjs$1);
var cjs = {};
var lib$5 = {};
var node$1 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$2 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
Object.defineProperty(node$1, "__esModule", { value: true });
node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.CDATA = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
var domelementtype_1$2 = lib$i;
var Node$1 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$1(this, recursive);
    };
    return Node2;
  }()
);
node$1.Node = Node$1;
var DataNode$1 = (
  /** @class */
  function(_super) {
    __extends$1(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$1)
);
node$1.DataNode = DataNode$1;
var Text$1 = (
  /** @class */
  function(_super) {
    __extends$1(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$1)
);
node$1.Text = Text$1;
var Comment$1 = (
  /** @class */
  function(_super) {
    __extends$1(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$1)
);
node$1.Comment = Comment$1;
var ProcessingInstruction$1 = (
  /** @class */
  function(_super) {
    __extends$1(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$2.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$1)
);
node$1.ProcessingInstruction = ProcessingInstruction$1;
var NodeWithChildren$1 = (
  /** @class */
  function(_super) {
    __extends$1(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$1)
);
node$1.NodeWithChildren = NodeWithChildren$1;
var CDATA$1 = (
  /** @class */
  function(_super) {
    __extends$1(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$1)
);
node$1.CDATA = CDATA$1;
var Document$1 = (
  /** @class */
  function(_super) {
    __extends$1(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$1)
);
node$1.Document = Document$1;
var Element$1 = (
  /** @class */
  function(_super) {
    __extends$1(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$2.ElementType.Script : name2 === "style" ? domelementtype_1$2.ElementType.Style : domelementtype_1$2.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$1)
);
node$1.Element = Element$1;
function isTag$1(node2) {
  return (0, domelementtype_1$2.isTag)(node2);
}
node$1.isTag = isTag$1;
function isCDATA$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.CDATA;
}
node$1.isCDATA = isCDATA$1;
function isText$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Text;
}
node$1.isText = isText$1;
function isComment$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Comment;
}
node$1.isComment = isComment$1;
function isDirective$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Directive;
}
node$1.isDirective = isDirective$1;
function isDocument$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Root;
}
node$1.isDocument = isDocument$1;
function hasChildren$1(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$1.hasChildren = hasChildren$1;
function cloneNode$1(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$1(node2)) {
    result = new Text$1(node2.data);
  } else if (isComment$1(node2)) {
    result = new Comment$1(node2.data);
  } else if (isTag$1(node2)) {
    var children = recursive ? cloneChildren$1(node2.children) : [];
    var clone_1 = new Element$1(node2.name, __assign$2({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$2({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$2({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$1(node2)) {
    var children = recursive ? cloneChildren$1(node2.children) : [];
    var clone_2 = new CDATA$1(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$1(node2)) {
    var children = recursive ? cloneChildren$1(node2.children) : [];
    var clone_3 = new Document$1(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$1(node2)) {
    var instruction = new ProcessingInstruction$1(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$1.cloneNode = cloneNode$1;
function cloneChildren$1(childs) {
  var children = childs.map(function(child) {
    return cloneNode$1(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$1;
  __exportStar(node$1, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$5);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.adapter = exports2.serializeDoctypeContent = void 0;
  const parse5_12 = cjs$1;
  const domhandler_12 = lib$5;
  function createTextNode(value) {
    return new domhandler_12.Text(value);
  }
  function enquoteDoctypeId(id2) {
    const quote = id2.includes('"') ? "'" : '"';
    return quote + id2 + quote;
  }
  function serializeDoctypeContent(name2, publicId, systemId) {
    let str = "!DOCTYPE ";
    if (name2) {
      str += name2;
    }
    if (publicId) {
      str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
    } else if (systemId) {
      str += " SYSTEM";
    }
    if (systemId) {
      str += ` ${enquoteDoctypeId(systemId)}`;
    }
    return str;
  }
  exports2.serializeDoctypeContent = serializeDoctypeContent;
  exports2.adapter = {
    // Re-exports from domhandler
    isCommentNode: domhandler_12.isComment,
    isElementNode: domhandler_12.isTag,
    isTextNode: domhandler_12.isText,
    //Node construction
    createDocument() {
      const node2 = new domhandler_12.Document([]);
      node2["x-mode"] = parse5_12.html.DOCUMENT_MODE.NO_QUIRKS;
      return node2;
    },
    createDocumentFragment() {
      return new domhandler_12.Document([]);
    },
    createElement(tagName, namespaceURI, attrs) {
      const attribs = /* @__PURE__ */ Object.create(null);
      const attribsNamespace = /* @__PURE__ */ Object.create(null);
      const attribsPrefix = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].name;
        attribs[attrName] = attrs[i].value;
        attribsNamespace[attrName] = attrs[i].namespace;
        attribsPrefix[attrName] = attrs[i].prefix;
      }
      const node2 = new domhandler_12.Element(tagName, attribs, []);
      node2.namespace = namespaceURI;
      node2["x-attribsNamespace"] = attribsNamespace;
      node2["x-attribsPrefix"] = attribsPrefix;
      return node2;
    },
    createCommentNode(data2) {
      return new domhandler_12.Comment(data2);
    },
    //Tree mutation
    appendChild(parentNode, newNode) {
      const prev = parentNode.children[parentNode.children.length - 1];
      if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
      }
      parentNode.children.push(newNode);
      newNode.parent = parentNode;
    },
    insertBefore(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.children.indexOf(referenceNode);
      const { prev } = referenceNode;
      if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
      }
      referenceNode.prev = newNode;
      newNode.next = referenceNode;
      parentNode.children.splice(insertionIdx, 0, newNode);
      newNode.parent = parentNode;
    },
    setTemplateContent(templateElement, contentElement) {
      exports2.adapter.appendChild(templateElement, contentElement);
    },
    getTemplateContent(templateElement) {
      return templateElement.children[0];
    },
    setDocumentType(document, name2, publicId, systemId) {
      const data2 = serializeDoctypeContent(name2, publicId, systemId);
      let doctypeNode = document.children.find((node2) => (0, domhandler_12.isDirective)(node2) && node2.name === "!doctype");
      if (doctypeNode) {
        doctypeNode.data = data2 !== null && data2 !== void 0 ? data2 : null;
      } else {
        doctypeNode = new domhandler_12.ProcessingInstruction("!doctype", data2);
        exports2.adapter.appendChild(document, doctypeNode);
      }
      doctypeNode["x-name"] = name2 !== null && name2 !== void 0 ? name2 : void 0;
      doctypeNode["x-publicId"] = publicId !== null && publicId !== void 0 ? publicId : void 0;
      doctypeNode["x-systemId"] = systemId !== null && systemId !== void 0 ? systemId : void 0;
    },
    setDocumentMode(document, mode) {
      document["x-mode"] = mode;
    },
    getDocumentMode(document) {
      return document["x-mode"];
    },
    detachNode(node2) {
      if (node2.parent) {
        const idx = node2.parent.children.indexOf(node2);
        const { prev, next } = node2;
        node2.prev = null;
        node2.next = null;
        if (prev) {
          prev.next = next;
        }
        if (next) {
          next.prev = prev;
        }
        node2.parent.children.splice(idx, 1);
        node2.parent = null;
      }
    },
    insertText(parentNode, text2) {
      const lastChild2 = parentNode.children[parentNode.children.length - 1];
      if (lastChild2 && (0, domhandler_12.isText)(lastChild2)) {
        lastChild2.data += text2;
      } else {
        exports2.adapter.appendChild(parentNode, createTextNode(text2));
      }
    },
    insertTextBefore(parentNode, text2, referenceNode) {
      const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
      if (prevNode && (0, domhandler_12.isText)(prevNode)) {
        prevNode.data += text2;
      } else {
        exports2.adapter.insertBefore(parentNode, createTextNode(text2), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].name;
        if (typeof recipient.attribs[attrName] === "undefined") {
          recipient.attribs[attrName] = attrs[i].value;
          recipient["x-attribsNamespace"][attrName] = attrs[i].namespace;
          recipient["x-attribsPrefix"][attrName] = attrs[i].prefix;
        }
      }
    },
    //Tree traversing
    getFirstChild(node2) {
      return node2.children[0];
    },
    getChildNodes(node2) {
      return node2.children;
    },
    getParentNode(node2) {
      return node2.parent;
    },
    getAttrList(element2) {
      return element2.attributes;
    },
    //Node data
    getTagName(element2) {
      return element2.name;
    },
    getNamespaceURI(element2) {
      return element2.namespace;
    },
    getTextNodeContent(textNode) {
      return textNode.data;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.data;
    },
    getDocumentTypeNodeName(doctypeNode) {
      var _a;
      return (_a = doctypeNode["x-name"]) !== null && _a !== void 0 ? _a : "";
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      var _a;
      return (_a = doctypeNode["x-publicId"]) !== null && _a !== void 0 ? _a : "";
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      var _a;
      return (_a = doctypeNode["x-systemId"]) !== null && _a !== void 0 ? _a : "";
    },
    //Node types
    isDocumentTypeNode(node2) {
      return (0, domhandler_12.isDirective)(node2) && node2.name === "!doctype";
    },
    // Source code location
    setNodeSourceCodeLocation(node2, location2) {
      if (location2) {
        node2.startIndex = location2.startOffset;
        node2.endIndex = location2.endOffset;
      }
      node2.sourceCodeLocation = location2;
    },
    getNodeSourceCodeLocation(node2) {
      return node2.sourceCodeLocation;
    },
    updateNodeSourceCodeLocation(node2, endLocation) {
      if (endLocation.endOffset != null)
        node2.endIndex = endLocation.endOffset;
      node2.sourceCodeLocation = Object.assign(Object.assign({}, node2.sourceCodeLocation), endLocation);
    }
  };
})(cjs);
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(parse5Adapter, "__esModule", { value: true });
parse5Adapter.renderWithParse5 = parse5Adapter.parseWithParse5 = void 0;
var domhandler_1$4 = lib$j;
var parse5_1 = cjs$1;
var parse5_htmlparser2_tree_adapter_1 = cjs;
function parseWithParse5(content, options2, isDocument2, context) {
  var opts = {
    scriptingEnabled: typeof options2.scriptingEnabled === "boolean" ? options2.scriptingEnabled : true,
    treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter,
    sourceCodeLocationInfo: options2.sourceCodeLocationInfo
  };
  return isDocument2 ? (0, parse5_1.parse)(content, opts) : (0, parse5_1.parseFragment)(context, content, opts);
}
parse5Adapter.parseWithParse5 = parseWithParse5;
var renderOpts = { treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter };
function renderWithParse5(dom) {
  var _a;
  var nodes = "length" in dom ? dom : [dom];
  for (var index2 = 0; index2 < nodes.length; index2 += 1) {
    var node2 = nodes[index2];
    if ((0, domhandler_1$4.isDocument)(node2)) {
      (_a = Array.prototype.splice).call.apply(_a, __spreadArray([nodes, index2, 1], node2.children, false));
    }
  }
  var result = "";
  for (var index2 = 0; index2 < nodes.length; index2 += 1) {
    var node2 = nodes[index2];
    result += (0, parse5_1.serializeOuter)(node2, renderOpts);
  }
  return result;
}
parse5Adapter.renderWithParse5 = renderWithParse5;
var lib$4 = {};
var Parser$1 = {};
var Tokenizer2 = {};
var decode = {};
var decodeDataHtml = {};
Object.defineProperty(decodeDataHtml, "__esModule", { value: true });
decodeDataHtml.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decodeDataXml = {};
Object.defineProperty(decodeDataXml, "__esModule", { value: true });
decodeDataXml.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decode_codepoint = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.QuoteType = void 0;
  var decode_js_12 = decode;
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
    CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
    CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
    CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes2[CharCodes2["Space"] = 32] = "Space";
    CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes2[CharCodes2["Number"] = 35] = "Number";
    CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
    CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
    CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
    CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
    CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
    CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
    CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
    CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
    CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
    CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
    CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
    CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
    CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
    CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
    CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
    CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
    CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
    CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
    CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  var State2;
  (function(State3) {
    State3[State3["Text"] = 1] = "Text";
    State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
    State3[State3["InTagName"] = 3] = "InTagName";
    State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
    State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State3[State3["InAttributeName"] = 9] = "InAttributeName";
    State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
    State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State3[State3["InDeclaration"] = 16] = "InDeclaration";
    State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State3[State3["BeforeComment"] = 18] = "BeforeComment";
    State3[State3["CDATASequence"] = 19] = "CDATASequence";
    State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
    State3[State3["InCommentLike"] = 21] = "InCommentLike";
    State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
    State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
    State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
    State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
    State3[State3["InHexEntity"] = 29] = "InHexEntity";
  })(State2 || (State2 = {}));
  function isWhitespace2(c) {
    return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
  }
  function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace2(c);
  }
  function isNumber(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
  }
  function isASCIIAlpha(c) {
    return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
  }
  function isHexDigit(c) {
    return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
  }
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType = exports2.QuoteType || (exports2.QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    // `</title`
  };
  var Tokenizer3 = (
    /** @class */
    function() {
      function Tokenizer4(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        this.state = State2.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State2.Text;
        this.isSpecial = false;
        this.running = true;
        this.offset = 0;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_12.xmlDecodeTree : decode_js_12.htmlDecodeTree;
      }
      Tokenizer4.prototype.reset = function() {
        this.state = State2.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State2.Text;
        this.currentSequence = void 0;
        this.running = true;
        this.offset = 0;
      };
      Tokenizer4.prototype.write = function(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
      };
      Tokenizer4.prototype.end = function() {
        if (this.running)
          this.finish();
      };
      Tokenizer4.prototype.pause = function() {
        this.running = false;
      };
      Tokenizer4.prototype.resume = function() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
          this.parse();
        }
      };
      Tokenizer4.prototype.getIndex = function() {
        return this.index;
      };
      Tokenizer4.prototype.getSectionStart = function() {
        return this.sectionStart;
      };
      Tokenizer4.prototype.stateText = function(c) {
        if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = State2.BeforeTagName;
          this.sectionStart = this.index;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.state = State2.BeforeEntity;
        }
      };
      Tokenizer4.prototype.stateSpecialStartSequence = function(c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.isSpecial = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = State2.InTagName;
        this.stateInTagName(c);
      };
      Tokenizer4.prototype.stateInSpecialTag = function(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === CharCodes.Gt || isWhitespace2(c)) {
            var endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              var actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.isSpecial = false;
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd) {
            if (this.decodeEntities && c === CharCodes.Amp) {
              this.state = State2.BeforeEntity;
            }
          } else if (this.fastForwardTo(CharCodes.Lt)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === CharCodes.Lt);
        }
      };
      Tokenizer4.prototype.stateCDATASequence = function(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = State2.InCommentLike;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = State2.InDeclaration;
          this.stateInDeclaration(c);
        }
      };
      Tokenizer4.prototype.fastForwardTo = function(c) {
        while (++this.index < this.buffer.length + this.offset) {
          if (this.buffer.charCodeAt(this.index - this.offset) === c) {
            return true;
          }
        }
        this.index = this.buffer.length + this.offset - 1;
        return false;
      };
      Tokenizer4.prototype.stateInCommentLike = function(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index, 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index, 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = State2.Text;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      };
      Tokenizer4.prototype.isTagStartChar = function(c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
      };
      Tokenizer4.prototype.startSpecial = function(sequence2, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence2;
        this.sequenceIndex = offset;
        this.state = State2.SpecialStartSequence;
      };
      Tokenizer4.prototype.stateBeforeTagName = function(c) {
        if (c === CharCodes.ExclamationMark) {
          this.state = State2.BeforeDeclaration;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Questionmark) {
          this.state = State2.InProcessingInstruction;
          this.sectionStart = this.index + 1;
        } else if (this.isTagStartChar(c)) {
          var lower = c | 32;
          this.sectionStart = this.index;
          if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
            this.startSpecial(Sequences.TitleEnd, 3);
          } else {
            this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
          }
        } else if (c === CharCodes.Slash) {
          this.state = State2.BeforeClosingTagName;
        } else {
          this.state = State2.Text;
          this.stateText(c);
        }
      };
      Tokenizer4.prototype.stateInTagName = function(c) {
        if (isEndOfTagSection(c)) {
          this.cbs.onopentagname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        }
      };
      Tokenizer4.prototype.stateBeforeClosingTagName = function(c) {
        if (isWhitespace2(c))
          ;
        else if (c === CharCodes.Gt) {
          this.state = State2.Text;
        } else {
          this.state = this.isTagStartChar(c) ? State2.InClosingTagName : State2.InSpecialComment;
          this.sectionStart = this.index;
        }
      };
      Tokenizer4.prototype.stateInClosingTagName = function(c) {
        if (c === CharCodes.Gt || isWhitespace2(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State2.AfterClosingTagName;
          this.stateAfterClosingTagName(c);
        }
      };
      Tokenizer4.prototype.stateAfterClosingTagName = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.state = State2.Text;
          this.baseState = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateBeforeAttributeName = function(c) {
        if (c === CharCodes.Gt) {
          this.cbs.onopentagend(this.index);
          if (this.isSpecial) {
            this.state = State2.InSpecialTag;
            this.sequenceIndex = 0;
          } else {
            this.state = State2.Text;
          }
          this.baseState = this.state;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Slash) {
          this.state = State2.InSelfClosingTag;
        } else if (!isWhitespace2(c)) {
          this.state = State2.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer4.prototype.stateInSelfClosingTag = function(c) {
        if (c === CharCodes.Gt) {
          this.cbs.onselfclosingtag(this.index);
          this.state = State2.Text;
          this.baseState = State2.Text;
          this.sectionStart = this.index + 1;
          this.isSpecial = false;
        } else if (!isWhitespace2(c)) {
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        }
      };
      Tokenizer4.prototype.stateInAttributeName = function(c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State2.AfterAttributeName;
          this.stateAfterAttributeName(c);
        }
      };
      Tokenizer4.prototype.stateAfterAttributeName = function(c) {
        if (c === CharCodes.Eq) {
          this.state = State2.BeforeAttributeValue;
        } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        } else if (!isWhitespace2(c)) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State2.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer4.prototype.stateBeforeAttributeValue = function(c) {
        if (c === CharCodes.DoubleQuote) {
          this.state = State2.InAttributeValueDq;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.SingleQuote) {
          this.state = State2.InAttributeValueSq;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace2(c)) {
          this.sectionStart = this.index;
          this.state = State2.InAttributeValueNq;
          this.stateInAttributeValueNoQuotes(c);
        }
      };
      Tokenizer4.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
          this.state = State2.BeforeAttributeName;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State2.BeforeEntity;
        }
      };
      Tokenizer4.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
      };
      Tokenizer4.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
      };
      Tokenizer4.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (isWhitespace2(c) || c === CharCodes.Gt) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(QuoteType.Unquoted, this.index);
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State2.BeforeEntity;
        }
      };
      Tokenizer4.prototype.stateBeforeDeclaration = function(c) {
        if (c === CharCodes.OpeningSquareBracket) {
          this.state = State2.CDATASequence;
          this.sequenceIndex = 0;
        } else {
          this.state = c === CharCodes.Dash ? State2.BeforeComment : State2.InDeclaration;
        }
      };
      Tokenizer4.prototype.stateInDeclaration = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.ondeclaration(this.sectionStart, this.index);
          this.state = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateInProcessingInstruction = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateBeforeComment = function(c) {
        if (c === CharCodes.Dash) {
          this.state = State2.InCommentLike;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = State2.InDeclaration;
        }
      };
      Tokenizer4.prototype.stateInSpecialComment = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.oncomment(this.sectionStart, this.index, 0);
          this.state = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateBeforeSpecialS = function(c) {
        var lower = c | 32;
        if (lower === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = State2.InTagName;
          this.stateInTagName(c);
        }
      };
      Tokenizer4.prototype.stateBeforeEntity = function(c) {
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Number) {
          this.state = State2.BeforeNumericEntity;
        } else if (c === CharCodes.Amp)
          ;
        else {
          this.trieIndex = 0;
          this.trieCurrent = this.entityTrie[0];
          this.state = State2.InNamedEntity;
          this.stateInNamedEntity(c);
        }
      };
      Tokenizer4.prototype.stateInNamedEntity = function(c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_12.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
          this.emitNamedEntity();
          this.index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_12.BinTrieFlags.VALUE_LENGTH;
        if (masked) {
          var valueLength = (masked >> 14) - 1;
          if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
            this.trieIndex += valueLength;
          } else {
            var entityStart = this.index - this.entityExcess + 1;
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.entityResult = this.trieIndex;
            this.trieIndex += valueLength;
            this.entityExcess = 0;
            this.sectionStart = this.index + 1;
            if (valueLength === 0) {
              this.emitNamedEntity();
            }
          }
        }
      };
      Tokenizer4.prototype.emitNamedEntity = function() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
          return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_12.BinTrieFlags.VALUE_LENGTH) >> 14;
        switch (valueLength) {
          case 1: {
            this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_12.BinTrieFlags.VALUE_LENGTH);
            break;
          }
          case 2: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            break;
          }
          case 3: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
          }
        }
      };
      Tokenizer4.prototype.stateBeforeNumericEntity = function(c) {
        if ((c | 32) === CharCodes.LowerX) {
          this.entityExcess++;
          this.state = State2.InHexEntity;
        } else {
          this.state = State2.InNumericEntity;
          this.stateInNumericEntity(c);
        }
      };
      Tokenizer4.prototype.emitNumericEntity = function(strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
        if (numberStart !== this.index) {
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.sectionStart = this.index + Number(strict);
          this.emitCodePoint((0, decode_js_12.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
      };
      Tokenizer4.prototype.stateInNumericEntity = function(c) {
        if (c === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber(c)) {
          this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer4.prototype.stateInHexEntity = function(c) {
        if (c === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber(c)) {
          this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
          this.entityExcess++;
        } else if (isHexDigit(c)) {
          this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer4.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
      };
      Tokenizer4.prototype.cleanup = function() {
        if (this.running && this.sectionStart !== this.index) {
          if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      };
      Tokenizer4.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
      };
      Tokenizer4.prototype.parse = function() {
        while (this.shouldContinue()) {
          var c = this.buffer.charCodeAt(this.index - this.offset);
          switch (this.state) {
            case State2.Text: {
              this.stateText(c);
              break;
            }
            case State2.SpecialStartSequence: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case State2.InSpecialTag: {
              this.stateInSpecialTag(c);
              break;
            }
            case State2.CDATASequence: {
              this.stateCDATASequence(c);
              break;
            }
            case State2.InAttributeValueDq: {
              this.stateInAttributeValueDoubleQuotes(c);
              break;
            }
            case State2.InAttributeName: {
              this.stateInAttributeName(c);
              break;
            }
            case State2.InCommentLike: {
              this.stateInCommentLike(c);
              break;
            }
            case State2.InSpecialComment: {
              this.stateInSpecialComment(c);
              break;
            }
            case State2.BeforeAttributeName: {
              this.stateBeforeAttributeName(c);
              break;
            }
            case State2.InTagName: {
              this.stateInTagName(c);
              break;
            }
            case State2.InClosingTagName: {
              this.stateInClosingTagName(c);
              break;
            }
            case State2.BeforeTagName: {
              this.stateBeforeTagName(c);
              break;
            }
            case State2.AfterAttributeName: {
              this.stateAfterAttributeName(c);
              break;
            }
            case State2.InAttributeValueSq: {
              this.stateInAttributeValueSingleQuotes(c);
              break;
            }
            case State2.BeforeAttributeValue: {
              this.stateBeforeAttributeValue(c);
              break;
            }
            case State2.BeforeClosingTagName: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case State2.AfterClosingTagName: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case State2.BeforeSpecialS: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case State2.InAttributeValueNq: {
              this.stateInAttributeValueNoQuotes(c);
              break;
            }
            case State2.InSelfClosingTag: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case State2.InDeclaration: {
              this.stateInDeclaration(c);
              break;
            }
            case State2.BeforeDeclaration: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case State2.BeforeComment: {
              this.stateBeforeComment(c);
              break;
            }
            case State2.InProcessingInstruction: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case State2.InNamedEntity: {
              this.stateInNamedEntity(c);
              break;
            }
            case State2.BeforeEntity: {
              this.stateBeforeEntity(c);
              break;
            }
            case State2.InHexEntity: {
              this.stateInHexEntity(c);
              break;
            }
            case State2.InNumericEntity: {
              this.stateInNumericEntity(c);
              break;
            }
            default: {
              this.stateBeforeNumericEntity(c);
            }
          }
          this.index++;
        }
        this.cleanup();
      };
      Tokenizer4.prototype.finish = function() {
        if (this.state === State2.InNamedEntity) {
          this.emitNamedEntity();
        }
        if (this.sectionStart < this.index) {
          this.handleTrailingData();
        }
        this.cbs.onend();
      };
      Tokenizer4.prototype.handleTrailingData = function() {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State2.InCommentLike) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex, 0);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex, 0);
          }
        } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName)
          ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      };
      Tokenizer4.prototype.emitPartial = function(start, endIndex) {
        if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
          this.cbs.onattribdata(start, endIndex);
        } else {
          this.cbs.ontext(start, endIndex);
        }
      };
      Tokenizer4.prototype.emitCodePoint = function(cp) {
        if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
          this.cbs.onattribentity(cp);
        } else {
          this.cbs.ontextentity(cp);
        }
      };
      return Tokenizer4;
    }()
  );
  exports2.default = Tokenizer3;
})(Tokenizer2);
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
Object.defineProperty(Parser$1, "__esModule", { value: true });
Parser$1.Parser = void 0;
var Tokenizer_js_1 = __importStar$1(Tokenizer2);
var decode_js_1 = decode;
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser2 = (
  /** @class */
  function() {
    function Parser3(cbs, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _a, _b, _c, _d, _e;
      this.options = options2;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
      this.lowerCaseTagNames = (_a = options2.lowerCaseTags) !== null && _a !== void 0 ? _a : !options2.xmlMode;
      this.lowerCaseAttributeNames = (_b = options2.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options2.xmlMode;
      this.tokenizer = new ((_c = options2.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    Parser3.prototype.ontext = function(start, endIndex) {
      var _a, _b;
      var data2 = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data2);
      this.startIndex = endIndex;
    };
    Parser3.prototype.ontextentity = function(cp) {
      var _a, _b;
      var index2 = this.tokenizer.getSectionStart();
      this.endIndex = index2 - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
      this.startIndex = index2;
    };
    Parser3.prototype.isVoidElement = function(name2) {
      return !this.options.xmlMode && voidElements.has(name2);
    };
    Parser3.prototype.onopentagname = function(start, endIndex) {
      this.endIndex = endIndex;
      var name2 = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      this.emitOpenTag(name2);
    };
    Parser3.prototype.emitOpenTag = function(name2) {
      var _a, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name2;
      var impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          var element2 = this.stack.pop();
          (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element2, true);
        }
      }
      if (!this.isVoidElement(name2)) {
        this.stack.push(name2);
        if (foreignContextElements.has(name2)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name2)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
      if (this.cbs.onopentag)
        this.attribs = {};
    };
    Parser3.prototype.endOpenTag = function(isImplied) {
      var _a, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    };
    Parser3.prototype.onopentagend = function(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onclosetag = function(start, endIndex) {
      var _a, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      var name2 = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name2)) {
        var pos = this.stack.lastIndexOf(name2);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            var count2 = this.stack.length - pos;
            while (count2--) {
              this.cbs.onclosetag(this.stack.pop(), count2 !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name2 === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name2 === "br") {
        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onselfclosingtag = function(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    };
    Parser3.prototype.closeCurrentTag = function(isOpenImplied) {
      var _a, _b;
      var name2 = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name2) {
        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name2, !isOpenImplied);
        this.stack.pop();
      }
    };
    Parser3.prototype.onattribname = function(start, endIndex) {
      this.startIndex = start;
      var name2 = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
    };
    Parser3.prototype.onattribdata = function(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    };
    Parser3.prototype.onattribentity = function(cp) {
      this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    Parser3.prototype.onattribend = function(quote, endIndex) {
      var _a, _b;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    };
    Parser3.prototype.getInstructionName = function(value) {
      var index2 = value.search(reNameEnd);
      var name2 = index2 < 0 ? value : value.substr(0, index2);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      return name2;
    };
    Parser3.prototype.ondeclaration = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("!".concat(name2), "!".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onprocessinginstruction = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("?".concat(name2), "?".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.oncomment = function(start, endIndex, offset) {
      var _a, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.oncdata = function(start, endIndex, offset) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
        (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onend = function() {
      var _a, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
          ;
      }
      (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    Parser3.prototype.reset = function() {
      var _a, _b, _c, _d;
      (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    };
    Parser3.prototype.parseComplete = function(data2) {
      this.reset();
      this.end(data2);
    };
    Parser3.prototype.getSlice = function(start, end2) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      var slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
      while (end2 - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
      }
      return slice2;
    };
    Parser3.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    };
    Parser3.prototype.write = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    };
    Parser3.prototype.end = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    };
    Parser3.prototype.pause = function() {
      this.tokenizer.pause();
    };
    Parser3.prototype.resume = function() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    };
    Parser3.prototype.parseChunk = function(chunk) {
      this.write(chunk);
    };
    Parser3.prototype.done = function(chunk) {
      this.end(chunk);
    };
    return Parser3;
  }()
);
Parser$1.Parser = Parser2;
var lib$3 = {};
var node = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
Object.defineProperty(node, "__esModule", { value: true });
node.cloneNode = node.hasChildren = node.isDocument = node.isDirective = node.isComment = node.isText = node.isCDATA = node.isTag = node.Element = node.Document = node.CDATA = node.NodeWithChildren = node.ProcessingInstruction = node.Comment = node.Text = node.DataNode = node.Node = void 0;
var domelementtype_1$1 = lib$i;
var Node = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode(this, recursive);
    };
    return Node2;
  }()
);
node.Node = Node;
var DataNode = (
  /** @class */
  function(_super) {
    __extends(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node)
);
node.DataNode = DataNode;
var Text = (
  /** @class */
  function(_super) {
    __extends(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode)
);
node.Text = Text;
var Comment = (
  /** @class */
  function(_super) {
    __extends(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode)
);
node.Comment = Comment;
var ProcessingInstruction = (
  /** @class */
  function(_super) {
    __extends(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode)
);
node.ProcessingInstruction = ProcessingInstruction;
var NodeWithChildren = (
  /** @class */
  function(_super) {
    __extends(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node)
);
node.NodeWithChildren = NodeWithChildren;
var CDATA = (
  /** @class */
  function(_super) {
    __extends(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren)
);
node.CDATA = CDATA;
var Document = (
  /** @class */
  function(_super) {
    __extends(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren)
);
node.Document = Document;
var Element = (
  /** @class */
  function(_super) {
    __extends(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$1.ElementType.Script : name2 === "style" ? domelementtype_1$1.ElementType.Style : domelementtype_1$1.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren)
);
node.Element = Element;
function isTag(node2) {
  return (0, domelementtype_1$1.isTag)(node2);
}
node.isTag = isTag;
function isCDATA(node2) {
  return node2.type === domelementtype_1$1.ElementType.CDATA;
}
node.isCDATA = isCDATA;
function isText(node2) {
  return node2.type === domelementtype_1$1.ElementType.Text;
}
node.isText = isText;
function isComment(node2) {
  return node2.type === domelementtype_1$1.ElementType.Comment;
}
node.isComment = isComment;
function isDirective(node2) {
  return node2.type === domelementtype_1$1.ElementType.Directive;
}
node.isDirective = isDirective;
function isDocument(node2) {
  return node2.type === domelementtype_1$1.ElementType.Root;
}
node.isDocument = isDocument;
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node.hasChildren = hasChildren;
function cloneNode(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText(node2)) {
    result = new Text(node2.data);
  } else if (isComment(node2)) {
    result = new Comment(node2.data);
  } else if (isTag(node2)) {
    var children = recursive ? cloneChildren(node2.children) : [];
    var clone_1 = new Element(node2.name, __assign$1({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$1({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$1({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA(node2)) {
    var children = recursive ? cloneChildren(node2.children) : [];
    var clone_2 = new CDATA(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument(node2)) {
    var children = recursive ? cloneChildren(node2.children) : [];
    var clone_3 = new Document(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective(node2)) {
    var instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node.cloneNode = cloneNode;
function cloneChildren(childs) {
  var children = childs.map(function(child) {
    return cloneNode(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node;
  __exportStar(node, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$3);
var lib$2 = {};
var stringify$3 = {};
var lib$1 = {};
var lib = {};
var encode = {};
var encodeHtml = {};
Object.defineProperty(encodeHtml, "__esModule", { value: true });
function restoreDiff(arr) {
  for (var i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
encodeHtml.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c, index2) {
      return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.encodeNonAsciiHTML = encode.encodeHTML = void 0;
var encode_html_js_1 = __importDefault$1(encodeHtml);
var escape_js_1 = _escape;
var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML(data2) {
  return encodeHTMLTrieRe(htmlReplacer, data2);
}
encode.encodeHTML = encodeHTML;
function encodeNonAsciiHTML(data2) {
  return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data2);
}
encode.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i = match.index;
    ret += str.substring(lastIdx, i);
    var char = str.charCodeAt(i);
    var next = encode_html_js_1.default.get(char);
    if (typeof next === "object") {
      if (i + 1 < str.length) {
        var nextChar = str.charCodeAt(i + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i + 1;
    } else {
      var cp = (0, escape_js_1.getCodePoint)(str, i);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode;
  var encode_js_1 = encode;
  var escape_js_12 = _escape;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode$12(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode$12;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode$12(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode$12(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode$12;
  var escape_js_2 = _escape;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib);
var foreignNames = {};
Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(lib$1, "__esModule", { value: true });
lib$1.render = void 0;
var ElementType = __importStar(lib$i);
var entities_1 = lib;
var foreignNames_js_1 = foreignNames;
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options2);
  }
  return output;
}
lib$1.render = render;
lib$1.default = render;
function renderNode(node2, options2) {
  switch (node2.type) {
    case ElementType.Root:
      return render(node2.children, options2);
    case ElementType.Doctype:
    case ElementType.Directive:
      return renderDirective(node2);
    case ElementType.Comment:
      return renderComment(node2);
    case ElementType.CDATA:
      return renderCdata(node2);
    case ElementType.Script:
    case ElementType.Style:
    case ElementType.Tag:
      return renderTag(node2, options2);
    case ElementType.Text:
      return renderText(node2, options2);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective(elem) {
  return "<".concat(elem.data, ">");
}
function renderText(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data2) : (0, entities_1.escapeText)(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$3, "__esModule", { value: true });
stringify$3.innerText = stringify$3.textContent = stringify$3.getText = stringify$3.getInnerHTML = stringify$3.getOuterHTML = void 0;
var domhandler_1$3 = lib$3;
var dom_serializer_1 = __importDefault(lib$1);
var domelementtype_1 = lib$i;
function getOuterHTML(node2, options2) {
  return (0, dom_serializer_1.default)(node2, options2);
}
stringify$3.getOuterHTML = getOuterHTML;
function getInnerHTML(node2, options2) {
  return (0, domhandler_1$3.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML(node3, options2);
  }).join("") : "";
}
stringify$3.getInnerHTML = getInnerHTML;
function getText(node2) {
  if (Array.isArray(node2))
    return node2.map(getText).join("");
  if ((0, domhandler_1$3.isTag)(node2))
    return node2.name === "br" ? "\n" : getText(node2.children);
  if ((0, domhandler_1$3.isCDATA)(node2))
    return getText(node2.children);
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$3.getText = getText;
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if ((0, domhandler_1$3.hasChildren)(node2) && !(0, domhandler_1$3.isComment)(node2)) {
    return textContent(node2.children);
  }
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$3.textContent = textContent;
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if ((0, domhandler_1$3.hasChildren)(node2) && (node2.type === domelementtype_1.ElementType.Tag || (0, domhandler_1$3.isCDATA)(node2))) {
    return innerText(node2.children);
  }
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$3.innerText = innerText;
var traversal = {};
Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$2 = lib$3;
function getChildren(elem) {
  return (0, domhandler_1$2.hasChildren)(elem) ? elem.children : [];
}
traversal.getChildren = getChildren;
function getParent(elem) {
  return elem.parent || null;
}
traversal.getParent = getParent;
function getSiblings(elem) {
  var _a, _b;
  var parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal.getSiblings = getSiblings;
function getAttributeValue(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal.getAttributeValue = getAttributeValue;
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal.hasAttrib = hasAttrib;
function getName(elem) {
  return elem.name;
}
traversal.getName = getName;
function nextElementSibling(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$2.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal.nextElementSibling = nextElementSibling;
function prevElementSibling(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$2.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal.prevElementSibling = prevElementSibling;
var manipulation = {};
Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation.removeElement = removeElement;
function replaceElement(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation.replaceElement = replaceElement;
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation.appendChild = appendChild;
function append(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation.append = append;
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation.prependChild = prependChild;
function prepend(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation.prepend = prepend;
var querying = {};
Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$1 = lib$3;
function filter(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$1(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying.filter = filter;
function find$1(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$1.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.find = find$1;
function findOneChild(test2, nodes) {
  return nodes.find(test2);
}
querying.findOneChild = findOneChild;
function findOne(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i = 0; i < nodes.length && !elem; i++) {
    var node2 = nodes[i];
    if (!(0, domhandler_1$1.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne(test2, node2.children, true);
    }
  }
  return elem;
}
querying.findOne = findOne;
function existsOne(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$1.isTag)(checked2) && (test2(checked2) || existsOne(test2, checked2.children));
  });
}
querying.existsOne = existsOne;
function findAll(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$1.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.findAll = findAll;
var legacy = {};
Object.defineProperty(legacy, "__esModule", { value: true });
legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
var domhandler_1 = lib$3;
var querying_js_1 = querying;
var Checks = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1.isTag;
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs(a, b) {
  return function(elem) {
    return a(elem) || b(elem);
  };
}
function compileTest(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options2, node2) {
  var test2 = compileTest(options2);
  return test2 ? test2(node2) : true;
}
legacy.testElement = testElement;
function getElements(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest(options2);
  return test2 ? (0, querying_js_1.filter)(test2, nodes, recurse, limit) : [];
}
legacy.getElements = getElements;
function getElementById(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1.findOne)(getAttribCheck("id", id2), nodes, recurse);
}
legacy.getElementById = getElementById;
function getElementsByTagName(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
legacy.getElementsByTagName = getElementsByTagName;
function getElementsByTagType(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}
legacy.getElementsByTagType = getElementsByTagType;
var helpers = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$3;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i, arr) {
      return !arr.includes(node2, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers);
var feeds = {};
Object.defineProperty(feeds, "__esModule", { value: true });
feeds.getFeed = void 0;
var stringify_js_1 = stringify$3;
var legacy_js_1 = legacy;
function getFeed(doc) {
  var feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
feeds.getFeed = getFeed;
function getAtomFeed(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  var updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  var updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node2) {
  return (0, legacy_js_1.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$3, exports2);
  __exportStar(traversal, exports2);
  __exportStar(manipulation, exports2);
  __exportStar(querying, exports2);
  __exportStar(legacy, exports2);
  __exportStar(helpers, exports2);
  __exportStar(feeds, exports2);
  var domhandler_12 = lib$3;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$2);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomUtils = exports2.parseFeed = exports2.getFeed = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DefaultHandler = exports2.DomHandler = exports2.Parser = void 0;
  var Parser_js_1 = Parser$1;
  var Parser_js_2 = Parser$1;
  Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
    return Parser_js_2.Parser;
  } });
  var domhandler_12 = lib$3;
  var domhandler_2 = lib$3;
  Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  function parseDocument(data2, options2) {
    var handler = new domhandler_12.DomHandler(void 0, options2);
    new Parser_js_1.Parser(handler, options2).end(data2);
    return handler.root;
  }
  exports2.parseDocument = parseDocument;
  function parseDOM(data2, options2) {
    return parseDocument(data2, options2).children;
  }
  exports2.parseDOM = parseDOM;
  function createDomStream(callback, options2, elementCallback) {
    var handler = new domhandler_12.DomHandler(callback, options2, elementCallback);
    return new Parser_js_1.Parser(handler, options2);
  }
  exports2.createDomStream = createDomStream;
  var Tokenizer_js_12 = Tokenizer2;
  Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
    return __importDefault2(Tokenizer_js_12).default;
  } });
  exports2.ElementType = __importStar2(lib$i);
  var domutils_12 = lib$2;
  var domutils_2 = lib$2;
  Object.defineProperty(exports2, "getFeed", { enumerable: true, get: function() {
    return domutils_2.getFeed;
  } });
  var parseFeedDefaultOptions = { xmlMode: true };
  function parseFeed(feed, options2) {
    if (options2 === void 0) {
      options2 = parseFeedDefaultOptions;
    }
    return (0, domutils_12.getFeed)(parseDOM(feed, options2));
  }
  exports2.parseFeed = parseFeed;
  exports2.DomUtils = __importStar2(lib$2);
})(lib$4);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m, p2);
  };
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.root = exports2.parseHTML = exports2.merge = exports2.contains = exports2.text = exports2.xml = exports2.html = exports2.load = void 0;
  __exportStar(types$1, exports2);
  var load_js_1 = load;
  var parse_js_12 = parse$5;
  var parse5_adapter_js_1 = parse5Adapter;
  var dom_serializer_12 = __importDefault2(lib$h);
  var htmlparser2_1 = lib$4;
  var parse2 = (0, parse_js_12.getParse)(function(content, options2, isDocument2, context) {
    return options2.xmlMode || options2._useHtmlParser2 ? (0, htmlparser2_1.parseDocument)(content, options2) : (0, parse5_adapter_js_1.parseWithParse5)(content, options2, isDocument2, context);
  });
  exports2.load = (0, load_js_1.getLoad)(parse2, function(dom, options2) {
    return options2.xmlMode || options2._useHtmlParser2 ? (0, dom_serializer_12.default)(dom, options2) : (0, parse5_adapter_js_1.renderWithParse5)(dom);
  });
  exports2.default = (0, exports2.load)([]);
  var static_js_12 = _static;
  Object.defineProperty(exports2, "html", { enumerable: true, get: function() {
    return static_js_12.html;
  } });
  Object.defineProperty(exports2, "xml", { enumerable: true, get: function() {
    return static_js_12.xml;
  } });
  Object.defineProperty(exports2, "text", { enumerable: true, get: function() {
    return static_js_12.text;
  } });
  var staticMethods2 = __importStar2(_static);
  exports2.contains = staticMethods2.contains;
  exports2.merge = staticMethods2.merge;
  exports2.parseHTML = staticMethods2.parseHTML;
  exports2.root = staticMethods2.root;
})(lib$l);
var utils$1 = {};
var lexer = { exports: {} };
var debug = { exports: {} };
(function(module2, exports2) {
  module2.exports = debug2;
  function debug2(label) {
    return _debug.bind(null, label);
  }
  function _debug(label) {
    var args = [].slice.call(arguments, 1);
    args.unshift("[" + label + "]");
    dist.process.stderr.write(args.join(" ") + "\n");
  }
})(debug);
var debugExports = debug.exports;
(function(module2, exports2) {
  debugExports("lex");
  module2.exports = lex;
  function lex(css2) {
    var buffer = "";
    var ch;
    var column = 0;
    var cursor = -1;
    var depth = 0;
    var line = 1;
    var state = "before-selector";
    var stack = [state];
    var token2 = {};
    var tokens = [];
    var atRules = [
      "media",
      "keyframes",
      { name: "-webkit-keyframes", type: "keyframes", prefix: "-webkit-" },
      { name: "-moz-keyframes", type: "keyframes", prefix: "-moz-" },
      { name: "-ms-keyframes", type: "keyframes", prefix: "-ms-" },
      { name: "-o-keyframes", type: "keyframes", prefix: "-o-" },
      "font-face",
      { name: "import", state: "before-at-value" },
      { name: "charset", state: "before-at-value" },
      "supports",
      "viewport",
      { name: "namespace", state: "before-at-value" },
      "document",
      { name: "-moz-document", type: "document", prefix: "-moz-" },
      "page"
    ];
    function getCh() {
      skip();
      return css2[cursor];
    }
    function getState(index2) {
      return index2 ? stack[stack.length - 1 - index2] : state;
    }
    function isNextString(str) {
      var start = cursor + 1;
      return str === css2.slice(start, start + str.length);
    }
    function find2(str) {
      var pos2 = css2.slice(cursor).indexOf(str);
      return pos2 > 0 ? pos2 : false;
    }
    function isNextChar(ch2) {
      return ch2 === peek(1);
    }
    function peek(offset) {
      return css2[cursor + (offset || 1)];
    }
    function popState() {
      var removed = stack.pop();
      state = stack[stack.length - 1];
      return removed;
    }
    function pushState(newState) {
      state = newState;
      stack.push(state);
      return stack.length;
    }
    function replaceState(newState) {
      var previousState = state;
      stack[stack.length - 1] = state = newState;
      return previousState;
    }
    function skip(n) {
      if ((n || 1) == 1) {
        if (css2[cursor] == "\n") {
          line++;
          column = 1;
        } else {
          column++;
        }
        cursor++;
      } else {
        var skipStr = css2.slice(cursor, cursor + n).split("\n");
        if (skipStr.length > 1) {
          line += skipStr.length - 1;
          column = 1;
        }
        column += skipStr[skipStr.length - 1].length;
        cursor = cursor + n;
      }
    }
    function addToken() {
      token2.end = {
        line,
        col: column
      };
      tokens.push(token2);
      buffer = "";
      token2 = {};
    }
    function initializeToken(type) {
      token2 = {
        type,
        start: {
          line,
          col: column
        }
      };
    }
    while (ch = getCh()) {
      switch (ch) {
        case " ":
          switch (getState()) {
            case "selector":
            case "value":
            case "value-paren":
            case "at-group":
            case "at-value":
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
          }
          break;
        case "\n":
        case "	":
        case "\r":
        case "\f":
          switch (getState()) {
            case "value":
            case "value-paren":
            case "at-group":
            case "comment":
            case "single-string":
            case "double-string":
            case "selector":
              buffer += ch;
              break;
            case "at-value":
              if ("\n" === ch) {
                token2.value = buffer.trim();
                addToken();
                popState();
              }
              break;
          }
          break;
        case ":":
          switch (getState()) {
            case "name":
              token2.name = buffer.trim();
              buffer = "";
              replaceState("before-value");
              break;
            case "before-selector":
              buffer += ch;
              initializeToken("selector");
              pushState("selector");
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
            default:
              buffer += ch;
              break;
          }
          break;
        case ";":
          switch (getState()) {
            case "name":
            case "before-value":
            case "value":
              if (buffer.trim().length > 0) {
                token2.value = buffer.trim(), addToken();
              }
              replaceState("before-name");
              break;
            case "value-paren":
              buffer += ch;
              break;
            case "at-value":
              token2.value = buffer.trim();
              addToken();
              popState();
              break;
            case "before-name":
              break;
            default:
              buffer += ch;
              break;
          }
          break;
        case "{":
          switch (getState()) {
            case "selector":
              if (peek(-1) === "\\") {
                buffer += ch;
                break;
              }
              token2.text = buffer.trim();
              addToken();
              replaceState("before-name");
              depth = depth + 1;
              break;
            case "at-group":
              token2.name = buffer.trim();
              switch (token2.type) {
                case "font-face":
                case "viewport":
                case "page":
                  pushState("before-name");
                  break;
                default:
                  pushState("before-selector");
              }
              addToken();
              depth = depth + 1;
              break;
            case "name":
            case "at-rule":
              token2.name = buffer.trim();
              addToken();
              pushState("before-name");
              depth = depth + 1;
              break;
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
          }
          break;
        case "}":
          switch (getState()) {
            case "before-name":
            case "name":
            case "before-value":
            case "value":
              if (buffer) {
                token2.value = buffer.trim();
              }
              if (token2.name && token2.value) {
                addToken();
              }
              initializeToken("end");
              addToken();
              popState();
              if ("at-group" === getState()) {
                initializeToken("at-group-end");
                addToken();
                popState();
              }
              if (depth > 0) {
                depth = depth - 1;
              }
              break;
            case "at-group":
            case "before-selector":
            case "selector":
              if (peek(-1) === "\\") {
                buffer += ch;
                break;
              }
              if (depth > 0) {
                if ("at-group" === getState(1)) {
                  initializeToken("at-group-end");
                  addToken();
                }
              }
              if (depth > 1) {
                popState();
              }
              if (depth > 0) {
                depth = depth - 1;
              }
              break;
            case "double-string":
            case "single-string":
            case "comment":
              buffer += ch;
              break;
          }
          break;
        case '"':
        case "'":
          switch (getState()) {
            case "double-string":
              if ('"' === ch && "\\" !== peek(-1)) {
                popState();
              }
              break;
            case "single-string":
              if ("'" === ch && "\\" !== peek(-1)) {
                popState();
              }
              break;
            case "before-at-value":
              replaceState("at-value");
              pushState('"' === ch ? "double-string" : "single-string");
              break;
            case "before-value":
              replaceState("value");
              pushState('"' === ch ? "double-string" : "single-string");
              break;
            case "comment":
              break;
            default:
              if ("\\" !== peek(-1)) {
                pushState('"' === ch ? "double-string" : "single-string");
              }
          }
          buffer += ch;
          break;
        case "/":
          switch (getState()) {
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
            case "before-value":
            case "selector":
            case "name":
            case "value":
              if (isNextChar("*")) {
                var pos = find2("*/");
                if (pos) {
                  skip(pos + 1);
                }
              } else {
                if (getState() == "before-value")
                  replaceState("value");
                buffer += ch;
              }
              break;
            default:
              if (isNextChar("*")) {
                initializeToken("comment");
                pushState("comment");
                skip();
              } else {
                buffer += ch;
              }
              break;
          }
          break;
        case "*":
          switch (getState()) {
            case "comment":
              if (isNextChar("/")) {
                token2.text = buffer;
                skip();
                addToken();
                popState();
              } else {
                buffer += ch;
              }
              break;
            case "before-selector":
              buffer += ch;
              initializeToken("selector");
              pushState("selector");
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
            default:
              buffer += ch;
          }
          break;
        case "@":
          switch (getState()) {
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
            default:
              var tokenized = false;
              var name2;
              var rule;
              for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
                rule = atRules[j];
                name2 = rule.name || rule;
                if (!isNextString(name2)) {
                  continue;
                }
                tokenized = true;
                initializeToken(name2);
                pushState(rule.state || "at-group");
                skip(name2.length);
                if (rule.prefix) {
                  token2.prefix = rule.prefix;
                }
                if (rule.type) {
                  token2.type = rule.type;
                }
              }
              if (!tokenized) {
                buffer += ch;
              }
              break;
          }
          break;
        case "(":
          switch (getState()) {
            case "value":
              pushState("value-paren");
              break;
            case "before-value":
              replaceState("value");
              break;
          }
          buffer += ch;
          break;
        case ")":
          switch (getState()) {
            case "value-paren":
              popState();
              break;
            case "before-value":
              replaceState("value");
              break;
          }
          buffer += ch;
          break;
        default:
          switch (getState()) {
            case "before-selector":
              initializeToken("selector");
              pushState("selector");
              break;
            case "before-name":
              initializeToken("property");
              replaceState("name");
              break;
            case "before-value":
              replaceState("value");
              break;
            case "before-at-value":
              replaceState("at-value");
              break;
          }
          buffer += ch;
          break;
      }
    }
    return tokens;
  }
})(lexer);
var lexerExports = lexer.exports;
var parser$1 = { exports: {} };
(function(module2, exports2) {
  debugExports("parse");
  var lex = lexerExports;
  module2.exports = parse2;
  var _comments;
  var _depth;
  var _position;
  var _tokens;
  function parse2(css2, options2) {
    options2 || (options2 = {});
    _comments = !!options2.comments;
    _position = !!options2.position;
    _depth = 0;
    _tokens = Array.isArray(css2) ? css2.slice() : lex(css2);
    var rule;
    var rules = [];
    var token2;
    while (token2 = next()) {
      rule = parseToken(token2);
      rule && rules.push(rule);
    }
    return {
      type: "stylesheet",
      stylesheet: {
        rules
      }
    };
  }
  function astNode(token2, override) {
    override || (override = {});
    var key2;
    var keys = ["type", "name", "value"];
    var node2 = {};
    for (var i = 0; i < keys.length; ++i) {
      key2 = keys[i];
      if (token2[key2]) {
        node2[key2] = override[key2] || token2[key2];
      }
    }
    keys = Object.keys(override);
    for (i = 0; i < keys.length; ++i) {
      key2 = keys[i];
      if (!node2[key2]) {
        node2[key2] = override[key2];
      }
    }
    if (_position) {
      node2.position = {
        start: token2.start,
        end: token2.end
      };
    }
    return node2;
  }
  function next() {
    var token2 = _tokens.shift();
    return token2;
  }
  function parseAtGroup(token2) {
    _depth = _depth + 1;
    var overrides = {};
    switch (token2.type) {
      case "font-face":
      case "viewport":
        overrides.declarations = parseDeclarations();
        break;
      case "page":
        overrides.prefix = token2.prefix;
        overrides.declarations = parseDeclarations();
        break;
      default:
        overrides.prefix = token2.prefix;
        overrides.rules = parseRules();
    }
    return astNode(token2, overrides);
  }
  function parseAtImport(token2) {
    return astNode(token2);
  }
  function parseCharset(token2) {
    return astNode(token2);
  }
  function parseComment(token2) {
    return astNode(token2, { text: token2.text });
  }
  function parseNamespace(token2) {
    return astNode(token2);
  }
  function parseProperty(token2) {
    return astNode(token2);
  }
  function parseSelector2(token2) {
    function trim(str) {
      return str.trim();
    }
    return astNode(token2, {
      type: "rule",
      selectors: token2.text.split(",").map(trim),
      declarations: parseDeclarations()
    });
  }
  function parseToken(token2) {
    switch (token2.type) {
      case "property":
        return parseProperty(token2);
      case "selector":
        return parseSelector2(token2);
      case "at-group-end":
        _depth = _depth - 1;
        return;
      case "media":
      case "keyframes":
        return parseAtGroup(token2);
      case "comment":
        if (_comments) {
          return parseComment(token2);
        }
        break;
      case "charset":
        return parseCharset(token2);
      case "import":
        return parseAtImport(token2);
      case "namespace":
        return parseNamespace(token2);
      case "font-face":
      case "supports":
      case "viewport":
      case "document":
      case "page":
        return parseAtGroup(token2);
    }
  }
  function parseTokensWhile(conditionFn) {
    var node2;
    var nodes = [];
    var token2;
    while ((token2 = next()) && (conditionFn && conditionFn(token2))) {
      node2 = parseToken(token2);
      node2 && nodes.push(node2);
    }
    if (token2 && token2.type !== "end") {
      _tokens.unshift(token2);
    }
    return nodes;
  }
  function parseDeclarations() {
    return parseTokensWhile(function(token2) {
      return token2.type === "property" || token2.type === "comment";
    });
  }
  function parseRules() {
    return parseTokensWhile(function() {
      return _depth;
    });
  }
})(parser$1);
var parserExports = parser$1.exports;
var stringify$2 = { exports: {} };
(function(module2, exports2) {
  debugExports("stringify");
  var _comments;
  var _compress;
  var _indentation;
  var _level;
  var _n;
  var _s;
  module2.exports = stringify2;
  function stringify2(ast, options2) {
    options2 || (options2 = {});
    _indentation = options2.indentation || "";
    _compress = !!options2.compress;
    _comments = !!options2.comments;
    _level = 1;
    if (_compress) {
      _n = _s = "";
    } else {
      _n = "\n";
      _s = " ";
    }
    var css2 = reduce(ast.stylesheet.rules, stringifyNode).join("\n").trim();
    return css2;
  }
  function indent(level) {
    if (level) {
      _level += level;
      return;
    }
    if (_compress) {
      return "";
    }
    return Array(_level).join(_indentation || "");
  }
  function stringifyAtRule(node2) {
    return "@" + node2.type + " " + node2.value + ";" + _n;
  }
  function stringifyAtGroup(node2) {
    var label = "";
    var prefix = node2.prefix || "";
    if (node2.name) {
      label = " " + node2.name;
    }
    var chomp = node2.type !== "page";
    return "@" + prefix + node2.type + label + _s + stringifyBlock(node2, chomp) + _n;
  }
  function stringifyComment(node2) {
    if (!_comments) {
      return "";
    }
    return "/*" + (node2.text || "") + "*/" + _n;
  }
  function stringifyRule(node2) {
    var label;
    if (node2.selectors) {
      label = node2.selectors.join("," + _n);
    } else {
      label = "@" + node2.type;
      label += node2.name ? " " + node2.name : "";
    }
    return indent() + label + _s + stringifyBlock(node2) + _n;
  }
  function reduce(items, fn) {
    return items.reduce(function(results, item) {
      var result = item.type === "comment" ? stringifyComment(item) : fn(item);
      result && results.push(result);
      return results;
    }, []);
  }
  function stringifyBlock(node2, chomp) {
    var children = node2.declarations;
    var fn = stringifyDeclaration;
    if (node2.rules) {
      children = node2.rules;
      fn = stringifyRule;
    }
    children = stringifyChildren(children, fn);
    children && (children = _n + children + (chomp ? "" : _n));
    return "{" + children + indent() + "}";
  }
  function stringifyChildren(children, fn) {
    if (!children) {
      return "";
    }
    indent(1);
    var results = reduce(children, fn);
    indent(-1);
    if (!results.length) {
      return "";
    }
    return results.join(_n);
  }
  function stringifyDeclaration(node2) {
    if (node2.type === "property") {
      return stringifyProperty(node2);
    }
  }
  function stringifyNode(node2) {
    switch (node2.type) {
      case "rule":
        return stringifyRule(node2);
      case "media":
      case "keyframes":
        return stringifyAtGroup(node2);
      case "comment":
        return stringifyComment(node2);
      case "import":
      case "charset":
      case "namespace":
        return stringifyAtRule(node2);
      case "font-face":
      case "supports":
      case "viewport":
      case "document":
      case "page":
        return stringifyAtGroup(node2);
    }
  }
  function stringifyProperty(node2) {
    var name2 = node2.name ? node2.name + ":" + _s : "";
    return indent() + name2 + node2.value + ";";
  }
})(stringify$2);
var stringifyExports = stringify$2.exports;
var mensch = {
  lex: lexerExports,
  parse: parserExports,
  stringify: stringifyExports
};
var selector = { exports: {} };
var escapeRe = /([-.*+?^${}()|[\]\/\\])/g, unescapeRe = /\\/g;
var escape = function(string) {
  return (string + "").replace(escapeRe, "\\$1");
};
var unescape = function(string) {
  return (string + "").replace(unescapeRe, "");
};
var slickRe = RegExp(
  /*
  #!/usr/bin/env ruby
  puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
  __END__
      "(?x)^(?:\
        \\s* ( , ) \\s*               # Separator          \n\
      | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
      |      ( \\s+ )                 # CombinatorChildren \n\
      |      ( <unicode>+ | \\* )     # Tag                \n\
      | \\#  ( <unicode>+       )     # ID                 \n\
      | \\.  ( <unicode>+       )     # ClassName          \n\
      |                               # Attribute          \n\
      \\[  \
          \\s* (<unicode1>+)  (?:  \
              \\s* ([*^$!~|]?=)  (?:  \
                  \\s* (?:\
                      ([\"']?)(.*?)\\9 \
                  )\
              )  \
          )?  \\s*  \
      \\](?!\\]) \n\
      |   :+ ( <unicode>+ )(?:\
      \\( (?:\
          (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
      ) \\)\
      )?\
      )"
  */
  `^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:(["']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:(["'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)`.replace(/<combinator>/, "[" + escape(">+~`!@$%^&={}\\;</") + "]").replace(/<unicode>/g, "(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])").replace(/<unicode1>/g, "(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])")
);
var Part = function Part2(combinator) {
  this.combinator = combinator || " ";
  this.tag = "*";
};
Part.prototype.toString = function() {
  if (!this.raw) {
    var xpr = "", k, part;
    xpr += this.tag || "*";
    if (this.id)
      xpr += "#" + this.id;
    if (this.classes)
      xpr += "." + this.classList.join(".");
    if (this.attributes)
      for (k = 0; part = this.attributes[k++]; ) {
        xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : "") + "]";
      }
    if (this.pseudos)
      for (k = 0; part = this.pseudos[k++]; ) {
        xpr += ":" + part.name;
        if (part.value)
          xpr += "(" + part.value + ")";
      }
    this.raw = xpr;
  }
  return this.raw;
};
var Expression = function Expression2() {
  this.length = 0;
};
Expression.prototype.toString = function() {
  if (!this.raw) {
    var xpr = "";
    for (var j = 0, bit; bit = this[j++]; ) {
      if (j !== 1)
        xpr += " ";
      if (bit.combinator !== " ")
        xpr += bit.combinator + " ";
      xpr += bit;
    }
    this.raw = xpr;
  }
  return this.raw;
};
var replacer = function(rawMatch, separator, combinator, combinatorChildren, tagName, id2, className2, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {
  var expression, current;
  if (separator || !this.length) {
    expression = this[this.length++] = new Expression();
    if (separator)
      return "";
  }
  if (!expression)
    expression = this[this.length - 1];
  if (combinator || combinatorChildren || !expression.length) {
    current = expression[expression.length++] = new Part(combinator);
  }
  if (!current)
    current = expression[expression.length - 1];
  if (tagName) {
    current.tag = unescape(tagName);
  } else if (id2) {
    current.id = unescape(id2);
  } else if (className2) {
    var unescaped = unescape(className2);
    var classes = current.classes || (current.classes = {});
    if (!classes[unescaped]) {
      classes[unescaped] = escape(className2);
      var classList = current.classList || (current.classList = []);
      classList.push(unescaped);
      classList.sort();
    }
  } else if (pseudoClass) {
    pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
    (current.pseudos || (current.pseudos = [])).push({
      type: pseudoMarker.length == 1 ? "class" : "element",
      name: unescape(pseudoClass),
      escapedName: escape(pseudoClass),
      value: pseudoClassValue ? unescape(pseudoClassValue) : null,
      escapedValue: pseudoClassValue ? escape(pseudoClassValue) : null
    });
  } else if (attributeKey) {
    attributeValue = attributeValue ? escape(attributeValue) : null;
    (current.attributes || (current.attributes = [])).push({
      operator: attributeOperator,
      name: unescape(attributeKey),
      escapedName: escape(attributeKey),
      value: attributeValue ? unescape(attributeValue) : null,
      escapedValue: attributeValue ? escape(attributeValue) : null
    });
  }
  return "";
};
var Expressions = function Expressions2(expression) {
  this.length = 0;
  var self2 = this;
  var original = expression, replaced;
  while (expression) {
    replaced = expression.replace(slickRe, function() {
      return replacer.apply(self2, arguments);
    });
    if (replaced === expression)
      throw new Error(original + " is an invalid expression");
    expression = replaced;
  }
};
Expressions.prototype.toString = function() {
  if (!this.raw) {
    var expressions = [];
    for (var i = 0, expression; expression = this[i++]; )
      expressions.push(expression);
    this.raw = expressions.join(", ");
  }
  return this.raw;
};
var cache = {};
var parse$3 = function(expression) {
  if (expression == null)
    return null;
  expression = ("" + expression).replace(/^\s+|\s+$/g, "");
  return cache[expression] || (cache[expression] = new Expressions(expression));
};
var parser = parse$3;
(function(module2, exports2) {
  var parser$12 = parser;
  module2.exports = Selector;
  function Selector(text2, styleAttribute) {
    this.text = text2;
    this.spec = void 0;
    this.styleAttribute = styleAttribute || false;
  }
  Selector.prototype.parsed = function() {
    if (!this.tokens) {
      this.tokens = parse2(this.text);
    }
    return this.tokens;
  };
  Selector.prototype.specificity = function() {
    var styleAttribute = this.styleAttribute;
    if (!this.spec) {
      this.spec = specificity(this.text, this.parsed());
    }
    return this.spec;
    function specificity(text2, parsed) {
      var expressions = parsed || parse2(text2);
      var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
      var nots = [];
      for (var i = 0; i < expressions.length; i++) {
        var expression = expressions[i];
        var pseudos2 = expression.pseudos;
        if (expression.id) {
          spec[1]++;
        }
        if (expression.attributes) {
          spec[2] += expression.attributes.length;
        }
        if (expression.classList) {
          spec[2] += expression.classList.length;
        }
        if (expression.tag && expression.tag !== "*") {
          spec[3]++;
        }
        if (pseudos2) {
          spec[3] += pseudos2.length;
          for (var p2 = 0; p2 < pseudos2.length; p2++) {
            if (pseudos2[p2].name === "not") {
              nots.push(pseudos2[p2].value);
              spec[3]--;
            }
          }
        }
      }
      for (var ii = nots.length; ii--; ) {
        var not2 = specificity(nots[ii]);
        for (var jj = 4; jj--; ) {
          spec[jj] += not2[jj];
        }
      }
      return spec;
    }
  };
  function parse2(text2) {
    try {
      return parser$12(text2)[0];
    } catch (e) {
      return [];
    }
  }
})(selector);
var selectorExports = selector.exports;
var property = { exports: {} };
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty)
    return property.exports;
  hasRequiredProperty = 1;
  (function(module2, exports2) {
    module2.exports = Property;
    var utils2 = requireUtils();
    function Property(prop2, value, selector2, priority, additionalPriority) {
      this.prop = prop2;
      this.value = value;
      this.selector = selector2;
      this.priority = priority || 0;
      this.additionalPriority = additionalPriority || [];
    }
    Property.prototype.compareFunc = function(property2) {
      var a = [];
      a.push.apply(a, this.selector.specificity());
      a.push.apply(a, this.additionalPriority);
      a[0] += this.priority;
      var b = [];
      b.push.apply(b, property2.selector.specificity());
      b.push.apply(b, property2.additionalPriority);
      b[0] += property2.priority;
      return utils2.compareFunc(a, b);
    };
    Property.prototype.compare = function(property2) {
      var winner = this.compareFunc(property2);
      if (winner === 1) {
        return this;
      }
      return property2;
    };
    Property.prototype.toString = function() {
      return this.prop + ": " + this.value.replace(/['"]+/g, "") + ";";
    };
  })(property);
  return property.exports;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$1;
  hasRequiredUtils = 1;
  (function(exports2) {
    var mensch$1 = mensch;
    var Selector = selectorExports;
    var Property = requireProperty();
    exports2.Selector = Selector;
    exports2.Property = Property;
    /**
     * Returns an array of the selectors.
     *
     * @license Sizzle CSS Selector Engine - MIT
     * @param {String} selectorText from mensch
     * @api public
     */
    exports2.extract = function extract(selectorText) {
      var attr2 = 0;
      var sels = [];
      var sel = "";
      for (var i = 0, l = selectorText.length; i < l; i++) {
        var c = selectorText.charAt(i);
        if (attr2) {
          if ("]" === c || ")" === c) {
            attr2--;
          }
          sel += c;
        } else {
          if ("," === c) {
            sels.push(sel);
            sel = "";
          } else {
            if ("[" === c || "(" === c) {
              attr2++;
            }
            if (sel.length || c !== "," && c !== "\n" && c !== " ") {
              sel += c;
            }
          }
        }
      }
      if (sel.length) {
        sels.push(sel);
      }
      return sels;
    };
    exports2.parseCSS = function(css2) {
      var parsed = mensch$1.parse(css2, { position: true, comments: true });
      var rules = typeof parsed.stylesheet != "undefined" && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
      var ret = [];
      for (var i = 0, l = rules.length; i < l; i++) {
        if (rules[i].type == "rule") {
          var rule = rules[i];
          var selectors = rule.selectors;
          for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
            ret.push([selectors[ii], rule.declarations]);
          }
        }
      }
      return ret;
    };
    exports2.getPreservedText = function(css2, options2, ignoredPseudos) {
      var parsed = mensch$1.parse(css2, { position: true, comments: true });
      var rules = typeof parsed.stylesheet != "undefined" && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
      var preserved = [];
      for (var i = rules.length - 1; i >= 0; i--) {
        if (options2.fontFaces && rules[i].type === "font-face" || options2.mediaQueries && rules[i].type === "media" || options2.keyFrames && rules[i].type === "keyframes" || options2.pseudos && rules[i].selectors && this.matchesPseudo(rules[i].selectors[0], ignoredPseudos)) {
          preserved.unshift(
            mensch$1.stringify(
              { stylesheet: { rules: [rules[i]] } },
              { comments: false, indentation: "  " }
            )
          );
        }
        rules[i].position.start;
      }
      if (preserved.length === 0) {
        return false;
      }
      return "\n" + preserved.join("\n") + "\n";
    };
    exports2.normalizeLineEndings = function(text2) {
      return text2.replace(/\r\n/g, "\n").replace(/\n/g, "\r\n");
    };
    exports2.matchesPseudo = function(needle, haystack) {
      return haystack.find(function(element2) {
        return needle.indexOf(element2) > -1;
      });
    };
    exports2.compareFunc = function(a, b) {
      var min = Math.min(a.length, b.length);
      for (var i = 0; i < min; i++) {
        if (a[i] === b[i]) {
          continue;
        }
        if (a[i] > b[i]) {
          return 1;
        }
        return -1;
      }
      return a.length - b.length;
    };
    exports2.compare = function(a, b) {
      return exports2.compareFunc(a, b) == 1 ? a : b;
    };
    exports2.getDefaultOptions = function(options2) {
      var result = Object.assign({
        extraCss: "",
        insertPreservedExtraCss: true,
        applyStyleTags: true,
        removeStyleTags: true,
        preserveMediaQueries: true,
        preserveFontFaces: true,
        preserveKeyFrames: true,
        preservePseudos: true,
        applyWidthAttributes: true,
        applyHeightAttributes: true,
        applyAttributesTableElements: true,
        url: ""
      }, options2);
      result.webResources = result.webResources || {};
      return result;
    };
  })(utils$1);
  return utils$1;
}
(function(module2) {
  var cheerio2 = lib$l;
  requireUtils();
  var cheerioLoad = function(html2, options2, encodeEntities) {
    options2 = Object.assign({ decodeEntities: false, _useHtmlParser2: true }, options2);
    html2 = encodeEntities(html2);
    return cheerio2.load(html2, options2);
  };
  var createEntityConverters = function() {
    var codeBlockLookup = [];
    var encodeCodeBlocks = function(html2) {
      var blocks = module2.exports.codeBlocks;
      Object.keys(blocks).forEach(function(key2) {
        var re2 = new RegExp(blocks[key2].start + "([\\S\\s]*?)" + blocks[key2].end, "g");
        html2 = html2.replace(re2, function(match, subMatch) {
          codeBlockLookup.push(match);
          return "JUICE_CODE_BLOCK_" + (codeBlockLookup.length - 1) + "_";
        });
      });
      return html2;
    };
    var decodeCodeBlocks = function(html2) {
      for (var index2 = 0; index2 < codeBlockLookup.length; index2++) {
        var re2 = new RegExp("JUICE_CODE_BLOCK_" + index2 + '_(="")?', "gi");
        html2 = html2.replace(re2, function() {
          return codeBlockLookup[index2];
        });
      }
      return html2;
    };
    return {
      encodeEntities: encodeCodeBlocks,
      decodeEntities: decodeCodeBlocks
    };
  };
  module2.exports = function(html2, options2, callback, callbackExtraArguments) {
    var entityConverters = createEntityConverters();
    var $ = cheerioLoad(html2, options2, entityConverters.encodeEntities);
    var args = [$];
    args.push.apply(args, callbackExtraArguments);
    var doc = callback.apply(void 0, args) || $;
    if (options2 && options2.xmlMode) {
      return entityConverters.decodeEntities(doc.xml());
    }
    return entityConverters.decodeEntities(doc.html());
  };
  module2.exports.codeBlocks = {
    EJS: { start: "<%", end: "%>" },
    HBS: { start: "{{", end: "}}" }
  };
})(cheerio$2);
var cheerioExports = cheerio$2.exports;
var numbers$1 = {};
numbers$1.romanize = function(num) {
  if (isNaN(num))
    return NaN;
  var digits = String(+num).split(""), key2 = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
  ], roman = "", i = 3;
  while (i--)
    roman = (key2[+digits.pop() + i * 10] || "") + roman;
  return Array(+digits.join("") + 1).join("M") + roman;
};
numbers$1.alphanumeric = function(num) {
  var s2 = "", t;
  while (num > 0) {
    t = (num - 1) % 26;
    s2 = String.fromCharCode(65 + t) + s2;
    num = (num - t) / 26 | 0;
  }
  return s2 || void 0;
};
var utils = requireUtils();
var numbers = numbers$1;
var inline = function makeJuiceClient(juiceClient2) {
  juiceClient2.ignoredPseudos = ["hover", "active", "focus", "visited", "link"];
  juiceClient2.widthElements = ["TABLE", "TD", "TH", "IMG"];
  juiceClient2.heightElements = ["TABLE", "TD", "TH", "IMG"];
  juiceClient2.tableElements = ["TABLE", "TH", "TR", "TD", "CAPTION", "COLGROUP", "COL", "THEAD", "TBODY", "TFOOT"];
  juiceClient2.nonVisualElements = ["HEAD", "TITLE", "BASE", "LINK", "STYLE", "META", "SCRIPT", "NOSCRIPT"];
  juiceClient2.styleToAttribute = {
    "background-color": "bgcolor",
    "background-image": "background",
    "text-align": "align",
    "vertical-align": "valign"
  };
  juiceClient2.excludedProperties = [];
  juiceClient2.juiceDocument = juiceDocument2;
  juiceClient2.inlineDocument = inlineDocument;
  function inlineDocument($, css2, options2) {
    options2 = options2 || {};
    var rules = utils.parseCSS(css2);
    var editedElements = [];
    var styleAttributeName = "style";
    var counters = {};
    if (options2.styleAttributeName) {
      styleAttributeName = options2.styleAttributeName;
    }
    rules.forEach(handleRule);
    editedElements.forEach(setStyleAttrs);
    if (options2.inlinePseudoElements) {
      editedElements.forEach(inlinePseudoElements);
    }
    if (options2.applyWidthAttributes) {
      editedElements.forEach(function(el) {
        setDimensionAttrs(el, "width");
      });
    }
    if (options2.applyHeightAttributes) {
      editedElements.forEach(function(el) {
        setDimensionAttrs(el, "height");
      });
    }
    if (options2.applyAttributesTableElements) {
      editedElements.forEach(setAttributesOnTableElements);
    }
    if (options2.insertPreservedExtraCss && options2.extraCss) {
      var preservedText = utils.getPreservedText(options2.extraCss, {
        mediaQueries: options2.preserveMediaQueries,
        fontFaces: options2.preserveFontFaces,
        keyFrames: options2.preserveKeyFrames
      });
      if (preservedText) {
        var $appendTo = null;
        if (options2.insertPreservedExtraCss !== true) {
          $appendTo = $(options2.insertPreservedExtraCss);
        } else {
          $appendTo = $("head");
          if (!$appendTo.length) {
            $appendTo = $("body");
          }
          if (!$appendTo.length) {
            $appendTo = $.root();
          }
        }
        $appendTo.first().append("<style>" + preservedText + "</style>");
      }
    }
    function handleRule(rule) {
      var sel = rule[0];
      var style2 = rule[1];
      var selector2 = new utils.Selector(sel);
      var parsedSelector = selector2.parsed();
      if (!parsedSelector) {
        return;
      }
      var pseudoElementType = getPseudoElementType(parsedSelector);
      for (var i = 0; i < parsedSelector.length; ++i) {
        var subSel = parsedSelector[i];
        if (subSel.pseudos) {
          for (var j = 0; j < subSel.pseudos.length; ++j) {
            var subSelPseudo = subSel.pseudos[j];
            if (juiceClient2.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
              return;
            }
          }
        }
      }
      if (pseudoElementType) {
        var last2 = parsedSelector[parsedSelector.length - 1];
        var pseudos2 = last2.pseudos;
        last2.pseudos = filterElementPseudos(last2.pseudos);
        sel = parsedSelector.toString();
        last2.pseudos = pseudos2;
      }
      var els;
      try {
        els = $(sel);
      } catch (err) {
        return;
      }
      els.each(function() {
        var el = this;
        if (el.name && juiceClient2.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
          return;
        }
        if (!el.counterProps) {
          el.counterProps = el.parent && el.parent.counterProps ? Object.create(el.parent.counterProps) : {};
        }
        if (pseudoElementType) {
          var pseudoElPropName = "pseudo" + pseudoElementType;
          var pseudoEl = el[pseudoElPropName];
          if (!pseudoEl) {
            pseudoEl = el[pseudoElPropName] = $("<span />").get(0);
            pseudoEl.pseudoElementType = pseudoElementType;
            pseudoEl.pseudoElementParent = el;
            pseudoEl.counterProps = el.counterProps;
            el[pseudoElPropName] = pseudoEl;
          }
          el = pseudoEl;
        }
        if (!el.styleProps) {
          el.styleProps = {};
          if ($(el).attr(styleAttributeName)) {
            var cssText = "* { " + $(el).attr(styleAttributeName) + " } ";
            addProps(utils.parseCSS(cssText)[0][1], new utils.Selector("<style>", true));
          }
          editedElements.push(el);
        }
        function resetCounter(el2, value) {
          var tokens = value.split(/\s+/);
          for (var j2 = 0; j2 < tokens.length; j2++) {
            var counter = tokens[j2];
            var resetval = parseInt(tokens[j2 + 1], 10);
            isNaN(resetval) ? el2.counterProps[counter] = counters[counter] = 0 : el2.counterProps[counter] = counters[tokens[j2++]] = resetval;
          }
        }
        function incrementCounter(el2, value) {
          var tokens = value.split(/\s+/);
          for (var j2 = 0; j2 < tokens.length; j2++) {
            var counter = tokens[j2];
            if (el2.counterProps[counter] === void 0) {
              continue;
            }
            var incrval = parseInt(tokens[j2 + 1], 10);
            isNaN(incrval) ? el2.counterProps[counter] = counters[counter] += 1 : el2.counterProps[counter] = counters[tokens[j2++]] += incrval;
          }
        }
        function addProps(style3, selector3) {
          for (var i2 = 0, l = style3.length; i2 < l; i2++) {
            if (style3[i2].type == "property") {
              var name2 = style3[i2].name;
              var value = style3[i2].value;
              if (name2 === "counter-reset") {
                resetCounter(el, value);
              }
              if (name2 === "counter-increment") {
                incrementCounter(el, value);
              }
              var important = value.match(/!important$/) !== null;
              if (important && !options2.preserveImportant)
                value = removeImportant(value);
              var additionalPriority = [style3[i2].position.start.line, style3[i2].position.start.col];
              var prop2 = new utils.Property(name2, value, selector3, important ? 2 : 0, additionalPriority);
              var existing = el.styleProps[name2];
              if (juiceClient2.excludedProperties.indexOf(name2) < 0) {
                if (existing && existing.compare(prop2) === prop2 || !existing) {
                  if (existing && existing.selector !== selector3) {
                    delete el.styleProps[name2];
                  } else if (existing) {
                    prop2.nextProp = existing;
                  }
                  el.styleProps[name2] = prop2;
                }
              }
            }
          }
        }
        addProps(style2, selector2);
      });
    }
    function setStyleAttrs(el) {
      Object.keys(el.styleProps).length;
      var props = [];
      Object.keys(el.styleProps).forEach(function(key2) {
        var np = el.styleProps[key2];
        while (typeof np !== "undefined") {
          props.push(np);
          np = np.nextProp;
        }
      });
      props.sort(function(a, b) {
        return a.compareFunc(b);
      });
      var string = props.filter(function(prop2) {
        return prop2.prop !== "content";
      }).map(function(prop2) {
        return prop2.prop + ": " + prop2.value.replace(/["]/g, "'") + ";";
      }).join(" ");
      if (string) {
        $(el).attr(styleAttributeName, string);
      }
    }
    function inlinePseudoElements(el) {
      if (el.pseudoElementType && el.styleProps.content) {
        var parsed = parseContent(el);
        if (parsed.img) {
          el.name = "img";
          $(el).attr("src", parsed.img);
        } else {
          $(el).text(parsed);
        }
        var parent = el.pseudoElementParent;
        if (el.pseudoElementType === "before") {
          $(parent).prepend(el);
        } else {
          $(parent).append(el);
        }
      }
    }
    function setDimensionAttrs(el, dimension) {
      if (!el.name) {
        return;
      }
      var elName = el.name.toUpperCase();
      if (juiceClient2[dimension + "Elements"].indexOf(elName) > -1) {
        for (var i in el.styleProps) {
          if (el.styleProps[i].prop === dimension) {
            var value = el.styleProps[i].value;
            if (options2.preserveImportant) {
              value = removeImportant(value);
            }
            if (value.match(/(px|auto)/)) {
              var size = value.replace("px", "");
              $(el).attr(dimension, size);
              return;
            }
            if (juiceClient2.tableElements.indexOf(elName) > -1 && value.match(/\%/)) {
              $(el).attr(dimension, value);
              return;
            }
          }
        }
      }
    }
    function extractBackgroundUrl(value) {
      return value.indexOf("url(") !== 0 ? value : value.replace(/^url\((["'])?([^"']+)\1\)$/, "$2");
    }
    function setAttributesOnTableElements(el) {
      if (!el.name) {
        return;
      }
      var elName = el.name.toUpperCase();
      var styleProps = Object.keys(juiceClient2.styleToAttribute);
      if (juiceClient2.tableElements.indexOf(elName) > -1) {
        for (var i in el.styleProps) {
          if (styleProps.indexOf(el.styleProps[i].prop) > -1) {
            var prop2 = juiceClient2.styleToAttribute[el.styleProps[i].prop];
            var value = el.styleProps[i].value;
            if (options2.preserveImportant) {
              value = removeImportant(value);
            }
            if (prop2 === "background") {
              value = extractBackgroundUrl(value);
            }
            if (/(linear|radial)-gradient\(/i.test(value)) {
              continue;
            }
            $(el).attr(prop2, value);
          }
        }
      }
    }
  }
  function removeImportant(value) {
    return value.replace(/\s*!important$/, "");
  }
  function findVariableValue(el, variable) {
    while (el) {
      if (variable in el.styleProps) {
        return el.styleProps[variable].value;
      }
      var el = el.pseudoElementParent || el.parent;
    }
  }
  function applyCounterStyle(counter, style2) {
    switch (style2) {
      case "lower-roman":
        return numbers.romanize(counter).toLowerCase();
      case "upper-roman":
        return numbers.romanize(counter);
      case "lower-latin":
      case "lower-alpha":
        return numbers.alphanumeric(counter).toLowerCase();
      case "upper-latin":
      case "upper-alpha":
        return numbers.alphanumeric(counter);
      default:
        return counter.toString();
    }
  }
  function parseContent(el) {
    var content = el.styleProps.content.value;
    if (content === "none" || content === "normal") {
      return "";
    }
    var imageUrlMatch = content.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);
    if (imageUrlMatch) {
      var url = imageUrlMatch[1].replace(/^['"]|['"]$/g, "");
      return { img: url };
    }
    var parsed = [];
    var tokens = content.split(/['"]/);
    for (var i = 0; i < tokens.length; i++) {
      if (tokens[i] === "")
        continue;
      var varMatch = tokens[i].match(/var\s*\(\s*(.*?)\s*(,\s*(.*?)\s*)?\s*\)/i);
      if (varMatch) {
        var variable = findVariableValue(el, varMatch[1]) || varMatch[2];
        parsed.push(variable.replace(/^['"]|['"]$/g, ""));
        continue;
      }
      var counterMatch = tokens[i].match(/counter\s*\(\s*(.*?)\s*(,\s*(.*?)\s*)?\s*\)/i);
      if (counterMatch && counterMatch[1] in el.counterProps) {
        var counter = el.counterProps[counterMatch[1]];
        parsed.push(applyCounterStyle(counter, counterMatch[3]));
        continue;
      }
      var attrMatch = tokens[i].match(/attr\s*\(\s*(.*?)\s*\)/i);
      if (attrMatch) {
        var attr2 = attrMatch[1];
        parsed.push(
          el.pseudoElementParent ? el.pseudoElementParent.attribs[attr2] : el.attribs[attr2]
        );
        continue;
      }
      parsed.push(tokens[i]);
    }
    content = parsed.join("");
    content = content.replace(/\\/g, "");
    return content;
  }
  function getPseudoElementType(selector2) {
    if (selector2.length === 0) {
      return;
    }
    var pseudos2 = selector2[selector2.length - 1].pseudos;
    if (!pseudos2) {
      return;
    }
    for (var i = 0; i < pseudos2.length; i++) {
      if (isPseudoElementName(pseudos2[i])) {
        return pseudos2[i].name;
      }
    }
  }
  function isPseudoElementName(pseudo2) {
    return pseudo2.name === "before" || pseudo2.name === "after";
  }
  function filterElementPseudos(pseudos2) {
    return pseudos2.filter(function(pseudo2) {
      return !isPseudoElementName(pseudo2);
    });
  }
  function juiceDocument2($, options2) {
    options2 = utils.getDefaultOptions(options2);
    var css2 = extractCssFromDocument($, options2);
    css2 += "\n" + options2.extraCss;
    inlineDocument($, css2, options2);
    return $;
  }
  function getStylesData($, options2) {
    var results = [];
    var stylesList = $("style");
    var styleDataList, styleData, styleElement;
    stylesList.each(function() {
      styleElement = this;
      var usingParse5 = !!styleElement.childNodes;
      styleDataList = usingParse5 ? styleElement.childNodes : styleElement.children;
      if (styleDataList.length !== 1) {
        if (options2.removeStyleTags) {
          $(styleElement).remove();
        }
        return;
      }
      styleData = styleDataList[0].data;
      if (options2.applyStyleTags && $(styleElement).attr("data-embed") === void 0) {
        results.push(styleData);
      }
      if (options2.removeStyleTags && $(styleElement).attr("data-embed") === void 0) {
        var text2 = usingParse5 ? styleElement.childNodes[0].nodeValue : styleElement.children[0].data;
        var preservedText = utils.getPreservedText(text2, {
          mediaQueries: options2.preserveMediaQueries,
          fontFaces: options2.preserveFontFaces,
          keyFrames: options2.preserveKeyFrames,
          pseudos: options2.preservePseudos
        }, juiceClient2.ignoredPseudos);
        if (preservedText) {
          if (usingParse5) {
            styleElement.childNodes[0].nodeValue = preservedText;
          } else {
            styleElement.children[0].data = preservedText;
          }
        } else {
          $(styleElement).remove();
        }
      }
      $(styleElement).removeAttr("data-embed");
    });
    return results;
  }
  function extractCssFromDocument($, options2) {
    var results = getStylesData($, options2);
    var css2 = results.join("\n");
    return css2;
  }
  return juiceClient2;
};
var cheerio = cheerioExports;
var makeJuiceClient2 = inline;
var juiceClient = makeJuiceClient2(function(html2, options2) {
  return cheerio(html2, { xmlMode: options2 && options2.xmlMode }, juiceDocument, [options2]);
});
var juiceDocument = function(html2, options2) {
  return juiceClient.juiceDocument(html2, options2);
};
juiceClient.inlineContent = function(html2, css2, options2) {
  return cheerio(html2, { xmlMode: options2 && options2.xmlMode }, juiceClient.inlineDocument, [css2, options2]);
};
juiceClient.codeBlocks = cheerio.codeBlocks;
var client = juiceClient;
const juice = /* @__PURE__ */ getDefaultExportFromCjs(client);
function ok$1() {
}
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property2, normal, space) {
    this.property = property2;
    this.normal = normal;
    if (space) {
      this.space = space;
    }
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions, space) {
  const property2 = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property2, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema(property2, normal, space);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property2, attribute2) {
    this.property = property2;
    this.attribute = attribute2;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property2, attribute2, mask, space) {
    let index2 = -1;
    super(property2, attribute2);
    mark(this, "space", space);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
const own$7 = {}.hasOwnProperty;
function create(definition) {
  const property2 = {};
  const normal = {};
  let prop2;
  for (prop2 in definition.properties) {
    if (own$7.call(definition.properties, prop2)) {
      const value = definition.properties[prop2];
      const info = new DefinedInfo(
        prop2,
        definition.transform(definition.attributes || {}, prop2),
        value,
        definition.space
      );
      if (definition.mustUseProperty && definition.mustUseProperty.includes(prop2)) {
        info.mustUseProperty = true;
      }
      property2[prop2] = info;
      normal[normalize$1(prop2)] = prop2;
      normal[normalize$1(info.attribute)] = prop2;
    }
  }
  return new Schema(property2, normal, definition.space);
}
const xlink = create({
  space: "xlink",
  transform(_, prop2) {
    return "xlink:" + prop2.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_, prop2) {
    return "xml:" + prop2.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes2, attribute2) {
  return attribute2 in attributes2 ? attributes2[attribute2] : attribute2;
}
function caseInsensitiveTransform(attributes2, property2) {
  return caseSensitiveTransform(attributes2, property2.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_, prop2) {
    return prop2 === "role" ? prop2 : "aria-" + prop2.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
const html$3 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop2 = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase$1);
      prop2 = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop2, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase$1($0) {
  return $0.charAt(1).toUpperCase();
}
const html$2 = merge([xml, xlink, xmlns, aria, html$3], "html");
const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function parse$2(value) {
  const tokens = [];
  const input = String(value || "");
  let index2 = input.indexOf(",");
  let start = 0;
  let end2 = false;
  while (!end2) {
    if (index2 === -1) {
      index2 = input.length;
      end2 = true;
    }
    const token2 = input.slice(start, index2).trim();
    if (token2 || !end2) {
      tokens.push(token2);
    }
    start = index2 + 1;
    index2 = input.indexOf(",", start);
  }
  return tokens;
}
function stringify$1(values, options2) {
  const settings = options2 || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const search$1 = /[#.]/g;
function parseSelector(selector2, defaultTagName) {
  const value = selector2 || "";
  const props = {};
  let start = 0;
  let previous;
  let tagName;
  while (start < value.length) {
    search$1.lastIndex = start;
    const match = search$1.exec(value);
    const subvalue = value.slice(start, match ? match.index : value.length);
    if (subvalue) {
      if (!previous) {
        tagName = subvalue;
      } else if (previous === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start += subvalue.length;
    }
    if (match) {
      previous = match[0];
      start++;
    }
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}
function parse$1(value) {
  const input = String(value || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify(values) {
  return values.join(" ").trim();
}
const buttonTypes = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]);
const own$6 = {}.hasOwnProperty;
function createH(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive && createAdjustMap(caseSensitive);
  function h2(selector2, properties, ...children) {
    let index2 = -1;
    let node2;
    if (selector2 === void 0 || selector2 === null) {
      node2 = { type: "root", children: [] };
      const child = (
        /** @type {Child} */
        properties
      );
      children.unshift(child);
    } else {
      node2 = parseSelector(selector2, defaultTagName);
      node2.tagName = node2.tagName.toLowerCase();
      if (adjust && own$6.call(adjust, node2.tagName)) {
        node2.tagName = adjust[node2.tagName];
      }
      if (isProperties(properties, node2.tagName)) {
        let key2;
        for (key2 in properties) {
          if (own$6.call(properties, key2)) {
            addProperty(schema, node2.properties, key2, properties[key2]);
          }
        }
      } else {
        children.unshift(properties);
      }
    }
    while (++index2 < children.length) {
      addChild(node2.children, children[index2]);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  }
  return h2;
}
function isProperties(value, name2) {
  if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }
  if (name2 === "input" || !value.type || typeof value.type !== "string") {
    return true;
  }
  if ("children" in value && Array.isArray(value.children)) {
    return false;
  }
  if (name2 === "button") {
    return buttonTypes.has(value.type.toLowerCase());
  }
  return !("value" in value);
}
function addProperty(schema, properties, key2, value) {
  const info = find(schema, key2);
  let index2 = -1;
  let result;
  if (value === void 0 || value === null)
    return;
  if (typeof value === "number") {
    if (Number.isNaN(value))
      return;
    result = value;
  } else if (typeof value === "boolean") {
    result = value;
  } else if (typeof value === "string") {
    if (info.spaceSeparated) {
      result = parse$1(value);
    } else if (info.commaSeparated) {
      result = parse$2(value);
    } else if (info.commaOrSpaceSeparated) {
      result = parse$1(parse$2(value).join(" "));
    } else {
      result = parsePrimitive(info, info.property, value);
    }
  } else if (Array.isArray(value)) {
    result = value.concat();
  } else {
    result = info.property === "style" ? style(value) : String(value);
  }
  if (Array.isArray(result)) {
    const finalResult = [];
    while (++index2 < result.length) {
      const value2 = (
        /** @type {number | string} */
        parsePrimitive(info, info.property, result[index2])
      );
      finalResult[index2] = value2;
    }
    result = finalResult;
  }
  if (info.property === "className" && Array.isArray(properties.className)) {
    const value2 = (
      /** @type {number | string} */
      result
    );
    result = properties.className.concat(value2);
  }
  properties[info.property] = result;
}
function addChild(nodes, value) {
  let index2 = -1;
  if (value === void 0 || value === null)
    ;
  else if (typeof value === "string" || typeof value === "number") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    while (++index2 < value.length) {
      addChild(nodes, value[index2]);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info, name2, value) {
  if (typeof value === "string") {
    if (info.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$1(value) === normalize$1(name2))) {
      return true;
    }
  }
  return value;
}
function style(value) {
  const result = [];
  let key2;
  for (key2 in value) {
    if (own$6.call(value, key2)) {
      result.push([key2, value[key2]].join(": "));
    }
  }
  return result.join("; ");
}
function createAdjustMap(values) {
  const result = {};
  let index2 = -1;
  while (++index2 < values.length) {
    result[values[index2].toLowerCase()] = values[index2];
  }
  return result;
}
const svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];
const h = createH(html$2, "div");
const s = createH(svg, "g", svgCaseSensitiveTagNames);
const search = /\r?\n|\r/g;
function location(file) {
  const value = String(file);
  const indices = [];
  search.lastIndex = 0;
  while (search.test(value)) {
    indices.push(search.lastIndex);
  }
  indices.push(value.length + 1);
  return { toPoint, toOffset };
  function toPoint(offset) {
    let index2 = -1;
    if (typeof offset === "number" && offset > -1 && offset < indices[indices.length - 1]) {
      while (++index2 < indices.length) {
        if (indices[index2] > offset) {
          return {
            line: index2 + 1,
            column: offset - (index2 > 0 ? indices[index2 - 1] : 0) + 1,
            offset
          };
        }
      }
    }
  }
  function toOffset(point2) {
    const line = point2 && point2.line;
    const column = point2 && point2.column;
    if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {
      const offset = (indices[line - 2] || 0) + column - 1 || 0;
      if (offset > -1 && offset < indices[indices.length - 1]) {
        return offset;
      }
    }
  }
}
const webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
const own$5 = {}.hasOwnProperty;
const proto = Object.prototype;
function fromParse5(tree, options2) {
  const settings = options2 || {};
  return one$3(
    {
      file: settings.file || void 0,
      location: false,
      schema: settings.space === "svg" ? svg : html$2,
      verbose: settings.verbose || false
    },
    tree
  );
}
function one$3(state, node2) {
  let result;
  switch (node2.nodeName) {
    case "#comment": {
      const reference = (
        /** @type {P5Comment} */
        node2
      );
      result = { type: "comment", value: reference.data };
      patch(state, reference, result);
      return result;
    }
    case "#document":
    case "#document-fragment": {
      const reference = (
        /** @type {P5Document | P5DocumentFragment} */
        node2
      );
      const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
      result = {
        type: "root",
        children: all$3(state, node2.childNodes),
        data: { quirksMode }
      };
      if (state.file && state.location) {
        const doc = String(state.file);
        const loc = location(doc);
        const start = loc.toPoint(0);
        const end2 = loc.toPoint(doc.length);
        result.position = { start, end: end2 };
      }
      return result;
    }
    case "#documentType": {
      const reference = (
        /** @type {P5DocumentType} */
        node2
      );
      result = { type: "doctype" };
      patch(state, reference, result);
      return result;
    }
    case "#text": {
      const reference = (
        /** @type {P5Text} */
        node2
      );
      result = { type: "text", value: reference.value };
      patch(state, reference, result);
      return result;
    }
    default: {
      const reference = (
        /** @type {P5Element} */
        node2
      );
      result = element$1(state, reference);
      return result;
    }
  }
}
function all$3(state, nodes) {
  let index2 = -1;
  const results = [];
  while (++index2 < nodes.length) {
    const result = (
      /** @type {RootContent} */
      one$3(state, nodes[index2])
    );
    results.push(result);
  }
  return results;
}
function element$1(state, node2) {
  const schema = state.schema;
  state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$2;
  let index2 = -1;
  const props = {};
  while (++index2 < node2.attrs.length) {
    const attribute2 = node2.attrs[index2];
    const name2 = (attribute2.prefix ? attribute2.prefix + ":" : "") + attribute2.name;
    if (!own$5.call(proto, name2)) {
      props[name2] = attribute2.value;
    }
  }
  const fn = state.schema.space === "svg" ? s : h;
  const result = fn(node2.tagName, props, all$3(state, node2.childNodes));
  patch(state, node2, result);
  if (result.tagName === "template") {
    const reference = (
      /** @type {P5Template} */
      node2
    );
    const pos = reference.sourceCodeLocation;
    const startTag = pos && pos.startTag && position$1(pos.startTag);
    const endTag = pos && pos.endTag && position$1(pos.endTag);
    const content = (
      /** @type {Root} */
      one$3(state, reference.content)
    );
    if (startTag && endTag && state.file) {
      content.position = { start: startTag.end, end: endTag.start };
    }
    result.content = content;
  }
  state.schema = schema;
  return result;
}
function patch(state, from, to) {
  if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
    const position2 = createLocation(state, to, from.sourceCodeLocation);
    if (position2) {
      state.location = true;
      to.position = position2;
    }
  }
}
function createLocation(state, node2, location2) {
  const result = position$1(location2);
  if (node2.type === "element") {
    const tail = node2.children[node2.children.length - 1];
    if (result && !location2.endTag && tail && tail.position && tail.position.end) {
      result.end = Object.assign({}, tail.position.end);
    }
    if (state.verbose) {
      const props = {};
      let key2;
      if (location2.attrs) {
        for (key2 in location2.attrs) {
          if (own$5.call(location2.attrs, key2)) {
            props[find(state.schema, key2).property] = position$1(
              location2.attrs[key2]
            );
          }
        }
      }
      ok$1(location2.startTag);
      const opening2 = position$1(location2.startTag);
      const closing2 = location2.endTag ? position$1(location2.endTag) : void 0;
      const data2 = { opening: opening2 };
      if (closing2)
        data2.closing = closing2;
      data2.properties = props;
      node2.data = { position: data2 };
    }
  }
  return result;
}
function position$1(loc) {
  const start = point$1({
    line: loc.startLine,
    column: loc.startCol,
    offset: loc.startOffset
  });
  const end2 = point$1({
    line: loc.endLine,
    column: loc.endCol,
    offset: loc.endOffset
  });
  return start || end2 ? { start, end: end2 } : void 0;
}
function point$1(point2) {
  return point2.line && point2.column ? point2 : void 0;
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options2 = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options2 = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options2 = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options2 = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options2 = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options2.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options2.cause = causeOrReason;
    }
    if (!options2.ruleId && !options2.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options2.ruleId = origin;
      } else {
        options2.source = origin.slice(0, index2);
        options2.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options2.place && options2.ancestors && options2.ancestors) {
      const parent = options2.ancestors[options2.ancestors.length - 1];
      if (parent) {
        options2.place = parent.position;
      }
    }
    const start = options2.place && "start" in options2.place ? options2.place.start : options2.place;
    this.ancestors = options2.ancestors || void 0;
    this.cause = options2.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options2.place) || "1:1";
    this.place = options2.place || void 0;
    this.reason = this.message;
    this.ruleId = options2.ruleId || void 0;
    this.source = options2.source || void 0;
    this.stack = legacyCause && options2.cause && typeof options2.cause.stack === "string" ? options2.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end2 = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end2 < 0) {
        seenNonSlash = true;
        end2 = index2 + 1;
      }
    }
    return end2 < 0 ? "" : path2.slice(start, end2);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
          if (extIndex < 0) {
            end2 = index2;
          }
        } else {
          extIndex = -1;
          end2 = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end2) {
    end2 = firstNonSlashEnd;
  } else if (end2 < 0) {
    end2 = path2.length;
  }
  return path2.slice(start, end2);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end2 = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end2 = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end2 = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end2 < 0) {
      unmatchedSlash = true;
      end2 = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end2);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath$1(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options2;
    if (!value) {
      options2 = {};
    } else if (isUrl(value)) {
      options2 = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options2 = { value };
    } else {
      options2 = value;
    }
    this.cwd = proc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop3 = order[index2];
      if (prop3 in options2 && options2[prop3] !== void 0 && options2[prop3] !== null) {
        this[prop3] = prop3 === "history" ? [...options2[prop3]] : options2[prop3];
      }
    }
    let prop2;
    for (prop2 in options2) {
      if (!order.includes(prop2)) {
        this[prop2] = options2[prop2];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const errors = {
  /** @type {ErrorInfo} */
  abandonedHeadElementChild: {
    reason: "Unexpected metadata element after head",
    description: "Unexpected element after head. Expected the element before `</head>`",
    url: false
  },
  /** @type {ErrorInfo} */
  abruptClosingOfEmptyComment: {
    reason: "Unexpected abruptly closed empty comment",
    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
  },
  /** @type {ErrorInfo} */
  abruptDoctypePublicIdentifier: {
    reason: "Unexpected abruptly closed public identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
  },
  /** @type {ErrorInfo} */
  abruptDoctypeSystemIdentifier: {
    reason: "Unexpected abruptly closed system identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
  },
  /** @type {ErrorInfo} */
  absenceOfDigitsInNumericCharacterReference: {
    reason: "Unexpected non-digit at start of numeric character reference",
    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
  },
  /** @type {ErrorInfo} */
  cdataInHtmlContent: {
    reason: "Unexpected CDATA section in HTML",
    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
  },
  /** @type {ErrorInfo} */
  characterReferenceOutsideUnicodeRange: {
    reason: "Unexpected too big numeric character reference",
    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
  },
  /** @type {ErrorInfo} */
  closingOfElementWithOpenChildElements: {
    reason: "Unexpected closing tag with open child elements",
    description: "Unexpectedly closing tag. Expected other tags to be closed first",
    url: false
  },
  /** @type {ErrorInfo} */
  controlCharacterInInputStream: {
    reason: "Unexpected control character",
    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  controlCharacterReference: {
    reason: "Unexpected control character reference",
    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  disallowedContentInNoscriptInHead: {
    reason: "Disallowed content inside `<noscript>` in `<head>`",
    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
    url: false
  },
  /** @type {ErrorInfo} */
  duplicateAttribute: {
    reason: "Unexpected duplicate attribute",
    description: "Unexpectedly double attribute. Expected attributes to occur only once"
  },
  /** @type {ErrorInfo} */
  endTagWithAttributes: {
    reason: "Unexpected attribute on closing tag",
    description: "Unexpected attribute. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithTrailingSolidus: {
    reason: "Unexpected slash at end of closing tag",
    description: "Unexpected `%c-1`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithoutMatchingOpenElement: {
    reason: "Unexpected unopened end tag",
    description: "Unexpected end tag. Expected no end tag or another end tag",
    url: false
  },
  /** @type {ErrorInfo} */
  eofBeforeTagName: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected tag name instead"
  },
  /** @type {ErrorInfo} */
  eofInCdata: {
    reason: "Unexpected end of file in CDATA",
    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
  },
  /** @type {ErrorInfo} */
  eofInComment: {
    reason: "Unexpected end of file in comment",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInDoctype: {
    reason: "Unexpected end of file in doctype",
    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
  },
  /** @type {ErrorInfo} */
  eofInElementThatCanContainOnlyText: {
    reason: "Unexpected end of file in element that can only contain text",
    description: "Unexpected end of file. Expected text or a closing tag",
    url: false
  },
  /** @type {ErrorInfo} */
  eofInScriptHtmlCommentLikeText: {
    reason: "Unexpected end of file in comment inside script",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInTag: {
    reason: "Unexpected end of file in tag",
    description: "Unexpected end of file. Expected `>` to close the tag"
  },
  /** @type {ErrorInfo} */
  incorrectlyClosedComment: {
    reason: "Incorrectly closed comment",
    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  incorrectlyOpenedComment: {
    reason: "Incorrectly opened comment",
    description: "Unexpected `%c`. Expected `<!--` to open the comment"
  },
  /** @type {ErrorInfo} */
  invalidCharacterSequenceAfterDoctypeName: {
    reason: "Invalid sequence after doctype name",
    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
  },
  /** @type {ErrorInfo} */
  invalidFirstCharacterOfTagName: {
    reason: "Invalid first character in tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  misplacedDoctype: {
    reason: "Misplaced doctype",
    description: "Unexpected doctype. Expected doctype before head",
    url: false
  },
  /** @type {ErrorInfo} */
  misplacedStartTagForHeadElement: {
    reason: "Misplaced `<head>` start tag",
    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
    url: false
  },
  /** @type {ErrorInfo} */
  missingAttributeValue: {
    reason: "Missing attribute value",
    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctype: {
    reason: "Missing doctype before other content",
    description: "Expected a `<!doctype html>` before anything else",
    url: false
  },
  /** @type {ErrorInfo} */
  missingDoctypeName: {
    reason: "Missing doctype name",
    description: "Unexpected doctype end at `%c`. Expected `html` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypePublicIdentifier: {
    reason: "Missing public identifier in doctype",
    description: "Unexpected `%c`. Expected identifier for `public` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypeSystemIdentifier: {
    reason: "Missing system identifier in doctype",
    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
  },
  /** @type {ErrorInfo} */
  missingEndTagName: {
    reason: "Missing name in end tag",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: "Missing quote before public identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: "Missing quote before system identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingSemicolonAfterCharacterReference: {
    reason: "Missing semicolon after character reference",
    description: "Unexpected `%c`. Expected `;` instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: "Missing whitespace after public identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: "Missing whitespace after system identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBeforeDoctypeName: {
    reason: "Missing whitespace before doctype name",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenAttributes: {
    reason: "Missing whitespace between attributes",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: "Missing whitespace between public and system identifiers in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  nestedComment: {
    reason: "Unexpected nested comment",
    description: "Unexpected `<!--`. Expected `-->`"
  },
  /** @type {ErrorInfo} */
  nestedNoscriptInHead: {
    reason: "Unexpected nested `<noscript>` in `<head>`",
    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
    url: false
  },
  /** @type {ErrorInfo} */
  nonConformingDoctype: {
    reason: "Unexpected non-conforming doctype declaration",
    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
    url: false
  },
  /** @type {ErrorInfo} */
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: "Unexpected trailing slash on start tag of non-void element",
    description: "Unexpected `/`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  noncharacterCharacterReference: {
    reason: "Unexpected noncharacter code point referenced by character reference",
    description: "Unexpected code point. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  noncharacterInInputStream: {
    reason: "Unexpected noncharacter character",
    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  nullCharacterReference: {
    reason: "Unexpected NULL character referenced by character reference",
    description: "Unexpected code point. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  openElementsLeftAfterEof: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected closing tag instead",
    url: false
  },
  /** @type {ErrorInfo} */
  surrogateCharacterReference: {
    reason: "Unexpected surrogate character referenced by character reference",
    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  surrogateInInputStream: {
    reason: "Unexpected surrogate character",
    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: "Invalid character after system identifier in doctype",
    description: "Unexpected character at `%c`. Expected `>`"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInAttributeName: {
    reason: "Unexpected character in attribute name",
    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: "Unexpected character in unquoted attribute value",
    description: "Unexpected `%c`. Quote the attribute value to include it"
  },
  /** @type {ErrorInfo} */
  unexpectedEqualsSignBeforeAttributeName: {
    reason: "Unexpected equals sign before attribute name",
    description: "Unexpected `%c`. Add an attribute name before it"
  },
  /** @type {ErrorInfo} */
  unexpectedNullCharacter: {
    reason: "Unexpected NULL character",
    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: "Unexpected question mark instead of tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  unexpectedSolidusInTag: {
    reason: "Unexpected slash in tag",
    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
  },
  /** @type {ErrorInfo} */
  unknownNamedCharacterReference: {
    reason: "Unexpected unknown named character reference",
    description: "Unexpected character reference. Expected known named character references"
  }
};
const base = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-";
const dashToCamelRe = /-[a-z]/g;
const formatCRe = /%c(?:([-+])(\d+))?/g;
const formatXRe = /%x/g;
const fatalities = { 2: true, 1: false, 0: null };
const emptyOptions$1 = {};
function fromHtml(value, options2) {
  const settings = options2 || emptyOptions$1;
  const onerror = settings.onerror;
  const file = value instanceof VFile ? value : new VFile(value);
  const fn = settings.fragment ? cjs$1.parseFragment : cjs$1.parse;
  const doc = String(file);
  const p5doc = fn(doc, {
    sourceCodeLocationInfo: true,
    // Note `parse5` types currently do not allow `undefined`.
    onParseError: settings.onerror ? internalOnerror : null,
    scriptingEnabled: false
  });
  return (
    /** @type {Root} */
    fromParse5(p5doc, {
      file,
      space: settings.space,
      verbose: settings.verbose
    })
  );
  function internalOnerror(error) {
    const code2 = error.code;
    const name2 = camelcase(code2);
    const setting = settings[name2];
    const config = setting === null || setting === void 0 ? true : setting;
    const level = typeof config === "number" ? config : config ? 1 : 0;
    if (level) {
      const info = errors[name2];
      const message = new VFileMessage(format(info.reason), {
        place: {
          start: {
            line: error.startLine,
            column: error.startCol,
            offset: error.startOffset
          },
          end: {
            line: error.endLine,
            column: error.endCol,
            offset: error.endOffset
          }
        },
        ruleId: code2,
        source: "hast-util-from-html"
      });
      if (file.path) {
        message.file = file.path;
        message.name = file.path + ":" + message.name;
      }
      message.fatal = fatalities[level];
      message.note = format(info.description);
      message.url = info.url === false ? void 0 : base + code2;
      onerror(message);
    }
    function format(value2) {
      return value2.replace(formatCRe, formatC).replace(formatXRe, formatX);
      function formatC(_, $1, $2) {
        const offset = ($2 ? Number.parseInt($2, 10) : 0) * ($1 === "-" ? -1 : 1);
        const char = doc.charAt(error.startOffset + offset);
        return visualizeCharacter(char);
      }
      function formatX() {
        return visualizeCharacterCode(doc.charCodeAt(error.startOffset));
      }
    }
  }
}
function camelcase(value) {
  return (
    /** @type {ErrorCode} */
    value.replace(dashToCamelRe, dashToCamel)
  );
}
function dashToCamel($0) {
  return $0.charAt(1).toUpperCase();
}
function visualizeCharacter(char) {
  return char === "`" ? "` ` `" : char;
}
function visualizeCharacterCode(charCode) {
  return "0x" + charCode.toString(16).toUpperCase();
}
function rehypeParse(options2) {
  const self2 = this;
  const { emitParseErrors, ...settings } = { ...self2.data("settings"), ...options2 };
  self2.parser = parser2;
  function parser2(doc, file) {
    return fromHtml(doc, {
      ...settings,
      onerror: emitParseErrors ? function(message) {
        if (file.path) {
          message.name = file.path + ":" + message.name;
          message.file = file.path;
        }
        file.messages.push(message);
      } : void 0
    });
  }
}
const htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
const own$4 = {}.hasOwnProperty;
function zwitch(key2, options2) {
  const settings = options2 || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own$4.call(value, key2)) {
      const id2 = String(value[key2]);
      fn = own$4.call(handlers, id2) ? handlers[id2] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function core(value, options2) {
  value = value.replace(
    options2.subset ? charactersToExpression(options2.subset) : /["&'<>`]/g,
    basic
  );
  if (options2.subset || options2.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index2, all2) {
    return options2.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index2 + 2),
      options2
    );
  }
  function basic(character, index2, all2) {
    return options2.format(
      character.charCodeAt(0),
      all2.charCodeAt(index2 + 1),
      options2
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function toHexadecimal(code2, next, omit) {
  const value = "&#x" + code2.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
}
function toDecimal(code2, next, omit) {
  const value = "&#" + String(code2);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
}
const characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
const characterEntitiesHtml4 = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
};
const dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
const own$3 = {}.hasOwnProperty;
const characters = {};
let key;
for (key in characterEntitiesHtml4) {
  if (own$3.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
function toNamed(code2, next, omit, attribute2) {
  const character = String.fromCharCode(code2);
  if (own$3.call(characters, character)) {
    const name2 = characters[character];
    const value = "&" + name2;
    if (omit && characterEntitiesLegacy.includes(name2) && !dangerous.includes(name2) && (!attribute2 || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}
function formatSmart(code2, next, options2) {
  let numeric = toHexadecimal(code2, next, options2.omitOptionalSemicolons);
  let named;
  if (options2.useNamedReferences || options2.useShortestReferences) {
    named = toNamed(
      code2,
      next,
      options2.omitOptionalSemicolons,
      options2.attribute
    );
  }
  if ((options2.useShortestReferences || !named) && options2.useShortestReferences) {
    const decimal = toDecimal(code2, next, options2.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options2.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
function stringifyEntities(value, options2) {
  return core(value, Object.assign({ format: formatSmart }, options2));
}
function comment(node2, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + node2.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode2) + "-->";
  function encode2($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count2++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count2;
}
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty$3(thing.value) : false : empty$3(thing);
}
function empty$3(value) {
  return value.replace(re, "") === "";
}
const siblingAfter = siblings(1);
const siblingBefore = siblings(-1);
const emptyChildren$1 = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren$1;
    let offset = (index2 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}
const own$2 = {}.hasOwnProperty;
function omission(handlers) {
  return omit;
  function omit(node2, index2, parent) {
    return own$2.call(handlers, node2.tagName) && handlers[node2.tagName](node2, index2, parent);
  }
}
const closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html$1,
  li,
  optgroup,
  option,
  p,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_, index2, parent) {
  const next = siblingAfter(parent, index2, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html$1(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function body$1(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function p(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody$1(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_, index2, parent) {
  return !siblingAfter(parent, index2);
}
function tr(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}
const opening = omission({
  body,
  colgroup,
  head,
  html,
  tbody
});
function html(node2) {
  const head2 = siblingAfter(node2, -1);
  return !head2 || head2.type !== "comment";
}
function head(node2) {
  const children = node2.children;
  const seen = [];
  let index2 = -1;
  while (++index2 < children.length) {
    const child = children[index2];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName))
        return false;
      seen.push(child.tagName);
    }
  }
  return children.length > 0;
}
function body(node2) {
  const head2 = siblingAfter(node2, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node2, index2, parent) {
  const previous = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1, true);
  if (parent && previous && previous.type === "element" && previous.tagName === "colgroup" && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody(node2, index2, parent) {
  const previous = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1);
  if (parent && previous && previous.type === "element" && (previous.tagName === "thead" || previous.tagName === "tbody") && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}
const constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node2, index2, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last2;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg;
  }
  const attrs = serializeAttributes(state, node2.properties);
  const content = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content)
    selfClosing = false;
  if (attrs || !omit || !opening(node2, index2, parent)) {
    parts.push("<", node2.tagName, attrs ? " " + attrs : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last2 = attrs.charAt(attrs.length - 1);
      if (!state.settings.tightSelfClosing || last2 === "/" || last2 && last2 !== '"' && last2 !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content);
  if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, props) {
  const values = [];
  let index2 = -1;
  let key2;
  if (props) {
    for (key2 in props) {
      if (props[key2] !== null && props[key2] !== void 0) {
        const value = serializeAttribute(state, key2, props[key2]);
        if (value)
          values.push(value);
      }
    }
  }
  while (++index2 < values.length) {
    const last2 = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : void 0;
    if (index2 !== values.length - 1 && last2 !== '"' && last2 !== "'") {
      values[index2] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute(state, key2, value) {
  const info = find(state.schema, key2);
  const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y2 = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if (info.boolean || info.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name2 = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x][y2]
    })
  );
  if (value === true)
    return name2;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify$1 : stringify)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value)
    return name2;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x][y2]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x][y2],
        attribute: true
      })
    ) + quote;
  }
  return name2 + (result ? "=" + result : result);
}
function text(node2, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function raw(node2, index2, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text(node2, index2, parent, state);
}
function root$1(node2, _1, _2, state) {
  return state.all(node2);
}
const handle$1 = zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element, raw, root: root$1, text }
});
function invalid(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}
const emptyOptions = {};
const emptyCharacterReferences = {};
const emptyChildren = [];
function toHtml(tree, options2) {
  const options_ = options2 || emptyOptions;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one: one$2,
    all: all$2,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg : html$2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one$2(node2, index2, parent) {
  return handle$1(node2, index2, parent, this);
}
function all$2(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren;
  let index2 = -1;
  while (++index2 < children.length) {
    results[index2] = this.one(children[index2], index2, parent);
  }
  return results.join("");
}
function rehypeStringify(options2) {
  const self2 = this;
  const settings = { ...self2.data("settings"), ...options2 };
  self2.compiler = compiler;
  function compiler(tree) {
    return toHtml(tree, settings);
  }
}
function bail(error) {
  if (error) {
    throw error;
  }
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn.call(obj, key2);
};
var setProperty = function setProperty2(target, options2) {
  if (defineProperty && options2.name === "__proto__") {
    defineProperty(target, options2.name, {
      enumerable: true,
      configurable: true,
      value: options2.newValue,
      writable: true
    });
  } else {
    target[options2.name] = options2.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend = function extend2() {
  var options2, name2, src, copy, copyIsArray, clone2;
  var target = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length; ++i) {
    options2 = arguments[i];
    if (options2 != null) {
      for (name2 in options2) {
        src = getProperty(target, name2);
        copy = getProperty(options2, name2);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && isArray(src) ? src : [];
            } else {
              clone2 = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend2(deep, clone2, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty(target, { name: name2, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property2) {
    const self2 = this;
    const constr = self2.constructor;
    const proto2 = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const func = proto2[property2];
    const apply = function() {
      return func.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto2);
    const names = Object.getOwnPropertyNames(func);
    for (const p2 of names) {
      const descriptor = Object.getOwnPropertyDescriptor(func, p2);
      if (descriptor)
        Object.defineProperty(apply, p2, descriptor);
    }
    return apply;
  }
);
const own$1 = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$1(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own$1.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options2] = this.attachers[this.freezeIndex];
      if (options2[0] === false) {
        continue;
      }
      if (options2[0] === true) {
        options2[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options2);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser2 = this.parser || this.Parser;
    assertParser("parse", parser2);
    return parser2(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler);
    assertNode(tree);
    return compiler(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add2(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$1(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add2(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = extend$1(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const rehype = unified().use(rehypeParse).use(rehypeStringify).freeze();
const convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test2) {
    if (test2 === null || test2 === void 0) {
      return ok;
    }
    if (typeof test2 === "function") {
      return castFactory(test2);
    }
    if (typeof test2 === "object") {
      return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
    }
    if (typeof test2 === "string") {
      return typeFactory(test2);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color(d) {
  return d;
}
const empty$2 = [];
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
function visitParents(tree, test2, visitor, reverse) {
  let check;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
  } else {
    check = test2;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory2(tree, void 0, [])();
  function factory2(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty$2;
      let subresult;
      let offset;
      let grandparents;
      if (!test2 || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory2(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty$2 : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test2;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test2 = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test2 = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test2, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const emptyMulticharIndex = {};
const emptyRegularIndex = {};
function extendIndex(item, index2) {
  let currentIndex = index2;
  for (let pos = 0; pos < item.length; pos++) {
    const isLast = pos === item.length - 1;
    const char = item.charAt(pos);
    const charIndex = currentIndex[char] || (currentIndex[char] = { chars: {} });
    if (isLast) {
      charIndex.self = item;
    }
    currentIndex = charIndex.chars;
  }
}
function createMulticharIndex(items) {
  if (items.length === 0) {
    return emptyMulticharIndex;
  }
  const index2 = {};
  for (const item of items) {
    extendIndex(item, index2);
  }
  return index2;
}
function createRegularIndex(items) {
  if (items.length === 0) {
    return emptyRegularIndex;
  }
  const result = {};
  for (const item of items) {
    result[item] = true;
  }
  return result;
}
const emptyPseudoClassSignatures = {};
const defaultPseudoClassSignature = {
  type: "String",
  optional: true
};
function calculatePseudoClassSignature(types2) {
  const result = {
    optional: false
  };
  function setResultType(type) {
    if (result.type && result.type !== type) {
      throw new Error(`Conflicting pseudo-class argument type: "${result.type}" vs "${type}".`);
    }
    result.type = type;
  }
  for (const type of types2) {
    if (type === "NoArgument") {
      result.optional = true;
    }
    if (type === "Formula") {
      setResultType("Formula");
    }
    if (type === "FormulaOfSelector") {
      setResultType("Formula");
      result.ofSelector = true;
    }
    if (type === "String") {
      setResultType("String");
    }
    if (type === "Selector") {
      setResultType("Selector");
    }
  }
  return result;
}
function inverseCategories(obj) {
  const result = {};
  for (const category of Object.keys(obj)) {
    const items = obj[category];
    if (items) {
      for (const item of items) {
        (result[item] || (result[item] = [])).push(category);
      }
    }
  }
  return result;
}
function calculatePseudoClassSignatures(definitions) {
  const pseudoClassesToArgumentTypes = inverseCategories(definitions);
  const result = {};
  for (const pseudoClass of Object.keys(pseudoClassesToArgumentTypes)) {
    const argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];
    if (argumentTypes) {
      result[pseudoClass] = calculatePseudoClassSignature(argumentTypes);
    }
  }
  return result;
}
const emptyXmlOptions = {};
const defaultXmlOptions = { wildcard: true };
function getXmlOptions(param) {
  if (param) {
    if (typeof param === "boolean") {
      return defaultXmlOptions;
    } else {
      return param;
    }
  } else {
    return emptyXmlOptions;
  }
}
function extendSyntaxDefinition(base2, extension) {
  const result = { ...base2 };
  if ("tag" in extension) {
    if (extension.tag) {
      result.tag = { ...getXmlOptions(base2.tag) };
      const extensionOptions = getXmlOptions(extension.tag);
      if ("wildcard" in extensionOptions) {
        result.tag.wildcard = extensionOptions.wildcard;
      }
    } else {
      result.tag = void 0;
    }
  }
  if ("ids" in extension) {
    result.ids = extension.ids;
  }
  if ("classNames" in extension) {
    result.classNames = extension.classNames;
  }
  if ("namespace" in extension) {
    if (extension.namespace) {
      result.namespace = { ...getXmlOptions(base2.namespace) };
      const extensionOptions = getXmlOptions(extension.namespace);
      if ("wildcard" in extensionOptions) {
        result.namespace.wildcard = extensionOptions.wildcard;
      }
    } else {
      result.namespace = void 0;
    }
  }
  if ("combinators" in extension) {
    if (extension.combinators) {
      result.combinators = result.combinators ? result.combinators.concat(extension.combinators) : extension.combinators;
    } else {
      result.combinators = void 0;
    }
  }
  if ("attributes" in extension) {
    if (extension.attributes) {
      result.attributes = { ...base2.attributes };
      if ("unknownCaseSensitivityModifiers" in extension.attributes) {
        result.attributes.unknownCaseSensitivityModifiers = extension.attributes.unknownCaseSensitivityModifiers;
      }
      if ("operators" in extension.attributes) {
        result.attributes.operators = extension.attributes.operators ? result.attributes.operators ? result.attributes.operators.concat(extension.attributes.operators) : extension.attributes.operators : void 0;
      }
      if ("caseSensitivityModifiers" in extension.attributes) {
        result.attributes.caseSensitivityModifiers = extension.attributes.caseSensitivityModifiers ? result.attributes.caseSensitivityModifiers ? result.attributes.caseSensitivityModifiers.concat(extension.attributes.caseSensitivityModifiers) : extension.attributes.caseSensitivityModifiers : void 0;
      }
    } else {
      result.attributes = void 0;
    }
  }
  if ("pseudoElements" in extension) {
    if (extension.pseudoElements) {
      result.pseudoElements = { ...base2.pseudoElements };
      if ("unknown" in extension.pseudoElements) {
        result.pseudoElements.unknown = extension.pseudoElements.unknown;
      }
      if ("notation" in extension.pseudoElements) {
        result.pseudoElements.notation = extension.pseudoElements.notation;
      }
      if ("definitions" in extension.pseudoElements) {
        result.pseudoElements.definitions = extension.pseudoElements.definitions ? result.pseudoElements.definitions ? result.pseudoElements.definitions.concat(extension.pseudoElements.definitions) : extension.pseudoElements.definitions : void 0;
      }
    } else {
      result.pseudoElements = void 0;
    }
  }
  if ("pseudoClasses" in extension) {
    if (extension.pseudoClasses) {
      result.pseudoClasses = { ...base2.pseudoClasses };
      if ("unknown" in extension.pseudoClasses) {
        result.pseudoClasses.unknown = extension.pseudoClasses.unknown;
      }
      if ("definitions" in extension.pseudoClasses) {
        const newDefinitions = extension.pseudoClasses.definitions;
        if (newDefinitions) {
          result.pseudoClasses.definitions = {
            ...result.pseudoClasses.definitions
          };
          const existingDefinitions = result.pseudoClasses.definitions;
          for (const key2 of Object.keys(newDefinitions)) {
            const newDefinitionForNotation = newDefinitions[key2];
            const existingDefinitionForNotation = existingDefinitions[key2];
            if (newDefinitionForNotation) {
              existingDefinitions[key2] = existingDefinitionForNotation ? existingDefinitionForNotation.concat(newDefinitionForNotation) : newDefinitionForNotation;
            } else {
              existingDefinitions[key2] = void 0;
            }
          }
        } else {
          result.pseudoClasses.definitions = void 0;
        }
      }
    } else {
      result.pseudoClasses = void 0;
    }
  }
  return result;
}
const css1SyntaxDefinition = {
  tag: {},
  ids: true,
  classNames: true,
  combinators: [],
  pseudoElements: {
    unknown: "reject",
    notation: "singleColon",
    definitions: ["first-letter", "first-line"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["link", "visited", "active"]
    }
  }
};
const css2SyntaxDefinition = extendSyntaxDefinition(css1SyntaxDefinition, {
  tag: { wildcard: true },
  combinators: [">", "+"],
  attributes: {
    unknownCaseSensitivityModifiers: "reject",
    operators: ["=", "~=", "|="]
  },
  pseudoElements: {
    definitions: ["before", "after"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["hover", "focus", "first-child"],
      String: ["lang"]
    }
  }
});
const selectors3SyntaxDefinition = extendSyntaxDefinition(css2SyntaxDefinition, {
  namespace: {
    wildcard: true
  },
  combinators: ["~"],
  attributes: {
    operators: ["^=", "$=", "*="]
  },
  pseudoElements: {
    notation: "both"
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "root",
        "last-child",
        "first-of-type",
        "last-of-type",
        "only-child",
        "only-of-type",
        "empty",
        "target",
        "enabled",
        "disabled",
        "checked",
        "indeterminate"
      ],
      Formula: ["nth-child", "nth-last-child", "nth-of-type", "nth-last-of-type"],
      Selector: ["not"]
    }
  }
});
const selectors4SyntaxDefinition = extendSyntaxDefinition(selectors3SyntaxDefinition, {
  combinators: ["||"],
  attributes: {
    caseSensitivityModifiers: ["i", "I", "s", "S"]
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "any-link",
        "local-link",
        "target-within",
        "scope",
        "current",
        "past",
        "future",
        "focus-within",
        "focus-visible",
        "read-write",
        "read-only",
        "placeholder-shown",
        "default",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "required",
        "optional",
        "blank",
        "user-invalid"
      ],
      Formula: ["nth-col", "nth-last-col"],
      String: ["dir"],
      FormulaOfSelector: ["nth-child", "nth-last-child"],
      Selector: ["current", "is", "where", "has"]
    }
  }
});
const progressiveSyntaxDefinition = extendSyntaxDefinition(selectors4SyntaxDefinition, {
  pseudoElements: {
    unknown: "accept"
  },
  pseudoClasses: {
    unknown: "accept"
  },
  attributes: {
    unknownCaseSensitivityModifiers: "accept"
  }
});
const cssSyntaxDefinitions = {
  css1: css1SyntaxDefinition,
  css2: css2SyntaxDefinition,
  css3: selectors3SyntaxDefinition,
  "selectors-3": selectors3SyntaxDefinition,
  "selectors-4": selectors4SyntaxDefinition,
  latest: selectors4SyntaxDefinition,
  progressive: progressiveSyntaxDefinition
};
function isIdentStart(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-" || c === "_";
}
function isIdent(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "-" || c === "_";
}
function isHex(c) {
  return c >= "a" && c <= "f" || c >= "A" && c <= "F" || c >= "0" && c <= "9";
}
const stringEscapeChars = {
  n: "\n",
  r: "\r",
  t: "	",
  f: "\f",
  "\\": "\\"
};
const whitespaceChars = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true,
  "\f": true
};
const quoteChars = {
  '"': true,
  "'": true
};
const digitsChars = {
  0: true,
  1: true,
  2: true,
  3: true,
  4: true,
  5: true,
  6: true,
  7: true,
  8: true,
  9: true
};
const errorPrefix = `css-selector-parser parse error: `;
function createParser(options2 = {}) {
  const { syntax = "latest", substitutes, strict = true } = options2;
  let syntaxDefinition = typeof syntax === "string" ? cssSyntaxDefinitions[syntax] : syntax;
  if (syntaxDefinition.baseSyntax) {
    syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);
  }
  const [tagNameEnabled, tagNameWildcardEnabled] = syntaxDefinition.tag ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)] : [false, false];
  const idEnabled = Boolean(syntaxDefinition.ids);
  const classNamesEnabled = Boolean(syntaxDefinition.classNames);
  const namespaceEnabled = Boolean(syntaxDefinition.namespace);
  const namespaceWildcardEnabled = syntaxDefinition.namespace && (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);
  if (namespaceEnabled && !tagNameEnabled) {
    throw new Error(`${errorPrefix}Namespaces cannot be enabled while tags are disabled.`);
  }
  const substitutesEnabled = Boolean(substitutes);
  const combinatorsIndex = syntaxDefinition.combinators ? createMulticharIndex(syntaxDefinition.combinators) : emptyMulticharIndex;
  const [attributesEnabled, attributesOperatorsIndex, attributesCaseSensitivityModifiers, attributesAcceptUnknownCaseSensitivityModifiers] = syntaxDefinition.attributes ? [
    true,
    syntaxDefinition.attributes.operators ? createMulticharIndex(syntaxDefinition.attributes.operators) : emptyMulticharIndex,
    syntaxDefinition.attributes.caseSensitivityModifiers ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers) : emptyRegularIndex,
    syntaxDefinition.attributes.unknownCaseSensitivityModifiers === "accept"
  ] : [false, emptyMulticharIndex, emptyRegularIndex, false];
  const attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;
  const [pseudoClassesEnabled, paeudoClassesDefinitions, pseudoClassesAcceptUnknown] = syntaxDefinition.pseudoClasses ? [
    true,
    syntaxDefinition.pseudoClasses.definitions ? calculatePseudoClassSignatures(syntaxDefinition.pseudoClasses.definitions) : emptyPseudoClassSignatures,
    syntaxDefinition.pseudoClasses.unknown === "accept"
  ] : [false, emptyPseudoClassSignatures, false];
  const [pseudoElementsEnabled, pseudoElementsSingleColonNotationEnabled, pseudoElementsDoubleColonNotationEnabled, pseudoElementsIndex, pseudoElementsAcceptUnknown] = syntaxDefinition.pseudoElements ? [
    true,
    syntaxDefinition.pseudoElements.notation === "singleColon" || syntaxDefinition.pseudoElements.notation === "both",
    !syntaxDefinition.pseudoElements.notation || syntaxDefinition.pseudoElements.notation === "doubleColon" || syntaxDefinition.pseudoElements.notation === "both",
    syntaxDefinition.pseudoElements.definitions ? createRegularIndex(syntaxDefinition.pseudoElements.definitions) : emptyRegularIndex,
    syntaxDefinition.pseudoElements.unknown === "accept"
  ] : [false, false, false, emptyRegularIndex, false];
  let str = "";
  let l = str.length;
  let pos = 0;
  let chr = "";
  const is2 = (comparison) => chr === comparison;
  const isTagStart = () => is2("*") || isIdentStart(chr) || is2("\\");
  const rewind = (newPos) => {
    pos = newPos;
    chr = str.charAt(pos);
  };
  const next = () => {
    pos++;
    chr = str.charAt(pos);
  };
  const readAndNext = () => {
    const current = chr;
    pos++;
    chr = str.charAt(pos);
    return current;
  };
  function fail(errorMessage) {
    const position2 = Math.min(l - 1, pos);
    const error = new Error(`${errorPrefix}${errorMessage} Pos: ${position2}.`);
    error.position = position2;
    error.name = "ParserError";
    throw error;
  }
  function assert(condition, errorMessage) {
    if (!condition) {
      return fail(errorMessage);
    }
  }
  const assertNonEof = () => {
    assert(pos < l, "Unexpected end of input.");
  };
  const isEof = () => pos >= l;
  const pass = (character) => {
    assert(pos < l, `Expected "${character}" but end of input reached.`);
    assert(chr === character, `Expected "${character}" but "${chr}" found.`);
    pos++;
    chr = str.charAt(pos);
  };
  function matchMulticharIndex(index2) {
    const match = matchMulticharIndexPos(index2, pos);
    if (match) {
      pos += match.length;
      chr = str.charAt(pos);
      return match;
    }
  }
  function matchMulticharIndexPos(index2, subPos) {
    const char = str.charAt(subPos);
    const charIndex = index2[char];
    if (charIndex) {
      const subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);
      if (subMatch) {
        return subMatch;
      }
      if (charIndex.self) {
        return charIndex.self;
      }
    }
  }
  function parseHex() {
    let hex = readAndNext();
    while (isHex(chr)) {
      hex += readAndNext();
    }
    if (is2(" ")) {
      next();
    }
    return String.fromCharCode(parseInt(hex, 16));
  }
  function parseString(quote) {
    let result = "";
    pass(quote);
    while (pos < l) {
      if (is2(quote)) {
        next();
        return result;
      } else if (is2("\\")) {
        next();
        let esc;
        if (is2(quote)) {
          result += quote;
        } else if ((esc = stringEscapeChars[chr]) !== void 0) {
          result += esc;
        } else if (isHex(chr)) {
          result += parseHex();
          continue;
        } else {
          result += chr;
        }
      } else {
        result += chr;
      }
      next();
    }
    return result;
  }
  function parseIdentifier() {
    let result = "";
    while (pos < l) {
      if (isIdent(chr)) {
        result += readAndNext();
      } else if (is2("\\")) {
        next();
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        return result;
      }
    }
    return result;
  }
  function parsePseudoClassString() {
    let result = "";
    while (pos < l) {
      if (is2(")")) {
        break;
      } else if (is2("\\")) {
        next();
        if (isEof() && !strict) {
          return (result + "\\").trim();
        }
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        result += readAndNext();
      }
    }
    return result.trim();
  }
  function skipWhitespace() {
    while (whitespaceChars[chr]) {
      next();
    }
  }
  function parseSelector2(relative = false) {
    skipWhitespace();
    const rules = [parseRule(relative)];
    while (is2(",")) {
      next();
      skipWhitespace();
      rules.push(parseRule(relative));
    }
    return {
      type: "Selector",
      rules
    };
  }
  function parseAttribute() {
    pass("[");
    skipWhitespace();
    let attr2;
    if (is2("|")) {
      assert(namespaceEnabled, "Namespaces are not enabled.");
      next();
      attr2 = {
        type: "Attribute",
        name: parseIdentifier(),
        namespace: { type: "NoNamespace" }
      };
    } else if (is2("*")) {
      assert(namespaceEnabled, "Namespaces are not enabled.");
      assert(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      next();
      pass("|");
      attr2 = {
        type: "Attribute",
        name: parseIdentifier(),
        namespace: { type: "WildcardNamespace" }
      };
    } else {
      const identifier = parseIdentifier();
      attr2 = {
        type: "Attribute",
        name: identifier
      };
      if (is2("|")) {
        const savedPos = pos;
        next();
        if (isIdentStart(chr) || is2("\\")) {
          assert(namespaceEnabled, "Namespaces are not enabled.");
          attr2 = {
            type: "Attribute",
            name: parseIdentifier(),
            namespace: { type: "NamespaceName", name: identifier }
          };
        } else {
          rewind(savedPos);
        }
      }
    }
    assert(attr2.name, "Expected attribute name.");
    skipWhitespace();
    if (isEof() && !strict) {
      return attr2;
    }
    if (is2("]")) {
      next();
    } else {
      attr2.operator = matchMulticharIndex(attributesOperatorsIndex);
      assert(attr2.operator, "Expected a valid attribute selector operator.");
      skipWhitespace();
      assertNonEof();
      if (quoteChars[chr]) {
        attr2.value = {
          type: "String",
          value: parseString(chr)
        };
      } else if (substitutesEnabled && is2("$")) {
        next();
        attr2.value = {
          type: "Substitution",
          name: parseIdentifier()
        };
        assert(attr2.value.name, "Expected substitute name.");
      } else {
        attr2.value = {
          type: "String",
          value: parseIdentifier()
        };
        assert(attr2.value.value, "Expected attribute value.");
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return attr2;
      }
      if (!is2("]")) {
        attr2.caseSensitivityModifier = parseIdentifier();
        assert(attr2.caseSensitivityModifier, "Expected end of attribute selector.");
        assert(attributesCaseSensitivityModifiersEnabled, "Attribute case sensitivity modifiers are not enabled.");
        assert(attributesAcceptUnknownCaseSensitivityModifiers || attributesCaseSensitivityModifiers[attr2.caseSensitivityModifier], "Unknown attribute case sensitivity modifier.");
        skipWhitespace();
        if (isEof() && !strict) {
          return attr2;
        }
      }
      pass("]");
    }
    return attr2;
  }
  function parseNumber() {
    let result = "";
    while (digitsChars[chr]) {
      result += readAndNext();
    }
    assert(result !== "", "Formula parse error.");
    return parseInt(result);
  }
  const isNumberStart = () => is2("-") || is2("+") || digitsChars[chr];
  function parseFormula() {
    if (is2("e") || is2("o")) {
      const ident = parseIdentifier();
      if (ident === "even") {
        skipWhitespace();
        return [2, 0];
      }
      if (ident === "odd") {
        skipWhitespace();
        return [2, 1];
      }
    }
    let firstNumber = null;
    let firstNumberMultiplier = 1;
    if (is2("-")) {
      next();
      firstNumberMultiplier = -1;
    }
    if (isNumberStart()) {
      if (is2("+")) {
        next();
      }
      firstNumber = parseNumber();
      if (!is2("\\") && !is2("n")) {
        return [0, firstNumber * firstNumberMultiplier];
      }
    }
    if (firstNumber === null) {
      firstNumber = 1;
    }
    firstNumber *= firstNumberMultiplier;
    let identifier;
    if (is2("\\")) {
      next();
      if (isHex(chr)) {
        identifier = parseHex();
      } else {
        identifier = readAndNext();
      }
    } else {
      identifier = readAndNext();
    }
    assert(identifier === "n", 'Formula parse error: expected "n".');
    skipWhitespace();
    if (is2("+") || is2("-")) {
      const sign = is2("+") ? 1 : -1;
      next();
      skipWhitespace();
      return [firstNumber, sign * parseNumber()];
    } else {
      return [firstNumber, 0];
    }
  }
  function parsePseudoClass(pseudoName) {
    const pseudo2 = {
      type: "PseudoClass",
      name: pseudoName
    };
    let pseudoDefinition = paeudoClassesDefinitions[pseudoName];
    if (!pseudoDefinition && pseudoClassesAcceptUnknown) {
      pseudoDefinition = defaultPseudoClassSignature;
    }
    assert(pseudoDefinition, `Unknown pseudo-class: "${pseudoName}".`);
    pseudoDefinition = pseudoDefinition;
    if (is2("(")) {
      next();
      skipWhitespace();
      if (substitutesEnabled && is2("$")) {
        next();
        pseudo2.argument = {
          type: "Substitution",
          name: parseIdentifier()
        };
        assert(pseudo2.argument.name, "Expected substitute name.");
      } else if (pseudoDefinition.type === "String") {
        pseudo2.argument = {
          type: "String",
          value: parsePseudoClassString()
        };
        assert(pseudo2.argument.value, "Expected pseudo-class argument value.");
      } else if (pseudoDefinition.type === "Selector") {
        pseudo2.argument = parseSelector2(true);
      } else if (pseudoDefinition.type === "Formula") {
        const [a, b] = parseFormula();
        pseudo2.argument = {
          type: "Formula",
          a,
          b
        };
        if (pseudoDefinition.ofSelector) {
          skipWhitespace();
          if (is2("o") || is2("\\")) {
            const ident = parseIdentifier();
            assert(ident === "of", "Formula of selector parse error.");
            skipWhitespace();
            pseudo2.argument = {
              type: "FormulaOfSelector",
              a,
              b,
              selector: parseRule()
            };
          }
        }
      } else {
        return fail("Invalid pseudo-class signature.");
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return pseudo2;
      }
      pass(")");
    } else {
      assert(pseudoDefinition.optional, `Argument is required for pseudo-class "${pseudoName}".`);
    }
    return pseudo2;
  }
  function parseTagName() {
    if (is2("*")) {
      assert(tagNameWildcardEnabled, "Wildcard tag name is not enabled.");
      next();
      return { type: "WildcardTag" };
    } else if (isIdentStart(chr) || is2("\\")) {
      assert(tagNameEnabled, "Tag names are not enabled.");
      return {
        type: "TagName",
        name: parseIdentifier()
      };
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseTagNameWithNamespace() {
    if (is2("*")) {
      const savedPos = pos;
      next();
      if (!is2("|")) {
        rewind(savedPos);
        return parseTagName();
      }
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return parseTagName();
      }
      assert(namespaceEnabled, "Namespaces are not enabled.");
      assert(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      const tagName = parseTagName();
      tagName.namespace = { type: "WildcardNamespace" };
      return tagName;
    } else if (is2("|")) {
      assert(namespaceEnabled, "Namespaces are not enabled.");
      next();
      const tagName = parseTagName();
      tagName.namespace = { type: "NoNamespace" };
      return tagName;
    } else if (isIdentStart(chr) || is2("\\")) {
      const identifier = parseIdentifier();
      if (!is2("|")) {
        assert(tagNameEnabled, "Tag names are not enabled.");
        return {
          type: "TagName",
          name: identifier
        };
      }
      const savedPos = pos;
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return {
          type: "TagName",
          name: identifier
        };
      }
      assert(namespaceEnabled, "Namespaces are not enabled.");
      const tagName = parseTagName();
      tagName.namespace = { type: "NamespaceName", name: identifier };
      return tagName;
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseRule(relative = false) {
    const rule = {};
    let isRuleStart = true;
    if (relative) {
      const combinator = matchMulticharIndex(combinatorsIndex);
      if (combinator) {
        rule.combinator = combinator;
        skipWhitespace();
      }
    }
    while (pos < l) {
      if (isTagStart()) {
        assert(isRuleStart, "Unexpected tag/namespace start.");
        rule.tag = parseTagNameWithNamespace();
      } else if (is2("|")) {
        const savedPos = pos;
        next();
        if (isTagStart()) {
          assert(isRuleStart, "Unexpected tag/namespace start.");
          rewind(savedPos);
          rule.tag = parseTagNameWithNamespace();
        } else {
          rewind(savedPos);
          break;
        }
      } else if (is2(".")) {
        assert(classNamesEnabled, "Class names are not enabled.");
        next();
        const className2 = parseIdentifier();
        assert(className2, "Expected class name.");
        (rule.classNames = rule.classNames || []).push(className2);
      } else if (is2("#")) {
        assert(idEnabled, "IDs are not enabled.");
        next();
        const idName = parseIdentifier();
        assert(idName, "Expected ID name.");
        (rule.ids = rule.ids || []).push(idName);
      } else if (is2("[")) {
        assert(attributesEnabled, "Attributes are not enabled.");
        (rule.attributes = rule.attributes || []).push(parseAttribute());
      } else if (is2(":")) {
        let isDoubleColon = false;
        let isPseudoElement = false;
        next();
        if (is2(":")) {
          assert(pseudoElementsEnabled, "Pseudo elements are not enabled.");
          assert(pseudoElementsDoubleColonNotationEnabled, "Pseudo elements double colon notation is not enabled.");
          isDoubleColon = true;
          next();
        }
        const pseudoName = parseIdentifier();
        assert(isDoubleColon || pseudoName, "Expected pseudo-class name.");
        assert(!isDoubleColon || pseudoName, "Expected pseudo-element name.");
        assert(!isDoubleColon || pseudoElementsAcceptUnknown || pseudoElementsIndex[pseudoName], `Unknown pseudo-element "${pseudoName}".`);
        isPseudoElement = pseudoElementsEnabled && (isDoubleColon || !isDoubleColon && pseudoElementsSingleColonNotationEnabled && pseudoElementsIndex[pseudoName]);
        if (isPseudoElement) {
          rule.pseudoElement = pseudoName;
          if (!whitespaceChars[chr] && !is2(",") && !is2(")") && !isEof()) {
            return fail("Pseudo-element should be the last component of a CSS selector rule.");
          }
        } else {
          assert(pseudoClassesEnabled, "Pseudo classes are not enabled.");
          (rule.pseudoClasses = rule.pseudoClasses || []).push(parsePseudoClass(pseudoName));
        }
      } else {
        break;
      }
      isRuleStart = false;
    }
    if (isRuleStart) {
      if (isEof()) {
        return fail("Expected rule but end of input reached.");
      } else {
        return fail(`Expected rule but "${chr}" found.`);
      }
    }
    rule.type = "Rule";
    skipWhitespace();
    if (!isEof() && !is2(",") && !is2(")")) {
      const combinator = matchMulticharIndex(combinatorsIndex);
      skipWhitespace();
      rule.nestedRule = parseRule();
      rule.nestedRule.combinator = combinator;
    }
    return rule;
  }
  return (input) => {
    if (typeof input !== "string") {
      throw new Error(`${errorPrefix}Expected string input.`);
    }
    str = input;
    l = str.length;
    pos = 0;
    chr = str.charAt(0);
    return parseSelector2();
  };
}
const cssSelectorParse = createParser({ syntax: "selectors-4" });
function parse(selector2) {
  if (typeof selector2 !== "string") {
    throw new TypeError("Expected `string` as selector, not `" + selector2 + "`");
  }
  return cssSelectorParse(selector2);
}
const rtlRange = "---";
const ltrRange = "A-Za-z--------";
const rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
const ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  const source = String(value || "");
  return rtl.test(source) ? "rtl" : ltr.test(source) ? "ltr" : "neutral";
}
function toString(node2) {
  if ("children" in node2) {
    return all$1(node2);
  }
  return "value" in node2 ? node2.value : "";
}
function one$1(node2) {
  if (node2.type === "text") {
    return node2.value;
  }
  return "children" in node2 ? all$1(node2) : "";
}
function all$1(node2) {
  let index2 = -1;
  const result = [];
  while (++index2 < node2.children.length) {
    result[index2] = one$1(node2.children[index2]);
  }
  return result.join("");
}
function enterState(state, node2) {
  const schema = state.schema;
  const language = state.language;
  const currentDirection = state.direction;
  const editableOrEditingHost = state.editableOrEditingHost;
  let dirInferred;
  if (node2.type === "element") {
    const lang2 = node2.properties.xmlLang || node2.properties.lang;
    const type = node2.properties.type || "text";
    const dir2 = dirProperty(node2);
    if (lang2 !== null && lang2 !== void 0) {
      state.language = String(lang2);
    }
    if (schema && schema.space === "html") {
      if (node2.properties.contentEditable === "true") {
        state.editableOrEditingHost = true;
      }
      if (node2.tagName === "svg") {
        state.schema = svg;
      }
      if (dir2 === "rtl") {
        dirInferred = dir2;
      } else if (
        // Explicit `[dir=ltr]`.
        dir2 === "ltr" || // HTML with an invalid or no `[dir]`.
        dir2 !== "auto" && node2.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
        dir2 !== "auto" && node2.tagName === "input" && type === "tel"
      ) {
        dirInferred = "ltr";
      } else if (dir2 === "auto" || node2.tagName === "bdi") {
        if (node2.tagName === "textarea") {
          dirInferred = dirBidi(toString(node2));
        } else if (node2.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) {
          dirInferred = node2.properties.value ? dirBidi(String(node2.properties.value)) : "ltr";
        } else {
          visit(node2, inferDirectionality);
        }
      }
      if (dirInferred) {
        state.direction = dirInferred;
      }
    } else if (state.editableOrEditingHost) {
      state.editableOrEditingHost = false;
    }
  }
  return reset;
  function reset() {
    state.schema = schema;
    state.language = language;
    state.direction = currentDirection;
    state.editableOrEditingHost = editableOrEditingHost;
  }
  function inferDirectionality(child) {
    if (child.type === "text") {
      dirInferred = dirBidi(child.value);
      return dirInferred ? EXIT : void 0;
    }
    if (child !== node2 && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || dirProperty(child))) {
      return SKIP;
    }
  }
}
function dirBidi(value) {
  const result = direction(value);
  return result === "neutral" ? void 0 : result;
}
function dirProperty(node2) {
  const value = node2.type === "element" && typeof node2.properties.dir === "string" ? node2.properties.dir.toLowerCase() : void 0;
  return value === "auto" || value === "ltr" || value === "rtl" ? value : void 0;
}
function attributes(query, element2, schema) {
  let index2 = -1;
  if (query.attributes) {
    while (++index2 < query.attributes.length) {
      if (!attribute(query.attributes[index2], element2, schema)) {
        return false;
      }
    }
  }
  return true;
}
function attribute(query, element2, schema) {
  const info = find(schema, query.name);
  const propertyValue = element2.properties[info.property];
  let value = normalizeValue(propertyValue, info);
  if (!query.value) {
    return value !== void 0;
  }
  ok$1(query.value.type === "String");
  let key2 = query.value.value;
  if (query.caseSensitivityModifier === "i") {
    key2 = key2.toLowerCase();
    if (value) {
      value = value.toLowerCase();
    }
  }
  if (value !== void 0) {
    switch (query.operator) {
      case "=": {
        return key2 === value;
      }
      case "$=": {
        return key2 === value.slice(-key2.length);
      }
      case "*=": {
        return value.includes(key2);
      }
      case "^=": {
        return key2 === value.slice(0, key2.length);
      }
      case "|=": {
        return key2 === value || key2 === value.slice(0, key2.length) && value.charAt(key2.length) === "-";
      }
      case "~=": {
        return (
          // For all other values (including comma-separated lists), return whether this
          // is an exact match.
          key2 === value || // If this is a space-separated list, and the query is contained in it, return
          // true.
          parse$1(value).includes(key2)
        );
      }
    }
  }
  return false;
}
function normalizeValue(value, info) {
  if (value === null || value === void 0)
    ;
  else if (typeof value === "boolean") {
    if (value) {
      return info.attribute;
    }
  } else if (Array.isArray(value)) {
    if (value.length > 0) {
      return (info.commaSeparated ? stringify$1 : stringify)(value);
    }
  } else {
    return String(value);
  }
}
const emptyClassNames = [];
function className(query, element2) {
  const value = (
    /** @type {Readonly<Array<string>>} */
    element2.properties.className || emptyClassNames
  );
  let index2 = -1;
  if (query.classNames) {
    while (++index2 < query.classNames.length) {
      if (!value.includes(query.classNames[index2]))
        return false;
    }
  }
  return true;
}
function id(query, element2) {
  const ids = query.ids;
  return ids.length === 1 && element2.properties.id === ids[0];
}
function name(query, element2) {
  ok$1(query.tag);
  return query.tag.type === "WildcardTag" || query.tag.name === element2.tagName;
}
function factory(check, filter2) {
  return function(tags, ranges) {
    let left = cast(tags, "tag");
    const right = cast(
      ranges === null || ranges === void 0 ? "*" : ranges,
      "range"
    );
    const matches = [];
    let rightIndex = -1;
    while (++rightIndex < right.length) {
      const range = right[rightIndex].toLowerCase();
      if (!filter2 && range === "*")
        continue;
      let leftIndex = -1;
      const next = [];
      while (++leftIndex < left.length) {
        if (check(left[leftIndex].toLowerCase(), range)) {
          if (!filter2) {
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              left[leftIndex]
            );
          }
          matches.push(left[leftIndex]);
        } else {
          next.push(left[leftIndex]);
        }
      }
      left = next;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      filter2 ? matches : void 0
    );
  };
}
const extendedFilter = factory(function(tag, range) {
  const left = tag.split("-");
  const right = range.split("-");
  let leftIndex = 0;
  let rightIndex = 0;
  if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) {
    return false;
  }
  leftIndex++;
  rightIndex++;
  while (rightIndex < right.length) {
    if (right[rightIndex] === "*") {
      rightIndex++;
      continue;
    }
    if (!left[leftIndex])
      return false;
    if (left[leftIndex] === right[rightIndex]) {
      leftIndex++;
      rightIndex++;
      continue;
    }
    if (left[leftIndex].length === 1)
      return false;
    leftIndex++;
  }
  return true;
}, true);
function cast(values, name2) {
  const value = values && typeof values === "string" ? [values] : values;
  if (!value || typeof value !== "object" || !("length" in value)) {
    throw new Error(
      "Invalid " + name2 + " `" + value + "`, expected non-empty string"
    );
  }
  return value;
}
const own = {}.hasOwnProperty;
function hasProperty(node2, name2) {
  const value = node2.type === "element" && own.call(node2.properties, name2) && node2.properties[name2];
  return value !== null && value !== void 0 && value !== false;
}
const nthCheck = nthCheck$1.default || nthCheck$1;
const handle = zwitch("name", {
  handlers: {
    "any-link": anyLink,
    blank,
    checked,
    dir,
    disabled,
    empty: empty$1,
    enabled,
    "first-child": firstChild,
    "first-of-type": firstOfType,
    has,
    is,
    lang,
    "last-child": lastChild,
    "last-of-type": lastOfType,
    not,
    "nth-child": nthChild,
    "nth-last-child": nthLastChild,
    "nth-last-of-type": nthLastOfType,
    "nth-of-type": nthOfType,
    "only-child": onlyChild,
    "only-of-type": onlyOfType,
    optional,
    "read-only": readOnly,
    "read-write": readWrite,
    required,
    root,
    scope
  },
  invalid: invalidPseudo,
  unknown: unknownPseudo
});
function pseudo(query, element2, index2, parent, state) {
  const pseudos2 = query.pseudoClasses;
  let offset = -1;
  while (++offset < pseudos2.length) {
    if (!handle(pseudos2[offset], element2, index2, parent, state))
      return false;
  }
  return true;
}
function anyLink(_, element2) {
  return (element2.tagName === "a" || element2.tagName === "area" || element2.tagName === "link") && hasProperty(element2, "href");
}
function assertDeep(state, query) {
  if (state.shallow) {
    throw new Error("Cannot use `:" + query.name + "` without parent");
  }
}
function blank(_, element2) {
  return !someChildren(element2, check);
  function check(child) {
    return child.type === "element" || child.type === "text" && !whitespace(child);
  }
}
function checked(_, element2) {
  if (element2.tagName === "input" || element2.tagName === "menuitem") {
    return Boolean(
      (element2.properties.type === "checkbox" || element2.properties.type === "radio") && hasProperty(element2, "checked")
    );
  }
  if (element2.tagName === "option") {
    return hasProperty(element2, "selected");
  }
  return false;
}
function dir(query, _1, _2, _3, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "String");
  return state.direction === query.argument.value;
}
function disabled(_, element2) {
  return (element2.tagName === "button" || element2.tagName === "input" || element2.tagName === "select" || element2.tagName === "textarea" || element2.tagName === "optgroup" || element2.tagName === "option" || element2.tagName === "menuitem" || element2.tagName === "fieldset") && hasProperty(element2, "disabled");
}
function empty$1(_, element2) {
  return !someChildren(element2, check);
  function check(child) {
    return child.type === "element" || child.type === "text";
  }
}
function enabled(query, element2) {
  return !disabled(query, element2);
}
function firstChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementIndex === 0;
}
function firstOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeIndex === 0;
}
function getCachedNthCheck(query) {
  let fn = query._cachedFn;
  if (!fn) {
    const value = query.argument;
    if (value.type !== "Formula") {
      throw new Error(
        "Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)"
      );
    }
    fn = nthCheck(value.a + "n+" + value.b);
    query._cachedFn = fn;
  }
  return fn;
}
function has(query, element2, _1, _2, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "Selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element2],
    // Do walk deep.
    shallow: false
  };
  walk(childState, { type: "root", children: element2.children });
  return childState.results.length > 0;
}
function invalidPseudo() {
}
function is(query, element2, _1, _2, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "Selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element2],
    // Do walk deep.
    shallow: false
  };
  walk(childState, element2);
  return childState.results[0] === element2;
}
function lang(query, _1, _2, _3, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "String");
  return state.language !== "" && state.language !== void 0 && extendedFilter(state.language, parse$2(query.argument.value)).length > 0;
}
function lastChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return Boolean(
    state.elementCount && state.elementIndex === state.elementCount - 1
  );
}
function lastOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
function not(query, element2, index2, parent, state) {
  return !is(query, element2, index2, parent, state);
}
function nthChild(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.elementIndex === "number" && fn(state.elementIndex);
}
function nthLastChild(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return Boolean(
    typeof state.elementCount === "number" && typeof state.elementIndex === "number" && fn(state.elementCount - state.elementIndex - 1)
  );
}
function nthLastOfType(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && fn(state.typeCount - 1 - state.typeIndex);
}
function nthOfType(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && fn(state.typeIndex);
}
function onlyChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementCount === 1;
}
function onlyOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeCount === 1;
}
function optional(query, element2) {
  return !required(query, element2);
}
function readOnly(query, element2, index2, parent, state) {
  return !readWrite(query, element2, index2, parent, state);
}
function readWrite(_, element2, _1, _2, state) {
  return element2.tagName === "input" || element2.tagName === "textarea" ? !hasProperty(element2, "readOnly") && !hasProperty(element2, "disabled") : Boolean(state.editableOrEditingHost);
}
function required(_, element2) {
  return (element2.tagName === "input" || element2.tagName === "textarea" || element2.tagName === "select") && hasProperty(element2, "required");
}
function root(_1, element2, _2, parent, state) {
  return Boolean(
    (!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element2.tagName === "html" || element2.tagName === "svg")
  );
}
function scope(_1, element2, _2, _3, state) {
  return state.scopeElements.includes(element2);
}
function someChildren(element2, check) {
  const children = element2.children;
  let index2 = -1;
  while (++index2 < children.length) {
    if (check(children[index2]))
      return true;
  }
  return false;
}
function unknownPseudo(query_) {
  const query = (
    /** @type {AstPseudoClass} */
    query_
  );
  throw new Error("Unknown pseudo-selector `" + query.name + "`");
}
function test(query, element2, index2, parent, state) {
  if (query.pseudoElement) {
    throw new Error("Invalid selector: `::" + query.pseudoElement + "`");
  }
  return Boolean(
    (!query.tag || name(query, element2)) && (!query.classNames || className(query, element2)) && (!query.ids || id(query, element2)) && (!query.attributes || attributes(query, element2, state.schema)) && (!query.pseudoClasses || pseudo(query, element2, index2, parent, state))
  );
}
const empty = [];
function walk(state, tree) {
  if (tree) {
    one(state, [], tree, void 0, void 0, tree);
  }
}
function add(nest, field, rule) {
  const list = nest[field];
  if (list) {
    list.push(rule);
  } else {
    nest[field] = [rule];
  }
}
function all(state, nest, node2, tree) {
  const fromParent = combine(nest.descendant, nest.directChild);
  let fromSibling;
  let index2 = -1;
  const total = { count: 0, types: /* @__PURE__ */ new Map() };
  const before2 = { count: 0, types: /* @__PURE__ */ new Map() };
  while (++index2 < node2.children.length) {
    count(total, node2.children[index2]);
  }
  index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    const name2 = child.type === "element" ? child.tagName.toUpperCase() : void 0;
    state.elementIndex = before2.count;
    state.typeIndex = name2 ? before2.types.get(name2) || 0 : 0;
    state.elementCount = total.count;
    state.typeCount = name2 ? total.types.get(name2) : 0;
    if ("children" in child) {
      const forSibling = combine(fromParent, fromSibling);
      const nest2 = one(
        state,
        forSibling,
        node2.children[index2],
        index2,
        node2,
        tree
      );
      fromSibling = combine(nest2.generalSibling, nest2.adjacentSibling);
    }
    if (state.one && state.found) {
      break;
    }
    count(before2, node2.children[index2]);
  }
}
function applySelectors(state, rules, node2, index2, parent) {
  const nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  let selectorIndex = -1;
  while (++selectorIndex < rules.length) {
    const rule = rules[selectorIndex];
    if (state.one && state.found) {
      break;
    }
    if (state.shallow && rule.nestedRule) {
      throw new Error("Expected selector without nesting");
    }
    if (test(rule, node2, index2, parent, state)) {
      const nest = rule.nestedRule;
      if (nest) {
        const label = nest.combinator === "+" ? "adjacentSibling" : nest.combinator === "~" ? "generalSibling" : nest.combinator === ">" ? "directChild" : "descendant";
        add(nestResult, label, nest);
      } else {
        state.found = true;
        if (!state.results.includes(node2)) {
          state.results.push(node2);
        }
      }
    }
    if (rule.combinator === void 0) {
      add(nestResult, "descendant", rule);
    } else if (rule.combinator === "~") {
      add(nestResult, "generalSibling", rule);
    }
  }
  return nestResult;
}
function combine(left, right) {
  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;
}
function count(counts, node2) {
  if (node2.type === "element") {
    const name2 = node2.tagName.toUpperCase();
    const count2 = (counts.types.get(name2) || 0) + 1;
    counts.count++;
    counts.types.set(name2, count2);
  }
}
function one(state, currentRules, node2, index2, parent, tree) {
  let nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  const exit = enterState(state, node2);
  if (node2.type === "element") {
    let rootRules = state.rootQuery.rules;
    if (parent && parent !== tree) {
      rootRules = state.rootQuery.rules.filter(
        (d) => d.combinator === void 0 || d.combinator === ">" && parent === tree
      );
    }
    nestResult = applySelectors(
      state,
      // Try the root rules for this element too.
      combine(currentRules, rootRules),
      node2,
      index2,
      parent
    );
  }
  if ("children" in node2 && !state.shallow && !(state.one && state.found)) {
    all(state, nestResult, node2, tree);
  }
  exit();
  return nestResult;
}
function selectAll(selector2, tree, space) {
  const state = createState(selector2, tree, space);
  walk(state, tree || void 0);
  return state.results;
}
function createState(selector2, tree, space) {
  return {
    direction: "ltr",
    editableOrEditingHost: false,
    elementCount: void 0,
    elementIndex: void 0,
    found: false,
    language: void 0,
    one: false,
    // State of the query.
    results: [],
    rootQuery: parse(selector2),
    schema: space === "svg" ? svg : html$2,
    scopeElements: tree ? tree.type === "root" ? tree.children : [tree] : [],
    shallow: false,
    typeIndex: void 0,
    typeCount: void 0
  };
}
const remarkRewrite = (options2) => {
  const { selector: selector2, rewrite } = options2 || {};
  return (tree) => {
    if (!rewrite || typeof rewrite !== "function")
      return;
    if (selector2 && typeof selector2 === "string") {
      const selected = selectAll(selector2, tree);
      if (selected && selected.length > 0) {
        visit(tree, selected, (node2, index2, parent) => {
          rewrite(node2, index2, parent);
        });
      }
      return;
    }
    visit(tree, (node2, index2, parent) => {
      rewrite(node2, index2, parent);
    });
  };
};
const rehypeRewrite = remarkRewrite;
const resetStyles = "/**\n * Inline reset styles\n * These set common defaults for a consistent UI. Their comments will be automatically stripped by juice\n */\n/* default margin/padding, box sizing*/\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n/* height 100% all the way down */\ntable,\ntr,\ntd {\n  height: 100%;\n}\n\n/* img behavior - bicubic ms resizing, no border, fix space gap on gmail/hotmail */\nimg {\n  outline: none;\n  text-decoration: none;\n  -ms-interpolation-mode: bicubic;\n  display: block;\n}\n\na img {\n  border: none;\n}\n\n/* mso 07, 10 table spacing fix http://www.campaignmonitor.com/blog/post/3694/removing-spacing-from-around-tables-in-outlook-2007-and-2010 */\ntable {\n  border-collapse: collapse;\n  mso-table-lspace: 0pt;\n  mso-table-rspace: 0pt;\n}\n\n/* tel/sms links are unstyled by default */\na[href^=tel],\na[href^=sms] {\n  text-decoration: none;\n  pointer-events: none;\n  cursor: default;\n}";
const universalStyles = '/**\n * Originally based on The MailChimp Reset from Fabio Carneiro, MailChimp User Experience Design\n * More info and templates on Github: https://github.com/mailchimp/Email-Blueprints\n * http://www.mailchimp.com &amp; http://www.fabio-carneiro.com\n * These styles are non-inline; they impact UI added by email clients\n * By line:\n * (1) Force Outlook to provide a "view in browser" message\n * (2) Force Hotmail to display emails at full width\n * (3) Force Hotmail to display normal line spacing\n * (4) Prevent WebKit and Windows mobile changing default text sizes\n * (5) Remove spacing between tables in Outlook 2007 and up\n * (6) Remove table borders on MSO 07+ http://www.campaignmonitor.com/blog/post/3392/1px-borders-padding-on-table-cells-in-outlook-07/\n * (7) Specify bicubic resampling for MSO on img objects\n * (8) Media Query block - Pretty phone numbers in email: http://www.campaignmonitor.com/blog/post/3571/using-phone-numbers-in-html-email\n * (9) Media Query block - same as above, but for tablet sized devices\n */\n#outlook a {\n  padding: 0;\n}\n\n.ReadMsgBody {\n  width: 100%;\n}\n\n.ExternalClass {\n  width: 100%;\n}\n\n.ExternalClass,\n.ExternalClass p,\n.ExternalClass span,\n.ExternalClass font,\n.ExternalClass td,\n.ExternalClass div {\n  line-height: 100%;\n}\n\nbody,\ntable,\ntd,\np,\na,\nli,\nblockquote {\n  -webkit-text-size-adjust: 100%;\n  -ms-text-size-adjust: 100%;\n}\n\ntable,\ntd {\n  mso-table-lspace: 0pt;\n  mso-table-rspace: 0pt;\n}\n\ntable td {\n  border-collapse: collapse;\n}\n\nimg {\n  -ms-interpolation-mode: bicubic;\n}\n\n@media only screen and (max-device-width: 480px) {\n  a[href^=tel],\n  a[href^=sms] {\n    -webkit-text-decoration: default !important;\n            text-decoration: default !important;\n    pointer-events: auto !important;\n    cursor: default !important;\n  }\n}\n@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {\n  a[href^=tel],\n  a[href^=sms] {\n    -webkit-text-decoration: default !important;\n            text-decoration: default !important;\n    pointer-events: auto !important;\n    cursor: default !important;\n  }\n}';
const TAILWIND_CONFIG_PATH = "./tailwind.config.cjs";
const exec = async (name2, args) => {
  return new Promise((resolve, reject) => {
    const child = child_process.spawn(name2, args);
    let stdout = dist.Buffer.alloc(0);
    let stderr = dist.Buffer.alloc(0);
    child.stdout.on("data", (data2) => {
      stdout = dist.Buffer.concat([stdout, data2]);
    });
    child.stderr.on("data", (data2) => {
      stderr = dist.Buffer.concat([stderr, data2]);
    });
    child.on("error", (error) => {
      reject({
        error,
        stdout: stdout.toString(),
        stderr: stderr.toString()
      });
    });
    child.on("close", (code2) => {
      if (code2 == null) {
        reject({
          error: new Error("Process exited with null exit code."),
          stdout: stdout.toString(),
          stderr: stderr.toString()
        });
        return;
      }
      resolve({
        exit_code: code2,
        stdout: stdout.toString(),
        stderr: stderr.toString()
      });
    });
  });
};
const createStyleNode = (css2) => {
  return {
    type: "element",
    tagName: "style",
    children: [{ type: "text", value: css2 }]
  };
};
const resolveCssVariables = (s2) => {
  const VARIABLE_DEF_REGEX = /(--[a-zA-Z0-9-_]+)\s*:\s(.+?);/g;
  const VARIABLE_USAGE_REGEX = /var\((\s*--[a-zA-Z0-9-_]+\s*)(?:\)|,\s*(.*)\))/;
  const defs = /* @__PURE__ */ new Map();
  let withoutDefs = s2.replace(VARIABLE_DEF_REGEX, (_, def, value) => {
    defs.set(def.trim(), value.trim());
    return "";
  });
  const MAX_CYCLES = 1e3;
  let maxCycles = MAX_CYCLES;
  while (withoutDefs.match(VARIABLE_USAGE_REGEX)) {
    maxCycles--;
    if (maxCycles <= 0) {
      throw new Error("Max Cycles for replacement exceeded");
    }
    withoutDefs = withoutDefs.replace(
      VARIABLE_USAGE_REGEX,
      (_, def, fallback) => {
        const d = def.trim();
        if (defs.has(d)) {
          return defs.get(d) ?? "";
        }
        return (fallback ?? "").trim();
      }
    );
  }
  return withoutDefs;
};
const hypeHtml = (html2, css2) => {
  const hyped = rehype().use(rehypeRewrite, {
    rewrite: (node2) => {
      var _a;
      if (node2.type !== "element") {
        return node2;
      }
      if (node2.tagName === "head") {
        if (css2 != null) {
          const tmp = [
            ...node2.children,
            ...css2.map((c) => createStyleNode(c))
          ];
          node2.children = tmp;
        }
      }
      node2.properties = {
        ...node2.properties,
        style: resolveCssVariables(`${((_a = node2.properties) == null ? void 0 : _a.style) ?? ""}`)
      };
    }
  }).use(rehypeStringify).processSync(html2).toString();
  return hyped;
};
const updateIgnoredPseudos = (css2) => {
  const PSEUDO_CLASSES_REGEX = new RegExp("(?<=\\:)[a-z0-9-]+(?=\\:)", "g");
  const foundPseudos = css2.match(PSEUDO_CLASSES_REGEX) || [];
  foundPseudos.forEach((pseudo2) => {
    if (!juice.ignoredPseudos.includes(pseudo2)) {
      juice.ignoredPseudos.push(pseudo2);
    }
  });
};
const inlineStyles = (html2, tailwindCss, extraCss) => {
  const juiceOptions = {
    inlinePseudoElements: true,
    preserveImportant: true,
    applyStyleTags: true,
    removeStyleTags: true,
    insertPreservedExtraCss: true,
    preservePseudos: true,
    preserveFontFaces: true,
    preserveMediaQueries: true,
    preserveKeyFrames: true
    // !BUG - this is not working
    // resolveCSSVariables: true,
  };
  updateIgnoredPseudos(tailwindCss);
  if (extraCss != null) {
    extraCss.forEach((css2) => {
      updateIgnoredPseudos(css2);
    });
  } else {
    extraCss = [];
  }
  const htmlWithCss = hypeHtml(html2, [tailwindCss]);
  const juiced = juice(htmlWithCss, juiceOptions);
  const hyped = hypeHtml(juiced, extraCss);
  return hyped;
};
const mailwindCss = async (inputHtml, options2) => {
  const tailwindCssPath = require.resolve("tailwindcss/lib/cli.js");
  const tailwindConfigPath = options2.tailwindConfigPath ?? TAILWIND_CONFIG_PATH;
  const tmpInputHtmlPath = path$1.join(os.tmpdir(), "mailwind-input.html");
  fs.writeFileSync(tmpInputHtmlPath, inputHtml);
  const tmpInputCssPath = path$1.join(os.tmpdir(), "mailwind-input.css");
  fs.writeFileSync(tmpInputCssPath, options2.css ?? "");
  const tmpTailwindCssPath = path$1.join(os.tmpdir(), "mailwind-output.css");
  fs.writeFileSync(tmpTailwindCssPath, "");
  const args = [
    tailwindCssPath,
    "--config",
    tailwindConfigPath,
    "--output",
    tmpTailwindCssPath,
    "--content",
    tmpInputHtmlPath
  ];
  if (options2.css) {
    args.push("--input");
    args.push(tmpInputCssPath);
  }
  const result = await exec(require$$1.argv0, args);
  if (result.exit_code !== 0) {
    console.error("Failed to run Tailwind.");
    console.error(result.stderr);
    return;
  }
  const tailwindCss = fs.readFileSync(tmpTailwindCssPath, "utf-8") ?? "";
  return {
    html: inlineStyles(inputHtml, tailwindCss, [resetStyles, universalStyles]),
    css: tailwindCss
  };
};
const y = yargs(helpers$5.hideBin(dist.process.argv)).option("input-html", {
  alias: "i",
  describe: "The path to your input HTML file",
  type: "string",
  default: "./data/email.html",
  demandOption: true
}).option("output-html", {
  alias: "o",
  describe: "The path to the inlined HTML file that will be generated",
  type: "string",
  default: "./data/email.output.html",
  demandOption: true
}).option("input-css", {
  alias: "c",
  type: "string",
  describe: "The path to your custom CSS file"
}).option("output-css", {
  type: "string",
  describe: "The path to the CSS file that will be generated"
}).option("tailwind-config", {
  type: "string",
  describe: "The path to your custom Tailwind config file"
}).option("reset", {
  type: "string",
  describe: "Set to `false` to disable extended resets"
});
const main = async () => {
  console.log("Running mailwind...");
  const argv = await y.argv;
  const inputHtmlPath = argv["input-html"];
  const outputHtmlPath = argv["output-html"];
  const inputCssPath = argv["input-css"];
  const outputCssPath = argv["output-css"];
  const tailwindConfigPath = argv["tailwind-config"];
  const reset = argv["reset"];
  const inputHtml = fs.readFileSync(inputHtmlPath, "utf-8");
  const options2 = {
    css: inputCssPath ? fs.readFileSync(inputCssPath, "utf-8") : void 0,
    tailwindConfigPath,
    reset: reset === "false" ? false : true
  };
  const output = await mailwindCss(inputHtml, options2);
  if (!output) {
    console.log("Failed to generate output.");
    return;
  }
  const { html: html2, css: css2 } = output;
  if (outputHtmlPath) {
    fs.writeFileSync(outputHtmlPath, html2);
  }
  if (outputCssPath) {
    fs.writeFileSync(outputCssPath, css2);
  }
};
main().catch((error) => {
  console.error(error);
  dist.process.exit(1);
});
//# sourceMappingURL=mailwind.cjs.map
