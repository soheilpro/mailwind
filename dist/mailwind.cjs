"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var dist = {};
var bufferPolyfill = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
  lookup[i$1] = code[i$1];
  revLookup[code.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end2; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked2(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked2(array.length) | 0;
    const buf = createBuffer(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked2(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN2(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked2(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    const buffer = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end2 - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer, val2, byteOffset, encoding, dir2) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN2(byteOffset)) {
      byteOffset = dir2 ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir2)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir2)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val2 === "string") {
      val2 = Buffer2.from(val2, encoding);
    }
    if (Buffer2.isBuffer(val2)) {
      if (val2.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val2, byteOffset, encoding, dir2);
    } else if (typeof val2 === "number") {
      val2 = val2 & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir2) {
          return Uint8Array.prototype.indexOf.call(buffer, val2, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val2, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val2], byteOffset, encoding, dir2);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val2, byteOffset, encoding, dir2) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val2.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val2.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir2) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val2, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i2 + j2) !== read(val2, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val2, byteOffset, encoding) {
    return this.indexOf(val2, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val2, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN2(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end2) {
    if (start === 0 && end2 === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end2));
    }
  }
  function utf8Slice(buf, start, end2) {
    end2 = Math.min(buf.length, end2);
    const res = [];
    let i2 = start;
    while (i2 < end2) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end2) {
    let ret = "";
    end2 = Math.min(buf.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end2) {
    let ret = "";
    end2 = Math.min(buf.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end2) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len)
      end2 = len;
    let out = "";
    for (let i2 = start; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end2) {
    const bytes = buf.slice(start, end2);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end2) {
    const len = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len : ~~end2;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end2 < 0) {
      end2 += len;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len) {
      end2 = len;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val2 = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val2 += this[offset + i2] * mul;
    }
    return val2;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val2 = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val2 += this[offset + --byteLength3] * mul;
    }
    return val2;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val2 = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val2 += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val2 >= mul)
      val2 -= Math.pow(2, 8 * byteLength3);
    return val2;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val2 = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val2 += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val2 >= mul)
      val2 -= Math.pow(2, 8 * byteLength3);
    return val2;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val2 = this[offset] | this[offset + 1] << 8;
    return val2 & 32768 ? val2 | 4294901760 : val2;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val2 = this[offset + 1] | this[offset] << 8;
    return val2 & 32768 ? val2 | 4294901760 : val2;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val2 = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val2) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val2 = (first2 << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val2) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max2) {
    checkIntBI(value, min, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max2) {
    checkIntBI(value, min, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val2, start, end2, encoding) {
    if (typeof val2 === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val2.length === 1) {
        const code2 = val2.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val2 = code2;
        }
      }
    } else if (typeof val2 === "number") {
      val2 = val2 & 255;
    } else if (typeof val2 === "boolean") {
      val2 = Number(val2);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val2)
      val2 = 0;
    let i2;
    if (typeof val2 === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val2;
      }
    } else {
      const bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val2) {
    let res = "";
    let i2 = val2.length;
    const start = val2[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val2.slice(i2 - 3, i2)}${res}`;
    }
    return `${val2.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range = `>= ${min}${n2} and <= ${max2}${n2}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN2(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i2] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(bufferPolyfill);
var browser$1 = { exports: {} };
var process = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name2) {
  return [];
};
process.binding = function(name2) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir2) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
(function(exports2) {
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
  const t2 = bufferPolyfill, r2 = browserExports, o2 = (e2) => e2 && e2.__esModule ? e2 : { default: e2 }, l2 = o2(r2), u2 = globalThis || void 0 || self;
  Object.defineProperty(exports2, "Buffer", { enumerable: true, get: () => t2.Buffer });
  Object.defineProperty(exports2, "process", { enumerable: true, get: () => l2.default });
  exports2.global = u2;
})(dist);
var empty$5 = null;
const empty$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: empty$5
}, Symbol.toStringTag, { value: "Module" }));
var cheerio$2 = { exports: {} };
var lib$l = {};
var types$2 = {};
Object.defineProperty(types$2, "__esModule", { value: true });
var load = {};
var options = {};
var __assign$b = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$b = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$b.apply(this, arguments);
};
Object.defineProperty(options, "__esModule", { value: true });
options.flatten = void 0;
var defaultOpts$1 = {
  xml: false,
  decodeEntities: true
};
options.default = defaultOpts$1;
var xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true
};
function flatten(options2) {
  return (options2 === null || options2 === void 0 ? void 0 : options2.xml) ? typeof options2.xml === "boolean" ? xmlModeDefault : __assign$b(__assign$b({}, xmlModeDefault), options2.xml) : options2 !== null && options2 !== void 0 ? options2 : void 0;
}
options.flatten = flatten;
var _static = {};
var lib$k = {};
var stringify$8 = {};
var lib$j = {};
var lib$i = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
  var ElementType2;
  (function(ElementType3) {
    ElementType3["Root"] = "root";
    ElementType3["Text"] = "text";
    ElementType3["Directive"] = "directive";
    ElementType3["Comment"] = "comment";
    ElementType3["Script"] = "script";
    ElementType3["Style"] = "style";
    ElementType3["Tag"] = "tag";
    ElementType3["CDATA"] = "cdata";
    ElementType3["Doctype"] = "doctype";
  })(ElementType2 = exports2.ElementType || (exports2.ElementType = {}));
  function isTag2(elem) {
    return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
  }
  exports2.isTag = isTag2;
  exports2.Root = ElementType2.Root;
  exports2.Text = ElementType2.Text;
  exports2.Directive = ElementType2.Directive;
  exports2.Comment = ElementType2.Comment;
  exports2.Script = ElementType2.Script;
  exports2.Style = ElementType2.Style;
  exports2.Tag = ElementType2.Tag;
  exports2.CDATA = ElementType2.CDATA;
  exports2.Doctype = ElementType2.Doctype;
})(lib$i);
var node$4 = {};
var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$a = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$a = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$a.apply(this, arguments);
};
Object.defineProperty(node$4, "__esModule", { value: true });
node$4.cloneNode = node$4.hasChildren = node$4.isDocument = node$4.isDirective = node$4.isComment = node$4.isText = node$4.isCDATA = node$4.isTag = node$4.Element = node$4.Document = node$4.CDATA = node$4.NodeWithChildren = node$4.ProcessingInstruction = node$4.Comment = node$4.Text = node$4.DataNode = node$4.Node = void 0;
var domelementtype_1$8 = lib$i;
var Node$4 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$4(this, recursive);
    };
    return Node2;
  }()
);
node$4.Node = Node$4;
var DataNode$4 = (
  /** @class */
  function(_super) {
    __extends$5(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$4)
);
node$4.DataNode = DataNode$4;
var Text$4 = (
  /** @class */
  function(_super) {
    __extends$5(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$4)
);
node$4.Text = Text$4;
var Comment$4 = (
  /** @class */
  function(_super) {
    __extends$5(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$4)
);
node$4.Comment = Comment$4;
var ProcessingInstruction$4 = (
  /** @class */
  function(_super) {
    __extends$5(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$8.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$4)
);
node$4.ProcessingInstruction = ProcessingInstruction$4;
var NodeWithChildren$4 = (
  /** @class */
  function(_super) {
    __extends$5(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$4)
);
node$4.NodeWithChildren = NodeWithChildren$4;
var CDATA$4 = (
  /** @class */
  function(_super) {
    __extends$5(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$4)
);
node$4.CDATA = CDATA$4;
var Document$4 = (
  /** @class */
  function(_super) {
    __extends$5(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$8.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$4)
);
node$4.Document = Document$4;
var Element$4 = (
  /** @class */
  function(_super) {
    __extends$5(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$8.ElementType.Script : name2 === "style" ? domelementtype_1$8.ElementType.Style : domelementtype_1$8.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$4)
);
node$4.Element = Element$4;
function isTag$4(node2) {
  return (0, domelementtype_1$8.isTag)(node2);
}
node$4.isTag = isTag$4;
function isCDATA$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.CDATA;
}
node$4.isCDATA = isCDATA$4;
function isText$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Text;
}
node$4.isText = isText$4;
function isComment$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Comment;
}
node$4.isComment = isComment$4;
function isDirective$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Directive;
}
node$4.isDirective = isDirective$4;
function isDocument$4(node2) {
  return node2.type === domelementtype_1$8.ElementType.Root;
}
node$4.isDocument = isDocument$4;
function hasChildren$4(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$4.hasChildren = hasChildren$4;
function cloneNode$4(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$4(node2)) {
    result = new Text$4(node2.data);
  } else if (isComment$4(node2)) {
    result = new Comment$4(node2.data);
  } else if (isTag$4(node2)) {
    var children = recursive ? cloneChildren$4(node2.children) : [];
    var clone_1 = new Element$4(node2.name, __assign$a({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$a({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$a({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$4(node2)) {
    var children = recursive ? cloneChildren$4(node2.children) : [];
    var clone_2 = new CDATA$4(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$4(node2)) {
    var children = recursive ? cloneChildren$4(node2.children) : [];
    var clone_3 = new Document$4(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$4(node2)) {
    var instruction = new ProcessingInstruction$4(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$4.cloneNode = cloneNode$4;
function cloneChildren$4(childs) {
  var children = childs.map(function(child) {
    return cloneNode$4(child, true);
  });
  for (var i2 = 1; i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$4;
  __exportStar(node$4, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$j);
var lib$h = {};
var lib$g = {};
var decode$4 = {};
var decodeDataHtml$4 = {};
Object.defineProperty(decodeDataHtml$4, "__esModule", { value: true });
decodeDataHtml$4.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decodeDataXml$4 = {};
Object.defineProperty(decodeDataXml$4, "__esModule", { value: true });
decodeDataXml$4.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decode_codepoint$4 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$4);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$4);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$4);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$4);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$4;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$4);
var encode$3 = {};
var encodeHtml$3 = {};
Object.defineProperty(encodeHtml$3, "__esModule", { value: true });
function restoreDiff$3(arr) {
  for (var i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
encodeHtml$3.default = new Map(/* @__PURE__ */ restoreDiff$3([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff$3([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff$3([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff$3([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c2, index2) {
      return (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i2 = match.index;
      var char = str.charCodeAt(i2);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i2) + next;
        lastIdx = i2 + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports2.getCodePoint)(str, i2).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$4);
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode$3, "__esModule", { value: true });
encode$3.encodeNonAsciiHTML = encode$3.encodeHTML = void 0;
var encode_html_js_1$3 = __importDefault$9(encodeHtml$3);
var escape_js_1$4 = _escape$4;
var htmlReplacer$3 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML$3(data2) {
  return encodeHTMLTrieRe$3(htmlReplacer$3, data2);
}
encode$3.encodeHTML = encodeHTML$3;
function encodeNonAsciiHTML$3(data2) {
  return encodeHTMLTrieRe$3(escape_js_1$4.xmlReplacer, data2);
}
encode$3.encodeNonAsciiHTML = encodeNonAsciiHTML$3;
function encodeHTMLTrieRe$3(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i2 = match.index;
    ret += str.substring(lastIdx, i2);
    var char = str.charCodeAt(i2);
    var next = encode_html_js_1$3.default.get(char);
    if (typeof next === "object") {
      if (i2 + 1 < str.length) {
        var nextChar = str.charCodeAt(i2 + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i2 + 1;
    } else {
      var cp = (0, escape_js_1$4.getCodePoint)(str, i2);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode$4;
  var encode_js_1 = encode$3;
  var escape_js_12 = _escape$4;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode2;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode2(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode2;
  var escape_js_2 = _escape$4;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode$3;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode$4;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib$g);
var foreignNames$3 = {};
Object.defineProperty(foreignNames$3, "__esModule", { value: true });
foreignNames$3.attributeNames = foreignNames$3.elementNames = void 0;
foreignNames$3.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames$3.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign$9 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$9 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$9.apply(this, arguments);
};
var __createBinding$9 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$9 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$9 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$9(result, mod, k2);
  }
  __setModuleDefault$9(result, mod);
  return result;
};
Object.defineProperty(lib$h, "__esModule", { value: true });
lib$h.render = void 0;
var ElementType$3 = __importStar$9(lib$i);
var entities_1$3 = lib$g;
var foreignNames_js_1$3 = foreignNames$3;
var unencodedElements$3 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes$3(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes$3(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes$3 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1$3.encodeXML : entities_1$3.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1$3.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag$3 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$4(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode$3(nodes[i2], options2);
  }
  return output;
}
lib$h.render = render$4;
lib$h.default = render$4;
function renderNode$3(node2, options2) {
  switch (node2.type) {
    case ElementType$3.Root:
      return render$4(node2.children, options2);
    case ElementType$3.Doctype:
    case ElementType$3.Directive:
      return renderDirective$3(node2);
    case ElementType$3.Comment:
      return renderComment$3(node2);
    case ElementType$3.CDATA:
      return renderCdata$3(node2);
    case ElementType$3.Script:
    case ElementType$3.Style:
    case ElementType$3.Tag:
      return renderTag$3(node2, options2);
    case ElementType$3.Text:
      return renderText$3(node2, options2);
  }
}
var foreignModeIntegrationPoints$3 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements$3 = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$3(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1$3.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints$3.has(elem.parent.name)) {
      opts = __assign$9(__assign$9({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$3.has(elem.name)) {
    opts = __assign$9(__assign$9({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$3(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$3.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$4(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$3.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$3(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$3(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$3.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1$3.encodeXML)(data2) : (0, entities_1$3.escapeText)(data2);
  }
  return data2;
}
function renderCdata$3(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$3(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$8, "__esModule", { value: true });
stringify$8.innerText = stringify$8.textContent = stringify$8.getText = stringify$8.getInnerHTML = stringify$8.getOuterHTML = void 0;
var domhandler_1$j = lib$j;
var dom_serializer_1$3 = __importDefault$8(lib$h);
var domelementtype_1$7 = lib$i;
function getOuterHTML$3(node2, options2) {
  return (0, dom_serializer_1$3.default)(node2, options2);
}
stringify$8.getOuterHTML = getOuterHTML$3;
function getInnerHTML$3(node2, options2) {
  return (0, domhandler_1$j.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML$3(node3, options2);
  }).join("") : "";
}
stringify$8.getInnerHTML = getInnerHTML$3;
function getText$3(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$3).join("");
  if ((0, domhandler_1$j.isTag)(node2))
    return node2.name === "br" ? "\n" : getText$3(node2.children);
  if ((0, domhandler_1$j.isCDATA)(node2))
    return getText$3(node2.children);
  if ((0, domhandler_1$j.isText)(node2))
    return node2.data;
  return "";
}
stringify$8.getText = getText$3;
function textContent$3(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent$3).join("");
  if ((0, domhandler_1$j.hasChildren)(node2) && !(0, domhandler_1$j.isComment)(node2)) {
    return textContent$3(node2.children);
  }
  if ((0, domhandler_1$j.isText)(node2))
    return node2.data;
  return "";
}
stringify$8.textContent = textContent$3;
function innerText$3(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText$3).join("");
  if ((0, domhandler_1$j.hasChildren)(node2) && (node2.type === domelementtype_1$7.ElementType.Tag || (0, domhandler_1$j.isCDATA)(node2))) {
    return innerText$3(node2.children);
  }
  if ((0, domhandler_1$j.isText)(node2))
    return node2.data;
  return "";
}
stringify$8.innerText = innerText$3;
var traversal$3 = {};
Object.defineProperty(traversal$3, "__esModule", { value: true });
traversal$3.prevElementSibling = traversal$3.nextElementSibling = traversal$3.getName = traversal$3.hasAttrib = traversal$3.getAttributeValue = traversal$3.getSiblings = traversal$3.getParent = traversal$3.getChildren = void 0;
var domhandler_1$i = lib$j;
function getChildren$3(elem) {
  return (0, domhandler_1$i.hasChildren)(elem) ? elem.children : [];
}
traversal$3.getChildren = getChildren$3;
function getParent$3(elem) {
  return elem.parent || null;
}
traversal$3.getParent = getParent$3;
function getSiblings$3(elem) {
  var _a, _b;
  var parent = getParent$3(elem);
  if (parent != null)
    return getChildren$3(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal$3.getSiblings = getSiblings$3;
function getAttributeValue$3(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal$3.getAttributeValue = getAttributeValue$3;
function hasAttrib$3(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal$3.hasAttrib = hasAttrib$3;
function getName$3(elem) {
  return elem.name;
}
traversal$3.getName = getName$3;
function nextElementSibling$3(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$i.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal$3.nextElementSibling = nextElementSibling$3;
function prevElementSibling$3(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$i.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal$3.prevElementSibling = prevElementSibling$3;
var manipulation$4 = {};
Object.defineProperty(manipulation$4, "__esModule", { value: true });
manipulation$4.prepend = manipulation$4.prependChild = manipulation$4.append = manipulation$4.appendChild = manipulation$4.replaceElement = manipulation$4.removeElement = void 0;
function removeElement$3(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation$4.removeElement = removeElement$3;
function replaceElement$3(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation$4.replaceElement = replaceElement$3;
function appendChild$3(parent, child) {
  removeElement$3(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation$4.appendChild = appendChild$3;
function append$3(elem, next) {
  removeElement$3(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation$4.append = append$3;
function prependChild$3(parent, child) {
  removeElement$3(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation$4.prependChild = prependChild$3;
function prepend$3(elem, prev) {
  removeElement$3(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation$4.prepend = prepend$3;
var querying$3 = {};
Object.defineProperty(querying$3, "__esModule", { value: true });
querying$3.findAll = querying$3.existsOne = querying$3.findOne = querying$3.findOneChild = querying$3.find = querying$3.filter = void 0;
var domhandler_1$h = lib$j;
function filter$4(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$5(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying$3.filter = filter$4;
function find$5(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$h.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$3.find = find$5;
function findOneChild$3(test2, nodes) {
  return nodes.find(test2);
}
querying$3.findOneChild = findOneChild$3;
function findOne$3(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
    var node2 = nodes[i2];
    if (!(0, domhandler_1$h.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne$3(test2, node2.children, true);
    }
  }
  return elem;
}
querying$3.findOne = findOne$3;
function existsOne$3(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$h.isTag)(checked2) && (test2(checked2) || existsOne$3(test2, checked2.children));
  });
}
querying$3.existsOne = existsOne$3;
function findAll$3(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$h.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$3.findAll = findAll$3;
var legacy$3 = {};
Object.defineProperty(legacy$3, "__esModule", { value: true });
legacy$3.getElementsByTagType = legacy$3.getElementsByTagName = legacy$3.getElementById = legacy$3.getElements = legacy$3.testElement = void 0;
var domhandler_1$g = lib$j;
var querying_js_1$3 = querying$3;
var Checks$3 = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1$g.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1$g.isTag;
    }
    return function(elem) {
      return (0, domhandler_1$g.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1$g.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1$g.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck$3(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1$g.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1$g.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs$3(a2, b2) {
  return function(elem) {
    return a2(elem) || b2(elem);
  };
}
function compileTest$3(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks$3, key2) ? Checks$3[key2](value) : getAttribCheck$3(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$3);
}
function testElement$3(options2, node2) {
  var test2 = compileTest$3(options2);
  return test2 ? test2(node2) : true;
}
legacy$3.testElement = testElement$3;
function getElements$3(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest$3(options2);
  return test2 ? (0, querying_js_1$3.filter)(test2, nodes, recurse, limit) : [];
}
legacy$3.getElements = getElements$3;
function getElementById$3(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1$3.findOne)(getAttribCheck$3("id", id2), nodes, recurse);
}
legacy$3.getElementById = getElementById$3;
function getElementsByTagName$3(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$3.filter)(Checks$3["tag_name"](tagName), nodes, recurse, limit);
}
legacy$3.getElementsByTagName = getElementsByTagName$3;
function getElementsByTagType$3(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$3.filter)(Checks$3["tag_type"](type), nodes, recurse, limit);
}
legacy$3.getElementsByTagType = getElementsByTagType$3;
var helpers$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$j;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i2, arr) {
      return !arr.includes(node2, i2 + 1);
    });
    nodes.sort(function(a2, b2) {
      var relative = compareDocumentPosition(a2, b2);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers$4);
var feeds$3 = {};
Object.defineProperty(feeds$3, "__esModule", { value: true });
feeds$3.getFeed = void 0;
var stringify_js_1$3 = stringify$8;
var legacy_js_1$3 = legacy$3;
function getFeed$3(doc) {
  var feedRoot = getOneElement$3(isValidFeed$3, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed$3(feedRoot) : getRssFeed$3(feedRoot);
}
feeds$3.getFeed = getFeed$3;
function getAtomFeed$3(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1$3.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements$3(children) };
      addConditionally$3(entry, "id", "id", children);
      addConditionally$3(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement$3("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$3("summary", children) || fetch$3("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$3("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally$3(feed, "id", "id", childs);
  addConditionally$3(feed, "title", "title", childs);
  var href = (_a = getOneElement$3("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$3(feed, "description", "subtitle", childs);
  var updated = fetch$3("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$3(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed$3(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement$3("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1$3.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements$3(children) };
      addConditionally$3(entry, "id", "guid", children);
      addConditionally$3(entry, "title", "title", children);
      addConditionally$3(entry, "link", "link", children);
      addConditionally$3(entry, "description", "description", children);
      var pubDate = fetch$3("pubDate", children) || fetch$3("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally$3(feed, "title", "title", childs);
  addConditionally$3(feed, "link", "link", childs);
  addConditionally$3(feed, "description", "description", childs);
  var updated = fetch$3("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$3(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING$3 = ["url", "type", "lang"];
var MEDIA_KEYS_INT$3 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements$3(where) {
  return (0, legacy_js_1$3.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING$3; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT$3; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement$3(tagName, node2) {
  return (0, legacy_js_1$3.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$3(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1$3.textContent)((0, legacy_js_1$3.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally$3(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch$3(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed$3(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$8, exports2);
  __exportStar(traversal$3, exports2);
  __exportStar(manipulation$4, exports2);
  __exportStar(querying$3, exports2);
  __exportStar(legacy$3, exports2);
  __exportStar(helpers$4, exports2);
  __exportStar(feeds$3, exports2);
  var domhandler_12 = lib$j;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$k);
var __assign$8 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$8 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$8.apply(this, arguments);
};
var __createBinding$8 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$8 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$8 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$8(result, mod, k2);
  }
  __setModuleDefault$8(result, mod);
  return result;
};
Object.defineProperty(_static, "__esModule", { value: true });
_static.merge = _static.contains = _static.root = _static.parseHTML = _static.text = _static.xml = _static.html = void 0;
var domutils_1$4 = lib$k;
var options_js_1$1 = __importStar$8(options);
function render$3(that, dom, options2) {
  if (!that)
    return "";
  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options2).toString();
}
function isOptions(dom, options2) {
  return !options2 && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
}
function html$6(dom, options2) {
  var toRender = isOptions(dom) ? (options2 = dom, void 0) : dom;
  var opts = __assign$8(__assign$8(__assign$8({}, options_js_1$1.default), this === null || this === void 0 ? void 0 : this._options), (0, options_js_1$1.flatten)(options2 !== null && options2 !== void 0 ? options2 : {}));
  return render$3(this, toRender, opts);
}
_static.html = html$6;
function xml$1(dom) {
  var options2 = __assign$8(__assign$8({}, this._options), { xmlMode: true });
  return render$3(this, dom, options2);
}
_static.xml = xml$1;
function text$2(elements) {
  var elems = elements ? elements : this ? this.root() : [];
  var ret = "";
  for (var i2 = 0; i2 < elems.length; i2++) {
    ret += (0, domutils_1$4.textContent)(elems[i2]);
  }
  return ret;
}
_static.text = text$2;
function parseHTML(data2, context, keepScripts) {
  if (keepScripts === void 0) {
    keepScripts = typeof context === "boolean" ? context : false;
  }
  if (!data2 || typeof data2 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  var parsed = this.load(data2, options_js_1$1.default, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return parsed.root()[0].children.slice();
}
_static.parseHTML = parseHTML;
function root$2() {
  return this(this._root);
}
_static.root = root$2;
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  var next = contained;
  while (next && next !== next.parent) {
    next = next.parent;
    if (next === container) {
      return true;
    }
  }
  return false;
}
_static.contains = contains;
function merge$1(arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  var newLength = arr1.length;
  var len = +arr2.length;
  for (var i2 = 0; i2 < len; i2++) {
    arr1[newLength++] = arr2[i2];
  }
  arr1.length = newLength;
  return arr1;
}
_static.merge = merge$1;
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (var i2 = 0; i2 < item.length; i2++) {
    if (!(i2 in item)) {
      return false;
    }
  }
  return true;
}
var cheerio$1 = {};
var attributes$3 = {};
var utils$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isHtml = exports2.cloneDom = exports2.domEach = exports2.cssCase = exports2.camelCase = exports2.isCheerio = exports2.isTag = void 0;
  var domhandler_12 = lib$j;
  var domhandler_2 = lib$j;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_2.isTag;
  } });
  function isCheerio(maybeCheerio) {
    return maybeCheerio.cheerio != null;
  }
  exports2.isCheerio = isCheerio;
  function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function(_2, x2) {
      return x2.toUpperCase();
    });
  }
  exports2.camelCase = camelCase;
  function cssCase(str) {
    return str.replace(/[A-Z]/g, "-$&").toLowerCase();
  }
  exports2.cssCase = cssCase;
  function domEach(array, fn) {
    var len = array.length;
    for (var i2 = 0; i2 < len; i2++)
      fn(array[i2], i2);
    return array;
  }
  exports2.domEach = domEach;
  function cloneDom(dom) {
    var clone2 = "length" in dom ? Array.prototype.map.call(dom, function(el) {
      return (0, domhandler_12.cloneNode)(el, true);
    }) : [(0, domhandler_12.cloneNode)(dom, true)];
    var root2 = new domhandler_12.Document(clone2);
    clone2.forEach(function(node2) {
      node2.parent = root2;
    });
    return clone2;
  }
  exports2.cloneDom = cloneDom;
  var CharacterCodes;
  (function(CharacterCodes2) {
    CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
    CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
    CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
    CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
    CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
  })(CharacterCodes || (CharacterCodes = {}));
  function isHtml(str) {
    var tagStart = str.indexOf("<");
    if (tagStart < 0 || tagStart > str.length - 3)
      return false;
    var tagChar = str.charCodeAt(tagStart + 1);
    return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
  }
  exports2.isHtml = isHtml;
})(utils$2);
Object.defineProperty(attributes$3, "__esModule", { value: true });
attributes$3.toggleClass = attributes$3.removeClass = attributes$3.addClass = attributes$3.hasClass = attributes$3.removeAttr = attributes$3.val = attributes$3.data = attributes$3.prop = attributes$3.attr = void 0;
var static_js_1$2 = _static;
var utils_js_1$5 = utils$2;
var domutils_1$3 = lib$k;
var hasOwn$2 = Object.prototype.hasOwnProperty;
var rspace = /\s+/;
var dataAttrPrefix = "data-";
var primitives = {
  null: null,
  true: true,
  false: false
};
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name2, xmlMode) {
  var _a;
  if (!elem || !(0, utils_js_1$5.isTag)(elem))
    return void 0;
  (_a = elem.attribs) !== null && _a !== void 0 ? _a : elem.attribs = {};
  if (!name2) {
    return elem.attribs;
  }
  if (hasOwn$2.call(elem.attribs, name2)) {
    return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
  }
  if (elem.name === "option" && name2 === "value") {
    return (0, static_js_1$2.text)(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name2, value) {
  if (value === null) {
    removeAttribute(el, name2);
  } else {
    el.attribs[name2] = "".concat(value);
  }
}
function attr(name2, value) {
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return (0, utils_js_1$5.domEach)(this, function(el, i2) {
        if ((0, utils_js_1$5.isTag)(el))
          setAttr(el, name2, value.call(el, i2, el.attribs[name2]));
      });
    }
    return (0, utils_js_1$5.domEach)(this, function(el) {
      if (!(0, utils_js_1$5.isTag)(el))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach(function(objName) {
          var objValue = name2[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name2, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
}
attributes$3.attr = attr;
function getProp(el, name2, xmlMode) {
  return name2 in el ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el[name2]
  ) : !xmlMode && rboolean.test(name2) ? getAttr(el, name2, false) !== void 0 : getAttr(el, name2, xmlMode);
}
function setProp(el, name2, value, xmlMode) {
  if (name2 in el) {
    el[name2] = value;
  } else {
    setAttr(el, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : "".concat(value));
  }
}
function prop(name2, value) {
  var _this = this;
  var _a;
  if (typeof name2 === "string" && value === void 0) {
    var el = this[0];
    if (!el || !(0, utils_js_1$5.isTag)(el))
      return void 0;
    switch (name2) {
      case "style": {
        var property_1 = this.css();
        var keys2 = Object.keys(property_1);
        keys2.forEach(function(p2, i2) {
          property_1[i2] = p2;
        });
        property_1.length = keys2.length;
        return property_1;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        var prop_1 = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name2];
        if (typeof URL !== "undefined" && (name2 === "href" && (el.tagName === "a" || el.name === "link") || name2 === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop_1 !== void 0 && this.options.baseURI) {
          return new URL(prop_1, this.options.baseURI).href;
        }
        return prop_1;
      }
      case "innerText": {
        return (0, domutils_1$3.innerText)(el);
      }
      case "textContent": {
        return (0, domutils_1$3.textContent)(el);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el, name2, this.options.xmlMode);
    }
  }
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return (0, utils_js_1$5.domEach)(this, function(el2, i2) {
        if ((0, utils_js_1$5.isTag)(el2)) {
          setProp(el2, name2, value.call(el2, i2, getProp(el2, name2, _this.options.xmlMode)), _this.options.xmlMode);
        }
      });
    }
    return (0, utils_js_1$5.domEach)(this, function(el2) {
      if (!(0, utils_js_1$5.isTag)(el2))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach(function(key2) {
          var val2 = name2[key2];
          setProp(el2, key2, val2, _this.options.xmlMode);
        });
      } else {
        setProp(el2, name2, value, _this.options.xmlMode);
      }
    });
  }
  return void 0;
}
attributes$3.prop = prop;
function setData(el, name2, value) {
  var _a;
  var elem = el;
  (_a = elem.data) !== null && _a !== void 0 ? _a : elem.data = {};
  if (typeof name2 === "object")
    Object.assign(elem.data, name2);
  else if (typeof name2 === "string" && value !== void 0) {
    elem.data[name2] = value;
  }
}
function readData(el, name2) {
  var domNames;
  var jsNames;
  var value;
  if (name2 == null) {
    domNames = Object.keys(el.attribs).filter(function(attrName) {
      return attrName.startsWith(dataAttrPrefix);
    });
    jsNames = domNames.map(function(domName2) {
      return (0, utils_js_1$5.camelCase)(domName2.slice(dataAttrPrefix.length));
    });
  } else {
    domNames = [dataAttrPrefix + (0, utils_js_1$5.cssCase)(name2)];
    jsNames = [name2];
  }
  for (var idx = 0; idx < domNames.length; ++idx) {
    var domName = domNames[idx];
    var jsName = jsNames[idx];
    if (hasOwn$2.call(el.attribs, domName) && !hasOwn$2.call(el.data, jsName)) {
      value = el.attribs[domName];
      if (hasOwn$2.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e2) {
        }
      }
      el.data[jsName] = value;
    }
  }
  return name2 == null ? el.data : value;
}
function data(name2, value) {
  var _a;
  var elem = this[0];
  if (!elem || !(0, utils_js_1$5.isTag)(elem))
    return;
  var dataEl = elem;
  (_a = dataEl.data) !== null && _a !== void 0 ? _a : dataEl.data = {};
  if (!name2) {
    return readData(dataEl);
  }
  if (typeof name2 === "object" || value !== void 0) {
    (0, utils_js_1$5.domEach)(this, function(el) {
      if ((0, utils_js_1$5.isTag)(el)) {
        if (typeof name2 === "object")
          setData(el, name2);
        else
          setData(el, name2, value);
      }
    });
    return this;
  }
  if (hasOwn$2.call(dataEl.data, name2)) {
    return dataEl.data[name2];
  }
  return readData(dataEl, name2);
}
attributes$3.data = data;
function val(value) {
  var querying2 = arguments.length === 0;
  var element2 = this[0];
  if (!element2 || !(0, utils_js_1$5.isTag)(element2))
    return querying2 ? void 0 : this;
  switch (element2.name) {
    case "textarea":
      return this.text(value);
    case "select": {
      var option2 = this.find("option:selected");
      if (!querying2) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        var values = typeof value !== "object" ? [value] : value;
        for (var i2 = 0; i2 < values.length; i2++) {
          this.find('option[value="'.concat(values[i2], '"]')).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option2.toArray().map(function(el) {
        return (0, static_js_1$2.text)(el.children);
      }) : option2.attr("value");
    }
    case "input":
    case "option":
      return querying2 ? this.attr("value") : this.attr("value", value);
  }
  return void 0;
}
attributes$3.val = val;
function removeAttribute(elem, name2) {
  if (!elem.attribs || !hasOwn$2.call(elem.attribs, name2))
    return;
  delete elem.attribs[name2];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name2) {
  var attrNames = splitNames(name2);
  var _loop_1 = function(i3) {
    (0, utils_js_1$5.domEach)(this_1, function(elem) {
      if ((0, utils_js_1$5.isTag)(elem))
        removeAttribute(elem, attrNames[i3]);
    });
  };
  var this_1 = this;
  for (var i2 = 0; i2 < attrNames.length; i2++) {
    _loop_1(i2);
  }
  return this;
}
attributes$3.removeAttr = removeAttr;
function hasClass(className2) {
  return this.toArray().some(function(elem) {
    var clazz = (0, utils_js_1$5.isTag)(elem) && elem.attribs["class"];
    var idx = -1;
    if (clazz && className2.length) {
      while ((idx = clazz.indexOf(className2, idx + 1)) > -1) {
        var end2 = idx + className2.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
attributes$3.hasClass = hasClass;
function addClass(value) {
  if (typeof value === "function") {
    return (0, utils_js_1$5.domEach)(this, function(el2, i3) {
      if ((0, utils_js_1$5.isTag)(el2)) {
        var className3 = el2.attribs["class"] || "";
        addClass.call([el2], value.call(el2, i3, className3));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  var classNames = value.split(rspace);
  var numElements = this.length;
  for (var i2 = 0; i2 < numElements; i2++) {
    var el = this[i2];
    if (!(0, utils_js_1$5.isTag)(el))
      continue;
    var className2 = getAttr(el, "class", false);
    if (!className2) {
      setAttr(el, "class", classNames.join(" ").trim());
    } else {
      var setClass = " ".concat(className2, " ");
      for (var j2 = 0; j2 < classNames.length; j2++) {
        var appendClass = "".concat(classNames[j2], " ");
        if (!setClass.includes(" ".concat(appendClass)))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    }
  }
  return this;
}
attributes$3.addClass = addClass;
function removeClass(name2) {
  if (typeof name2 === "function") {
    return (0, utils_js_1$5.domEach)(this, function(el, i2) {
      if ((0, utils_js_1$5.isTag)(el)) {
        removeClass.call([el], name2.call(el, i2, el.attribs["class"] || ""));
      }
    });
  }
  var classes = splitNames(name2);
  var numClasses = classes.length;
  var removeAll = arguments.length === 0;
  return (0, utils_js_1$5.domEach)(this, function(el) {
    if (!(0, utils_js_1$5.isTag)(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      var elClasses = splitNames(el.attribs["class"]);
      var changed = false;
      for (var j2 = 0; j2 < numClasses; j2++) {
        var index2 = elClasses.indexOf(classes[j2]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j2--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
attributes$3.removeClass = removeClass;
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return (0, utils_js_1$5.domEach)(this, function(el2, i3) {
      if ((0, utils_js_1$5.isTag)(el2)) {
        toggleClass.call([el2], value.call(el2, i3, el2.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  var classNames = value.split(rspace);
  var numClasses = classNames.length;
  var state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  var numElements = this.length;
  for (var i2 = 0; i2 < numElements; i2++) {
    var el = this[i2];
    if (!(0, utils_js_1$5.isTag)(el))
      continue;
    var elementClasses = splitNames(el.attribs["class"]);
    for (var j2 = 0; j2 < numClasses; j2++) {
      var index2 = elementClasses.indexOf(classNames[j2]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j2]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}
attributes$3.toggleClass = toggleClass;
var traversing = {};
var lib$f = {};
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
const IgnoreCaseMode = {
  Unknown: null,
  QuirksMode: "quirks",
  IgnoreCase: true,
  CaseSensitive: false
};
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
const unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal$1(selector2) {
  switch (selector2.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_2, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c2) {
  return c2 === 39 || c2 === 34;
}
function isWhitespace$1(c2) {
  return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
}
function parse$7(selector2) {
  const subselects2 = [];
  const endIndex = parseSelector$1(subselects2, `${selector2}`, 0);
  if (endIndex < selector2.length) {
    throw new Error(`Unmatched selector: ${selector2.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector$1(subselects2, selector2, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match = selector2.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector2.slice(selectorIndex)}`);
    }
    const [name2] = match;
    selectorIndex += offset + name2.length;
    return unescapeCSS(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector2.length && isWhitespace$1(selector2.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector2.length; selectorIndex++) {
      if (selector2.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector2.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector2.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector2.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector2.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector2.length) {
      const firstChar = selector2.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace = null;
          if (selector2.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector2.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector2.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector2.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector2.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector2.charCodeAt(selectorIndex))) {
              const quote = selector2.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector2.length && (selector2.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector2.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector2.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector2.length && (!isWhitespace$1(selector2.charCodeAt(selectorIndex)) && selector2.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector2.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector2.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector2.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector2.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector2.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector2.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name2)) {
              if (isQuote(selector2.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector$1(data2, selector2, selectorIndex + 1);
              if (selector2.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector2})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name2)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector2.startsWith("/*", selectorIndex)) {
            const endIndex = selector2.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector2.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector2.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name2;
            if (selector2.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map((c2) => c2.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c2) => c2.charCodeAt(0)));
const charsToEscapeInName = new Set([
  ...pseudoValChars,
  "~",
  "^",
  "$",
  "*",
  "+",
  "!",
  "|",
  ":",
  "[",
  "]",
  " ",
  "."
].map((c2) => c2.charCodeAt(0)));
function stringify$7(selector2) {
  return selector2.map((token2) => token2.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token2, index2, arr) {
  switch (token2.type) {
    case SelectorType.Child:
      return index2 === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index2 === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index2 === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index2 === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index2 === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      return token2.namespace === "*" && index2 + 1 < arr.length && "name" in arr[index2 + 1] ? "" : `${getNamespace(token2.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token2);
    case SelectorType.PseudoElement:
      return `::${escapeName(token2.name, charsToEscapeInName)}${token2.data === null ? "" : `(${escapeName(token2.data, charsToEscapeInPseudoValue)})`}`;
    case SelectorType.Pseudo:
      return `:${escapeName(token2.name, charsToEscapeInName)}${token2.data === null ? "" : `(${typeof token2.data === "string" ? escapeName(token2.data, charsToEscapeInPseudoValue) : stringify$7(token2.data)})`}`;
    case SelectorType.Attribute: {
      if (token2.name === "id" && token2.action === AttributeAction.Equals && token2.ignoreCase === "quirks" && !token2.namespace) {
        return `#${escapeName(token2.value, charsToEscapeInName)}`;
      }
      if (token2.name === "class" && token2.action === AttributeAction.Element && token2.ignoreCase === "quirks" && !token2.namespace) {
        return `.${escapeName(token2.value, charsToEscapeInName)}`;
      }
      const name2 = getNamespacedName(token2);
      if (token2.action === AttributeAction.Exists) {
        return `[${name2}]`;
      }
      return `[${name2}${getActionValue(token2.action)}="${escapeName(token2.value, charsToEscapeInAttributeValue)}"${token2.ignoreCase === null ? "" : token2.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token2) {
  return `${getNamespace(token2.namespace)}${escapeName(token2.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|` : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    if (charsToEscape.has(str.charCodeAt(i2))) {
      ret += `${str.slice(lastIdx, i2)}\\${str.charAt(i2)}`;
      lastIdx = i2 + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get AttributeAction() {
    return AttributeAction;
  },
  IgnoreCaseMode,
  get SelectorType() {
    return SelectorType;
  },
  isTraversal: isTraversal$1,
  parse: parse$7,
  stringify: stringify$7
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(es);
var lib$e = {};
var lib$d = {};
var stringify$6 = {};
var lib$c = {};
var node$3 = {};
var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$7 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$7 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$7.apply(this, arguments);
};
Object.defineProperty(node$3, "__esModule", { value: true });
node$3.cloneNode = node$3.hasChildren = node$3.isDocument = node$3.isDirective = node$3.isComment = node$3.isText = node$3.isCDATA = node$3.isTag = node$3.Element = node$3.Document = node$3.CDATA = node$3.NodeWithChildren = node$3.ProcessingInstruction = node$3.Comment = node$3.Text = node$3.DataNode = node$3.Node = void 0;
var domelementtype_1$6 = lib$i;
var Node$3 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$3(this, recursive);
    };
    return Node2;
  }()
);
node$3.Node = Node$3;
var DataNode$3 = (
  /** @class */
  function(_super) {
    __extends$4(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$3)
);
node$3.DataNode = DataNode$3;
var Text$3 = (
  /** @class */
  function(_super) {
    __extends$4(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$3)
);
node$3.Text = Text$3;
var Comment$3 = (
  /** @class */
  function(_super) {
    __extends$4(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$3)
);
node$3.Comment = Comment$3;
var ProcessingInstruction$3 = (
  /** @class */
  function(_super) {
    __extends$4(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$6.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$3)
);
node$3.ProcessingInstruction = ProcessingInstruction$3;
var NodeWithChildren$3 = (
  /** @class */
  function(_super) {
    __extends$4(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$3)
);
node$3.NodeWithChildren = NodeWithChildren$3;
var CDATA$3 = (
  /** @class */
  function(_super) {
    __extends$4(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$3)
);
node$3.CDATA = CDATA$3;
var Document$3 = (
  /** @class */
  function(_super) {
    __extends$4(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$6.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$3)
);
node$3.Document = Document$3;
var Element$3 = (
  /** @class */
  function(_super) {
    __extends$4(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$6.ElementType.Script : name2 === "style" ? domelementtype_1$6.ElementType.Style : domelementtype_1$6.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$3)
);
node$3.Element = Element$3;
function isTag$3(node2) {
  return (0, domelementtype_1$6.isTag)(node2);
}
node$3.isTag = isTag$3;
function isCDATA$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.CDATA;
}
node$3.isCDATA = isCDATA$3;
function isText$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Text;
}
node$3.isText = isText$3;
function isComment$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Comment;
}
node$3.isComment = isComment$3;
function isDirective$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Directive;
}
node$3.isDirective = isDirective$3;
function isDocument$3(node2) {
  return node2.type === domelementtype_1$6.ElementType.Root;
}
node$3.isDocument = isDocument$3;
function hasChildren$3(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$3.hasChildren = hasChildren$3;
function cloneNode$3(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$3(node2)) {
    result = new Text$3(node2.data);
  } else if (isComment$3(node2)) {
    result = new Comment$3(node2.data);
  } else if (isTag$3(node2)) {
    var children = recursive ? cloneChildren$3(node2.children) : [];
    var clone_1 = new Element$3(node2.name, __assign$7({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$7({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$7({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$3(node2)) {
    var children = recursive ? cloneChildren$3(node2.children) : [];
    var clone_2 = new CDATA$3(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$3(node2)) {
    var children = recursive ? cloneChildren$3(node2.children) : [];
    var clone_3 = new Document$3(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$3(node2)) {
    var instruction = new ProcessingInstruction$3(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$3.cloneNode = cloneNode$3;
function cloneChildren$3(childs) {
  var children = childs.map(function(child) {
    return cloneNode$3(child, true);
  });
  for (var i2 = 1; i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$3;
  __exportStar(node$3, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$c);
var lib$b = {};
var lib$a = {};
var decode$3 = {};
var decodeDataHtml$3 = {};
Object.defineProperty(decodeDataHtml$3, "__esModule", { value: true });
decodeDataHtml$3.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decodeDataXml$3 = {};
Object.defineProperty(decodeDataXml$3, "__esModule", { value: true });
decodeDataXml$3.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decode_codepoint$3 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$3);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$3);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$3);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$3);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$3;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$3);
var encode$2 = {};
var encodeHtml$2 = {};
Object.defineProperty(encodeHtml$2, "__esModule", { value: true });
function restoreDiff$2(arr) {
  for (var i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
encodeHtml$2.default = new Map(/* @__PURE__ */ restoreDiff$2([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff$2([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff$2([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff$2([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape$3 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c2, index2) {
      return (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i2 = match.index;
      var char = str.charCodeAt(i2);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i2) + next;
        lastIdx = i2 + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports2.getCodePoint)(str, i2).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$3);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode$2, "__esModule", { value: true });
encode$2.encodeNonAsciiHTML = encode$2.encodeHTML = void 0;
var encode_html_js_1$2 = __importDefault$7(encodeHtml$2);
var escape_js_1$3 = _escape$3;
var htmlReplacer$2 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML$2(data2) {
  return encodeHTMLTrieRe$2(htmlReplacer$2, data2);
}
encode$2.encodeHTML = encodeHTML$2;
function encodeNonAsciiHTML$2(data2) {
  return encodeHTMLTrieRe$2(escape_js_1$3.xmlReplacer, data2);
}
encode$2.encodeNonAsciiHTML = encodeNonAsciiHTML$2;
function encodeHTMLTrieRe$2(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i2 = match.index;
    ret += str.substring(lastIdx, i2);
    var char = str.charCodeAt(i2);
    var next = encode_html_js_1$2.default.get(char);
    if (typeof next === "object") {
      if (i2 + 1 < str.length) {
        var nextChar = str.charCodeAt(i2 + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i2 + 1;
    } else {
      var cp = (0, escape_js_1$3.getCodePoint)(str, i2);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode$3;
  var encode_js_1 = encode$2;
  var escape_js_12 = _escape$3;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode2;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode2(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode2;
  var escape_js_2 = _escape$3;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode$2;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode$3;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib$a);
var foreignNames$2 = {};
Object.defineProperty(foreignNames$2, "__esModule", { value: true });
foreignNames$2.attributeNames = foreignNames$2.elementNames = void 0;
foreignNames$2.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames$2.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign$6 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var __createBinding$7 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$7 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$7 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$7(result, mod, k2);
  }
  __setModuleDefault$7(result, mod);
  return result;
};
Object.defineProperty(lib$b, "__esModule", { value: true });
lib$b.render = void 0;
var ElementType$2 = __importStar$7(lib$i);
var entities_1$2 = lib$a;
var foreignNames_js_1$2 = foreignNames$2;
var unencodedElements$2 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes$2(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes$2(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes$2 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1$2.encodeXML : entities_1$2.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1$2.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag$2 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$2(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode$2(nodes[i2], options2);
  }
  return output;
}
lib$b.render = render$2;
lib$b.default = render$2;
function renderNode$2(node2, options2) {
  switch (node2.type) {
    case ElementType$2.Root:
      return render$2(node2.children, options2);
    case ElementType$2.Doctype:
    case ElementType$2.Directive:
      return renderDirective$2(node2);
    case ElementType$2.Comment:
      return renderComment$2(node2);
    case ElementType$2.CDATA:
      return renderCdata$2(node2);
    case ElementType$2.Script:
    case ElementType$2.Style:
    case ElementType$2.Tag:
      return renderTag$2(node2, options2);
    case ElementType$2.Text:
      return renderText$2(node2, options2);
  }
}
var foreignModeIntegrationPoints$2 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements$2 = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$2(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1$2.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints$2.has(elem.parent.name)) {
      opts = __assign$6(__assign$6({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$2.has(elem.name)) {
    opts = __assign$6(__assign$6({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$2(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$2.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$2(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$2.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$2(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$2(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$2.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1$2.encodeXML)(data2) : (0, entities_1$2.escapeText)(data2);
  }
  return data2;
}
function renderCdata$2(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$2(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$6, "__esModule", { value: true });
stringify$6.innerText = stringify$6.textContent = stringify$6.getText = stringify$6.getInnerHTML = stringify$6.getOuterHTML = void 0;
var domhandler_1$f = lib$c;
var dom_serializer_1$2 = __importDefault$6(lib$b);
var domelementtype_1$5 = lib$i;
function getOuterHTML$2(node2, options2) {
  return (0, dom_serializer_1$2.default)(node2, options2);
}
stringify$6.getOuterHTML = getOuterHTML$2;
function getInnerHTML$2(node2, options2) {
  return (0, domhandler_1$f.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML$2(node3, options2);
  }).join("") : "";
}
stringify$6.getInnerHTML = getInnerHTML$2;
function getText$2(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$2).join("");
  if ((0, domhandler_1$f.isTag)(node2))
    return node2.name === "br" ? "\n" : getText$2(node2.children);
  if ((0, domhandler_1$f.isCDATA)(node2))
    return getText$2(node2.children);
  if ((0, domhandler_1$f.isText)(node2))
    return node2.data;
  return "";
}
stringify$6.getText = getText$2;
function textContent$2(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent$2).join("");
  if ((0, domhandler_1$f.hasChildren)(node2) && !(0, domhandler_1$f.isComment)(node2)) {
    return textContent$2(node2.children);
  }
  if ((0, domhandler_1$f.isText)(node2))
    return node2.data;
  return "";
}
stringify$6.textContent = textContent$2;
function innerText$2(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText$2).join("");
  if ((0, domhandler_1$f.hasChildren)(node2) && (node2.type === domelementtype_1$5.ElementType.Tag || (0, domhandler_1$f.isCDATA)(node2))) {
    return innerText$2(node2.children);
  }
  if ((0, domhandler_1$f.isText)(node2))
    return node2.data;
  return "";
}
stringify$6.innerText = innerText$2;
var traversal$2 = {};
Object.defineProperty(traversal$2, "__esModule", { value: true });
traversal$2.prevElementSibling = traversal$2.nextElementSibling = traversal$2.getName = traversal$2.hasAttrib = traversal$2.getAttributeValue = traversal$2.getSiblings = traversal$2.getParent = traversal$2.getChildren = void 0;
var domhandler_1$e = lib$c;
function getChildren$2(elem) {
  return (0, domhandler_1$e.hasChildren)(elem) ? elem.children : [];
}
traversal$2.getChildren = getChildren$2;
function getParent$2(elem) {
  return elem.parent || null;
}
traversal$2.getParent = getParent$2;
function getSiblings$2(elem) {
  var _a, _b;
  var parent = getParent$2(elem);
  if (parent != null)
    return getChildren$2(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal$2.getSiblings = getSiblings$2;
function getAttributeValue$2(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal$2.getAttributeValue = getAttributeValue$2;
function hasAttrib$2(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal$2.hasAttrib = hasAttrib$2;
function getName$2(elem) {
  return elem.name;
}
traversal$2.getName = getName$2;
function nextElementSibling$2(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$e.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal$2.nextElementSibling = nextElementSibling$2;
function prevElementSibling$2(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$e.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal$2.prevElementSibling = prevElementSibling$2;
var manipulation$3 = {};
Object.defineProperty(manipulation$3, "__esModule", { value: true });
manipulation$3.prepend = manipulation$3.prependChild = manipulation$3.append = manipulation$3.appendChild = manipulation$3.replaceElement = manipulation$3.removeElement = void 0;
function removeElement$2(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation$3.removeElement = removeElement$2;
function replaceElement$2(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation$3.replaceElement = replaceElement$2;
function appendChild$2(parent, child) {
  removeElement$2(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation$3.appendChild = appendChild$2;
function append$2(elem, next) {
  removeElement$2(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation$3.append = append$2;
function prependChild$2(parent, child) {
  removeElement$2(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation$3.prependChild = prependChild$2;
function prepend$2(elem, prev) {
  removeElement$2(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation$3.prepend = prepend$2;
var querying$2 = {};
Object.defineProperty(querying$2, "__esModule", { value: true });
querying$2.findAll = querying$2.existsOne = querying$2.findOne = querying$2.findOneChild = querying$2.find = querying$2.filter = void 0;
var domhandler_1$d = lib$c;
function filter$3(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$4(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying$2.filter = filter$3;
function find$4(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$d.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$2.find = find$4;
function findOneChild$2(test2, nodes) {
  return nodes.find(test2);
}
querying$2.findOneChild = findOneChild$2;
function findOne$2(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
    var node2 = nodes[i2];
    if (!(0, domhandler_1$d.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne$2(test2, node2.children, true);
    }
  }
  return elem;
}
querying$2.findOne = findOne$2;
function existsOne$2(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$d.isTag)(checked2) && (test2(checked2) || existsOne$2(test2, checked2.children));
  });
}
querying$2.existsOne = existsOne$2;
function findAll$2(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$d.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$2.findAll = findAll$2;
var legacy$2 = {};
Object.defineProperty(legacy$2, "__esModule", { value: true });
legacy$2.getElementsByTagType = legacy$2.getElementsByTagName = legacy$2.getElementById = legacy$2.getElements = legacy$2.testElement = void 0;
var domhandler_1$c = lib$c;
var querying_js_1$2 = querying$2;
var Checks$2 = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1$c.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1$c.isTag;
    }
    return function(elem) {
      return (0, domhandler_1$c.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1$c.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1$c.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck$2(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1$c.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1$c.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs$2(a2, b2) {
  return function(elem) {
    return a2(elem) || b2(elem);
  };
}
function compileTest$2(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks$2, key2) ? Checks$2[key2](value) : getAttribCheck$2(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$2);
}
function testElement$2(options2, node2) {
  var test2 = compileTest$2(options2);
  return test2 ? test2(node2) : true;
}
legacy$2.testElement = testElement$2;
function getElements$2(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest$2(options2);
  return test2 ? (0, querying_js_1$2.filter)(test2, nodes, recurse, limit) : [];
}
legacy$2.getElements = getElements$2;
function getElementById$2(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1$2.findOne)(getAttribCheck$2("id", id2), nodes, recurse);
}
legacy$2.getElementById = getElementById$2;
function getElementsByTagName$2(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$2.filter)(Checks$2["tag_name"](tagName), nodes, recurse, limit);
}
legacy$2.getElementsByTagName = getElementsByTagName$2;
function getElementsByTagType$2(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$2.filter)(Checks$2["tag_type"](type), nodes, recurse, limit);
}
legacy$2.getElementsByTagType = getElementsByTagType$2;
var helpers$3 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$c;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i2, arr) {
      return !arr.includes(node2, i2 + 1);
    });
    nodes.sort(function(a2, b2) {
      var relative = compareDocumentPosition(a2, b2);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers$3);
var feeds$2 = {};
Object.defineProperty(feeds$2, "__esModule", { value: true });
feeds$2.getFeed = void 0;
var stringify_js_1$2 = stringify$6;
var legacy_js_1$2 = legacy$2;
function getFeed$2(doc) {
  var feedRoot = getOneElement$2(isValidFeed$2, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed$2(feedRoot) : getRssFeed$2(feedRoot);
}
feeds$2.getFeed = getFeed$2;
function getAtomFeed$2(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1$2.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements$2(children) };
      addConditionally$2(entry, "id", "id", children);
      addConditionally$2(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement$2("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$2("summary", children) || fetch$2("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$2("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally$2(feed, "id", "id", childs);
  addConditionally$2(feed, "title", "title", childs);
  var href = (_a = getOneElement$2("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$2(feed, "description", "subtitle", childs);
  var updated = fetch$2("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$2(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed$2(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement$2("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1$2.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements$2(children) };
      addConditionally$2(entry, "id", "guid", children);
      addConditionally$2(entry, "title", "title", children);
      addConditionally$2(entry, "link", "link", children);
      addConditionally$2(entry, "description", "description", children);
      var pubDate = fetch$2("pubDate", children) || fetch$2("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally$2(feed, "title", "title", childs);
  addConditionally$2(feed, "link", "link", childs);
  addConditionally$2(feed, "description", "description", childs);
  var updated = fetch$2("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$2(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING$2 = ["url", "type", "lang"];
var MEDIA_KEYS_INT$2 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements$2(where) {
  return (0, legacy_js_1$2.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING$2; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT$2; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement$2(tagName, node2) {
  return (0, legacy_js_1$2.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$2(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1$2.textContent)((0, legacy_js_1$2.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally$2(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch$2(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed$2(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$6, exports2);
  __exportStar(traversal$2, exports2);
  __exportStar(manipulation$3, exports2);
  __exportStar(querying$2, exports2);
  __exportStar(legacy$2, exports2);
  __exportStar(helpers$3, exports2);
  __exportStar(feeds$2, exports2);
  var domhandler_12 = lib$c;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$d);
var boolbase = {
  trueFunc: function trueFunc() {
    return true;
  },
  falseFunc: function falseFunc() {
    return false;
  }
};
const boolbase$1 = /* @__PURE__ */ getDefaultExportFromCjs(boolbase);
var compile$2 = {};
var sort = {};
Object.defineProperty(sort, "__esModule", { value: true });
sort.isTraversal = void 0;
var css_what_1$2 = require$$0$1;
var procedure = /* @__PURE__ */ new Map([
  [css_what_1$2.SelectorType.Universal, 50],
  [css_what_1$2.SelectorType.Tag, 30],
  [css_what_1$2.SelectorType.Attribute, 1],
  [css_what_1$2.SelectorType.Pseudo, 0]
]);
function isTraversal(token2) {
  return !procedure.has(token2.type);
}
sort.isTraversal = isTraversal;
var attributes$2 = /* @__PURE__ */ new Map([
  [css_what_1$2.AttributeAction.Exists, 10],
  [css_what_1$2.AttributeAction.Equals, 8],
  [css_what_1$2.AttributeAction.Not, 7],
  [css_what_1$2.AttributeAction.Start, 6],
  [css_what_1$2.AttributeAction.End, 6],
  [css_what_1$2.AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  var procs = arr.map(getProcedure);
  for (var i2 = 1; i2 < arr.length; i2++) {
    var procNew = procs[i2];
    if (procNew < 0)
      continue;
    for (var j2 = i2 - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
      var token2 = arr[j2 + 1];
      arr[j2 + 1] = arr[j2];
      arr[j2] = token2;
      procs[j2 + 1] = procs[j2];
      procs[j2] = procNew;
    }
  }
}
sort.default = sortByProcedure;
function getProcedure(token2) {
  var _a, _b;
  var proc2 = (_a = procedure.get(token2.type)) !== null && _a !== void 0 ? _a : -1;
  if (token2.type === css_what_1$2.SelectorType.Attribute) {
    proc2 = (_b = attributes$2.get(token2.action)) !== null && _b !== void 0 ? _b : 4;
    if (token2.action === css_what_1$2.AttributeAction.Equals && token2.name === "id") {
      proc2 = 9;
    }
    if (token2.ignoreCase) {
      proc2 >>= 1;
    }
  } else if (token2.type === css_what_1$2.SelectorType.Pseudo) {
    if (!token2.data) {
      proc2 = 3;
    } else if (token2.name === "has" || token2.name === "contains") {
      proc2 = 0;
    } else if (Array.isArray(token2.data)) {
      proc2 = Math.min.apply(Math, token2.data.map(function(d2) {
        return Math.min.apply(Math, d2.map(getProcedure));
      }));
      if (proc2 < 0) {
        proc2 = 0;
      }
    } else {
      proc2 = 2;
    }
  }
  return proc2;
}
var general = {};
var attributes$1 = {};
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(attributes$1, "__esModule", { value: true });
attributes$1.attributeRules = void 0;
var boolbase_1$1 = __importDefault$5(boolbase);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector2, options2) {
  return typeof selector2.ignoreCase === "boolean" ? selector2.ignoreCase : selector2.ignoreCase === "quirks" ? !!options2.quirksMode : !options2.xmlMode && caseInsensitiveAttributes.has(selector2.name);
}
attributes$1.attributeRules = {
  equals: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next(elem);
      };
    }
    return function(elem) {
      return adapter.getAttributeValue(elem, name2) === value && next(elem);
    };
  },
  hyphen: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    var len = value.length;
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function hyphen(elem) {
      var attr2 = adapter.getAttributeValue(elem, name2);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next(elem);
    };
  },
  element: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name, value = data2.value;
    if (/\s/.test(value)) {
      return boolbase_1$1.default.falseFunc;
    }
    var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data2, options2) ? "i" : "");
    return function element2(elem) {
      var attr2 = adapter.getAttributeValue(elem, name2);
      return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next(elem);
    };
  },
  exists: function(next, _a, _b) {
    var name2 = _a.name;
    var adapter = _b.adapter;
    return function(elem) {
      return adapter.hasAttrib(elem, name2) && next(elem);
    };
  },
  start: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    var len = value.length;
    if (len === 0) {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function(elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
    };
  },
  end: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    var len = -value.length;
    if (len === 0) {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var _a;
        return ((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
      };
    }
    return function(elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
    };
  },
  any: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name, value = data2.value;
    if (value === "") {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      var regex_1 = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex_1.test(attr2) && next(elem);
      };
    }
    return function(elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
    };
  },
  not: function(next, data2, options2) {
    var adapter = options2.adapter;
    var name2 = data2.name;
    var value = data2.value;
    if (value === "") {
      return function(elem) {
        return !!adapter.getAttributeValue(elem, name2) && next(elem);
      };
    } else if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function(elem) {
        var attr2 = adapter.getAttributeValue(elem, name2);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next(elem);
      };
    }
    return function(elem) {
      return adapter.getAttributeValue(elem, name2) !== value && next(elem);
    };
  }
};
var pseudoSelectors = {};
var filters = {};
const whitespace$1 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$6(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a2 = 0;
  let sign = readSign();
  let number2 = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a2 = sign * (number2 !== null && number2 !== void 0 ? number2 : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number2 = readNumber();
    } else {
      sign = number2 = 0;
    }
  }
  if (number2 === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a2, sign * number2];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace$1.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile$1(parsed) {
  const a2 = parsed[0];
  const b2 = parsed[1] - 1;
  if (b2 < 0 && a2 <= 0)
    return boolbase$1.falseFunc;
  if (a2 === -1)
    return (index2) => index2 <= b2;
  if (a2 === 0)
    return (index2) => index2 === b2;
  if (a2 === 1)
    return b2 < 0 ? boolbase$1.trueFunc : (index2) => index2 >= b2;
  const absA = Math.abs(a2);
  const bMod = (b2 % absA + absA) % absA;
  return a2 > 1 ? (index2) => index2 >= b2 && index2 % absA === bMod : (index2) => index2 <= b2 && index2 % absA === bMod;
}
function generate(parsed) {
  const a2 = parsed[0];
  let b2 = parsed[1] - 1;
  let n2 = 0;
  if (a2 < 0) {
    const aPos = -a2;
    const minValue = (b2 % aPos + aPos) % aPos;
    return () => {
      const val2 = minValue + aPos * n2++;
      return val2 > b2 ? null : val2;
    };
  }
  if (a2 === 0)
    return b2 < 0 ? (
      // There are no result  always return `null`
      () => null
    ) : (
      // Return `b` exactly once
      () => n2++ === 0 ? b2 : null
    );
  if (b2 < 0) {
    b2 += a2 * Math.ceil(-b2 / a2);
  }
  return () => a2 * n2++ + b2;
}
function nthCheck$1(formula) {
  return compile$1(parse$6(formula));
}
function sequence(formula) {
  return generate(parse$6(formula));
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile: compile$1,
  default: nthCheck$1,
  generate,
  parse: parse$6,
  sequence
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esm);
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.filters = void 0;
  var nth_check_1 = __importDefault2(require$$0);
  var boolbase_12 = __importDefault2(boolbase);
  function getChildFunc(next, adapter) {
    return function(elem) {
      var parent = adapter.getParent(elem);
      return parent != null && adapter.isTag(parent) && next(elem);
    };
  }
  exports2.filters = {
    contains: function(next, text2, _a) {
      var adapter = _a.adapter;
      return function contains2(elem) {
        return next(elem) && adapter.getText(elem).includes(text2);
      };
    },
    icontains: function(next, text2, _a) {
      var adapter = _a.adapter;
      var itext = text2.toLowerCase();
      return function icontains(elem) {
        return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
      };
    },
    // Location specific methods
    "nth-child": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthChild2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i2 = 0; i2 < siblings2.length; i2++) {
          if (equals(elem, siblings2[i2]))
            break;
          if (adapter.isTag(siblings2[i2])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-child": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastChild2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i2 = siblings2.length - 1; i2 >= 0; i2--) {
          if (equals(elem, siblings2[i2]))
            break;
          if (adapter.isTag(siblings2[i2])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-of-type": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthOfType2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i2 = 0; i2 < siblings2.length; i2++) {
          var currentSibling = siblings2[i2];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-of-type": function(next, rule, _a) {
      var adapter = _a.adapter, equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      if (func === boolbase_12.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastOfType2(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var pos = 0;
        for (var i2 = siblings2.length - 1; i2 >= 0; i2--) {
          var currentSibling = siblings2[i2];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    // TODO determine the actual root element
    root: function(next, _rule, _a) {
      var adapter = _a.adapter;
      return function(elem) {
        var parent = adapter.getParent(elem);
        return (parent == null || !adapter.isTag(parent)) && next(elem);
      };
    },
    scope: function(next, rule, options2, context) {
      var equals = options2.equals;
      if (!context || context.length === 0) {
        return exports2.filters["root"](next, rule, options2);
      }
      if (context.length === 1) {
        return function(elem) {
          return equals(context[0], elem) && next(elem);
        };
      }
      return function(elem) {
        return context.includes(elem) && next(elem);
      };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive")
  };
  function dynamicStatePseudo(name2) {
    return function dynamicPseudo(next, _rule, _a) {
      var adapter = _a.adapter;
      var func = adapter[name2];
      if (typeof func !== "function") {
        return boolbase_12.default.falseFunc;
      }
      return function active(elem) {
        return func(elem) && next(elem);
      };
    };
  }
})(filters);
var pseudos = {};
Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
pseudos.pseudos = {
  empty: function(elem, _a) {
    var adapter = _a.adapter;
    return !adapter.getChildren(elem).some(function(elem2) {
      return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
    });
  },
  "first-child": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    var firstChild2 = adapter.getSiblings(elem).find(function(elem2) {
      return adapter.isTag(elem2);
    });
    return firstChild2 != null && equals(elem, firstChild2);
  },
  "last-child": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var siblings2 = adapter.getSiblings(elem);
    for (var i2 = siblings2.length - 1; i2 >= 0; i2--) {
      if (equals(elem, siblings2[i2]))
        return true;
      if (adapter.isTag(siblings2[i2]))
        break;
    }
    return false;
  },
  "first-of-type": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var siblings2 = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i2 = 0; i2 < siblings2.length; i2++) {
      var currentSibling = siblings2[i2];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var siblings2 = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i2 = siblings2.length - 1; i2 >= 0; i2--) {
      var currentSibling = siblings2[i2];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    var elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every(function(sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
    });
  },
  "only-child": function(elem, _a) {
    var adapter = _a.adapter, equals = _a.equals;
    return adapter.getSiblings(elem).every(function(sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling);
    });
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error("Pseudo-class :".concat(name2, " requires an argument"));
    }
  } else if (func.length === argIndex) {
    throw new Error("Pseudo-class :".concat(name2, " doesn't have any arguments"));
  }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;
var aliases = {};
Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
aliases.aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
var subselects = {};
(function(exports2) {
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.subselects = exports2.getNextSiblings = exports2.ensureIsTag = exports2.PLACEHOLDER_ELEMENT = void 0;
  var boolbase_12 = __importDefault2(boolbase);
  var sort_js_12 = sort;
  exports2.PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next, adapter) {
    if (next === boolbase_12.default.falseFunc)
      return boolbase_12.default.falseFunc;
    return function(elem) {
      return adapter.isTag(elem) && next(elem);
    };
  }
  exports2.ensureIsTag = ensureIsTag;
  function getNextSiblings(elem, adapter) {
    var siblings2 = adapter.getSiblings(elem);
    if (siblings2.length <= 1)
      return [];
    var elemIndex = siblings2.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings2.length - 1)
      return [];
    return siblings2.slice(elemIndex + 1).filter(adapter.isTag);
  }
  exports2.getNextSiblings = getNextSiblings;
  function copyOptions(options2) {
    return {
      xmlMode: !!options2.xmlMode,
      lowerCaseAttributeNames: !!options2.lowerCaseAttributeNames,
      lowerCaseTags: !!options2.lowerCaseTags,
      quirksMode: !!options2.quirksMode,
      cacheResults: !!options2.cacheResults,
      pseudos: options2.pseudos,
      adapter: options2.adapter,
      equals: options2.equals
    };
  }
  var is3 = function(next, token2, options2, context, compileToken2) {
    var func = compileToken2(token2, copyOptions(options2), context);
    return func === boolbase_12.default.trueFunc ? next : func === boolbase_12.default.falseFunc ? boolbase_12.default.falseFunc : function(elem) {
      return func(elem) && next(elem);
    };
  };
  exports2.subselects = {
    is: is3,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is3,
    where: is3,
    not: function(next, token2, options2, context, compileToken2) {
      var func = compileToken2(token2, copyOptions(options2), context);
      return func === boolbase_12.default.falseFunc ? next : func === boolbase_12.default.trueFunc ? boolbase_12.default.falseFunc : function(elem) {
        return !func(elem) && next(elem);
      };
    },
    has: function(next, subselect, options2, _context, compileToken2) {
      var adapter = options2.adapter;
      var opts = copyOptions(options2);
      opts.relativeSelector = true;
      var context = subselect.some(function(s2) {
        return s2.some(sort_js_12.isTraversal);
      }) ? (
        // Used as a placeholder. Will be replaced with the actual element.
        [exports2.PLACEHOLDER_ELEMENT]
      ) : void 0;
      var compiled = compileToken2(subselect, opts, context);
      if (compiled === boolbase_12.default.falseFunc)
        return boolbase_12.default.falseFunc;
      var hasElement = ensureIsTag(compiled, adapter);
      if (context && compiled !== boolbase_12.default.trueFunc) {
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
        return function(elem) {
          if (!next(elem))
            return false;
          context[0] = elem;
          var childs = adapter.getChildren(elem);
          var nextElements = shouldTestNextSiblings_1 ? __spreadArray2(__spreadArray2([], childs, true), getNextSiblings(elem, adapter), true) : childs;
          return adapter.existsOne(hasElement, nextElements);
        };
      }
      return function(elem) {
        return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
      };
    }
  };
})(subselects);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.compilePseudoSelector = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
  var css_what_12 = require$$0$1;
  var filters_js_1 = filters;
  Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
    return filters_js_1.filters;
  } });
  var pseudos_js_1 = pseudos;
  Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
    return pseudos_js_1.pseudos;
  } });
  var aliases_js_1 = aliases;
  Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
    return aliases_js_1.aliases;
  } });
  var subselects_js_12 = subselects;
  function compilePseudoSelector(next, selector2, options2, context, compileToken2) {
    var _a;
    var name2 = selector2.name, data2 = selector2.data;
    if (Array.isArray(data2)) {
      if (!(name2 in subselects_js_12.subselects)) {
        throw new Error("Unknown pseudo-class :".concat(name2, "(").concat(data2, ")"));
      }
      return subselects_js_12.subselects[name2](next, data2, options2, context, compileToken2);
    }
    var userPseudo = (_a = options2.pseudos) === null || _a === void 0 ? void 0 : _a[name2];
    var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name2];
    if (typeof stringPseudo === "string") {
      if (data2 != null) {
        throw new Error("Pseudo ".concat(name2, " doesn't have any arguments"));
      }
      var alias = (0, css_what_12.parse)(stringPseudo);
      return subselects_js_12.subselects["is"](next, alias, options2, context, compileToken2);
    }
    if (typeof userPseudo === "function") {
      (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name2, data2, 1);
      return function(elem) {
        return userPseudo(elem, data2) && next(elem);
      };
    }
    if (name2 in filters_js_1.filters) {
      return filters_js_1.filters[name2](next, data2, options2, context);
    }
    if (name2 in pseudos_js_1.pseudos) {
      var pseudo_1 = pseudos_js_1.pseudos[name2];
      (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name2, data2, 2);
      return function(elem) {
        return pseudo_1(elem, options2, data2) && next(elem);
      };
    }
    throw new Error("Unknown pseudo-class :".concat(name2));
  }
  exports2.compilePseudoSelector = compilePseudoSelector;
})(pseudoSelectors);
Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_js_1 = attributes$1;
var index_js_1$1 = pseudoSelectors;
var css_what_1$1 = require$$0$1;
function getElementParent(node2, adapter) {
  var parent = adapter.getParent(node2);
  if (parent && adapter.isTag(parent)) {
    return parent;
  }
  return null;
}
function compileGeneralSelector(next, selector2, options2, context, compileToken2) {
  var adapter = options2.adapter, equals = options2.equals;
  switch (selector2.type) {
    case css_what_1$1.SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case css_what_1$1.SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case css_what_1$1.SelectorType.Attribute: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options2.xmlMode || options2.lowerCaseAttributeNames) {
        selector2.name = selector2.name.toLowerCase();
      }
      return attributes_js_1.attributeRules[selector2.action](next, selector2, options2);
    }
    case css_what_1$1.SelectorType.Pseudo: {
      return (0, index_js_1$1.compilePseudoSelector)(next, selector2, options2, context, compileToken2);
    }
    case css_what_1$1.SelectorType.Tag: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      var name_1 = selector2.name;
      if (!options2.xmlMode || options2.lowerCaseTags) {
        name_1 = name_1.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name_1 && next(elem);
      };
    }
    case css_what_1$1.SelectorType.Descendant: {
      if (options2.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          var current = elem;
          while (current = getElementParent(current, adapter)) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        var current = elem;
        while (current = getElementParent(current, adapter)) {
          if (!isFalseCache_1.has(current)) {
            if (adapter.isTag(current) && next(current)) {
              return true;
            }
            isFalseCache_1.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        var current = elem;
        do {
          if (next(current))
            return true;
        } while (current = getElementParent(current, adapter));
        return false;
      };
    }
    case css_what_1$1.SelectorType.Parent: {
      return function parent(elem) {
        return adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) && next(elem2);
        });
      };
    }
    case css_what_1$1.SelectorType.Child: {
      return function child(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(parent);
      };
    }
    case css_what_1$1.SelectorType.Sibling: {
      return function sibling(elem) {
        var siblings2 = adapter.getSiblings(elem);
        for (var i2 = 0; i2 < siblings2.length; i2++) {
          var currentSibling = siblings2[i2];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case css_what_1$1.SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          var previous = adapter.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        var siblings2 = adapter.getSiblings(elem);
        var lastElement;
        for (var i2 = 0; i2 < siblings2.length; i2++) {
          var currentSibling = siblings2[i2];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case css_what_1$1.SelectorType.Universal: {
      if (selector2.namespace != null && selector2.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next;
    }
  }
}
general.compileGeneralSelector = compileGeneralSelector;
var __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$6(result, mod, k2);
  }
  __setModuleDefault$6(result, mod);
  return result;
};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(compile$2, "__esModule", { value: true });
compile$2.compileToken = compile$2.compileUnsafe = compile$2.compile = void 0;
var css_what_1 = require$$0$1;
var boolbase_1 = __importDefault$4(boolbase);
var sort_js_1 = __importStar$6(sort);
var general_js_1 = general;
var subselects_js_1 = subselects;
function compile(selector2, options2, context) {
  var next = compileUnsafe(selector2, options2, context);
  return (0, subselects_js_1.ensureIsTag)(next, options2.adapter);
}
compile$2.compile = compile;
function compileUnsafe(selector2, options2, context) {
  var token2 = typeof selector2 === "string" ? (0, css_what_1.parse)(selector2) : selector2;
  return compileToken(token2, options2, context);
}
compile$2.compileUnsafe = compileUnsafe;
function includesScopePseudo(t2) {
  return t2.type === css_what_1.SelectorType.Pseudo && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some(function(data2) {
    return data2.some(includesScopePseudo);
  }));
}
var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: css_what_1.SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token2, _a, context) {
  var adapter = _a.adapter;
  var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e2) {
    var parent = adapter.isTag(e2) && adapter.getParent(e2);
    return e2 === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
  }));
  for (var _i = 0, token_1 = token2; _i < token_1.length; _i++) {
    var t2 = token_1[_i];
    if (t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]) && t2[0].type !== css_what_1.SelectorType.Descendant)
      ;
    else if (hasContext && !t2.some(includesScopePseudo)) {
      t2.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t2.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token2, options2, context) {
  var _a;
  token2.forEach(sort_js_1.default);
  context = (_a = options2.context) !== null && _a !== void 0 ? _a : context;
  var isArrayContext = Array.isArray(context);
  var finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options2.relativeSelector !== false) {
    absolutize(token2, options2, finalContext);
  } else if (token2.some(function(t2) {
    return t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]);
  })) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  var shouldTestNextSiblings = false;
  var query = token2.map(function(rules) {
    if (rules.length >= 2) {
      var first2 = rules[0], second = rules[1];
      if (first2.type !== css_what_1.SelectorType.Pseudo || first2.name !== "scope")
        ;
      else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options2, finalContext);
  }).reduce(reduceRules, boolbase_1.default.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
compile$2.compileToken = compileToken;
function compileRules(rules, options2, context) {
  var _a;
  return rules.reduce(function(previous, rule) {
    return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options2, context, compileToken);
  }, (_a = options2.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
}
function reduceRules(a2, b2) {
  if (b2 === boolbase_1.default.falseFunc || a2 === boolbase_1.default.trueFunc) {
    return a2;
  }
  if (a2 === boolbase_1.default.falseFunc || b2 === boolbase_1.default.trueFunc) {
    return b2;
  }
  return function combine2(elem) {
    return a2(elem) || b2(elem);
  };
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.aliases = exports2.pseudos = exports2.filters = exports2.is = exports2.selectOne = exports2.selectAll = exports2.prepareContext = exports2._compileToken = exports2._compileUnsafe = exports2.compile = void 0;
  var DomUtils = __importStar2(lib$d);
  var boolbase_12 = __importDefault2(boolbase);
  var compile_js_1 = compile$2;
  var subselects_js_12 = subselects;
  var defaultEquals = function(a2, b2) {
    return a2 === b2;
  };
  var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals
  };
  function convertOptionFormats(options2) {
    var _a, _b, _c, _d;
    var opts = options2 !== null && options2 !== void 0 ? options2 : defaultOptions;
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
    (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
    return opts;
  }
  function wrapCompile(func) {
    return function addAdapter(selector2, options2, context) {
      var opts = convertOptionFormats(options2);
      return func(selector2, opts, context);
    };
  }
  exports2.compile = wrapCompile(compile_js_1.compile);
  exports2._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
  exports2._compileToken = wrapCompile(compile_js_1.compileToken);
  function getSelectorFunc(searchFunc) {
    return function select2(query, elements, options2) {
      var opts = convertOptionFormats(options2);
      if (typeof query !== "function") {
        query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
      }
      var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
      return searchFunc(query, filteredElements, opts);
    };
  }
  function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) {
      shouldTestNextSiblings = false;
    }
    if (shouldTestNextSiblings) {
      elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
  }
  exports2.prepareContext = prepareContext;
  function appendNextSiblings(elem, adapter) {
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i2 = 0; i2 < elemsLength; i2++) {
      var nextSiblings = (0, subselects_js_12.getNextSiblings)(elems[i2], adapter);
      elems.push.apply(elems, nextSiblings);
    }
    return elems;
  }
  exports2.selectAll = getSelectorFunc(function(query, elems, options2) {
    return query === boolbase_12.default.falseFunc || !elems || elems.length === 0 ? [] : options2.adapter.findAll(query, elems);
  });
  exports2.selectOne = getSelectorFunc(function(query, elems, options2) {
    return query === boolbase_12.default.falseFunc || !elems || elems.length === 0 ? null : options2.adapter.findOne(query, elems);
  });
  function is3(elem, query, options2) {
    var opts = convertOptionFormats(options2);
    return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
  }
  exports2.is = is3;
  exports2.default = exports2.selectAll;
  var index_js_12 = pseudoSelectors;
  Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
    return index_js_12.filters;
  } });
  Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
    return index_js_12.pseudos;
  } });
  Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
    return index_js_12.aliases;
  } });
})(lib$e);
var lib$9 = {};
var stringify$5 = {};
var lib$8 = {};
var node$2 = {};
var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$5 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
Object.defineProperty(node$2, "__esModule", { value: true });
node$2.cloneNode = node$2.hasChildren = node$2.isDocument = node$2.isDirective = node$2.isComment = node$2.isText = node$2.isCDATA = node$2.isTag = node$2.Element = node$2.Document = node$2.CDATA = node$2.NodeWithChildren = node$2.ProcessingInstruction = node$2.Comment = node$2.Text = node$2.DataNode = node$2.Node = void 0;
var domelementtype_1$4 = lib$i;
var Node$2 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$2(this, recursive);
    };
    return Node2;
  }()
);
node$2.Node = Node$2;
var DataNode$2 = (
  /** @class */
  function(_super) {
    __extends$3(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$2)
);
node$2.DataNode = DataNode$2;
var Text$2 = (
  /** @class */
  function(_super) {
    __extends$3(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$2)
);
node$2.Text = Text$2;
var Comment$2 = (
  /** @class */
  function(_super) {
    __extends$3(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$2)
);
node$2.Comment = Comment$2;
var ProcessingInstruction$2 = (
  /** @class */
  function(_super) {
    __extends$3(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$4.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$2)
);
node$2.ProcessingInstruction = ProcessingInstruction$2;
var NodeWithChildren$2 = (
  /** @class */
  function(_super) {
    __extends$3(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$2)
);
node$2.NodeWithChildren = NodeWithChildren$2;
var CDATA$2 = (
  /** @class */
  function(_super) {
    __extends$3(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$2)
);
node$2.CDATA = CDATA$2;
var Document$2 = (
  /** @class */
  function(_super) {
    __extends$3(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$4.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$2)
);
node$2.Document = Document$2;
var Element$2 = (
  /** @class */
  function(_super) {
    __extends$3(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$4.ElementType.Script : name2 === "style" ? domelementtype_1$4.ElementType.Style : domelementtype_1$4.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$2)
);
node$2.Element = Element$2;
function isTag$2(node2) {
  return (0, domelementtype_1$4.isTag)(node2);
}
node$2.isTag = isTag$2;
function isCDATA$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.CDATA;
}
node$2.isCDATA = isCDATA$2;
function isText$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Text;
}
node$2.isText = isText$2;
function isComment$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Comment;
}
node$2.isComment = isComment$2;
function isDirective$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Directive;
}
node$2.isDirective = isDirective$2;
function isDocument$2(node2) {
  return node2.type === domelementtype_1$4.ElementType.Root;
}
node$2.isDocument = isDocument$2;
function hasChildren$2(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$2.hasChildren = hasChildren$2;
function cloneNode$2(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$2(node2)) {
    result = new Text$2(node2.data);
  } else if (isComment$2(node2)) {
    result = new Comment$2(node2.data);
  } else if (isTag$2(node2)) {
    var children = recursive ? cloneChildren$2(node2.children) : [];
    var clone_1 = new Element$2(node2.name, __assign$5({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$5({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$5({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$2(node2)) {
    var children = recursive ? cloneChildren$2(node2.children) : [];
    var clone_2 = new CDATA$2(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$2(node2)) {
    var children = recursive ? cloneChildren$2(node2.children) : [];
    var clone_3 = new Document$2(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$2(node2)) {
    var instruction = new ProcessingInstruction$2(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$2.cloneNode = cloneNode$2;
function cloneChildren$2(childs) {
  var children = childs.map(function(child) {
    return cloneNode$2(child, true);
  });
  for (var i2 = 1; i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$2;
  __exportStar(node$2, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$8);
var lib$7 = {};
var lib$6 = {};
var decode$2 = {};
var decodeDataHtml$2 = {};
Object.defineProperty(decodeDataHtml$2, "__esModule", { value: true });
decodeDataHtml$2.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decodeDataXml$2 = {};
Object.defineProperty(decodeDataXml$2, "__esModule", { value: true });
decodeDataXml$2.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decode_codepoint$2 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$2);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$2);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$2);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$2);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$2;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$2);
var encode$1 = {};
var encodeHtml$1 = {};
Object.defineProperty(encodeHtml$1, "__esModule", { value: true });
function restoreDiff$1(arr) {
  for (var i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
encodeHtml$1.default = new Map(/* @__PURE__ */ restoreDiff$1([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff$1([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff$1([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff$1([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c2, index2) {
      return (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i2 = match.index;
      var char = str.charCodeAt(i2);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i2) + next;
        lastIdx = i2 + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports2.getCodePoint)(str, i2).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$2);
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode$1, "__esModule", { value: true });
encode$1.encodeNonAsciiHTML = encode$1.encodeHTML = void 0;
var encode_html_js_1$1 = __importDefault$3(encodeHtml$1);
var escape_js_1$2 = _escape$2;
var htmlReplacer$1 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML$1(data2) {
  return encodeHTMLTrieRe$1(htmlReplacer$1, data2);
}
encode$1.encodeHTML = encodeHTML$1;
function encodeNonAsciiHTML$1(data2) {
  return encodeHTMLTrieRe$1(escape_js_1$2.xmlReplacer, data2);
}
encode$1.encodeNonAsciiHTML = encodeNonAsciiHTML$1;
function encodeHTMLTrieRe$1(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i2 = match.index;
    ret += str.substring(lastIdx, i2);
    var char = str.charCodeAt(i2);
    var next = encode_html_js_1$1.default.get(char);
    if (typeof next === "object") {
      if (i2 + 1 < str.length) {
        var nextChar = str.charCodeAt(i2 + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i2 + 1;
    } else {
      var cp = (0, escape_js_1$2.getCodePoint)(str, i2);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode$2;
  var encode_js_1 = encode$1;
  var escape_js_12 = _escape$2;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode2;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode2(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode2(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode2;
  var escape_js_2 = _escape$2;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode$1;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode$2;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib$6);
var foreignNames$1 = {};
Object.defineProperty(foreignNames$1, "__esModule", { value: true });
foreignNames$1.attributeNames = foreignNames$1.elementNames = void 0;
foreignNames$1.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames$1.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign$4 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$5(result, mod, k2);
  }
  __setModuleDefault$5(result, mod);
  return result;
};
Object.defineProperty(lib$7, "__esModule", { value: true });
lib$7.render = void 0;
var ElementType$1 = __importStar$5(lib$i);
var entities_1$1 = lib$6;
var foreignNames_js_1$1 = foreignNames$1;
var unencodedElements$1 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes$1(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes$1(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes$1 : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1$1.encodeXML : entities_1$1.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1$1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag$1 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$1(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode$1(nodes[i2], options2);
  }
  return output;
}
lib$7.render = render$1;
lib$7.default = render$1;
function renderNode$1(node2, options2) {
  switch (node2.type) {
    case ElementType$1.Root:
      return render$1(node2.children, options2);
    case ElementType$1.Doctype:
    case ElementType$1.Directive:
      return renderDirective$1(node2);
    case ElementType$1.Comment:
      return renderComment$1(node2);
    case ElementType$1.CDATA:
      return renderCdata$1(node2);
    case ElementType$1.Script:
    case ElementType$1.Style:
    case ElementType$1.Tag:
      return renderTag$1(node2, options2);
    case ElementType$1.Text:
      return renderText$1(node2, options2);
  }
}
var foreignModeIntegrationPoints$1 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements$1 = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$1(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1$1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints$1.has(elem.parent.name)) {
      opts = __assign$4(__assign$4({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$1.has(elem.name)) {
    opts = __assign$4(__assign$4({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$1(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$1.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$1(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$1.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$1(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$1(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$1.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1$1.encodeXML)(data2) : (0, entities_1$1.escapeText)(data2);
  }
  return data2;
}
function renderCdata$1(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$1(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$5, "__esModule", { value: true });
stringify$5.innerText = stringify$5.textContent = stringify$5.getText = stringify$5.getInnerHTML = stringify$5.getOuterHTML = void 0;
var domhandler_1$b = lib$8;
var dom_serializer_1$1 = __importDefault$2(lib$7);
var domelementtype_1$3 = lib$i;
function getOuterHTML$1(node2, options2) {
  return (0, dom_serializer_1$1.default)(node2, options2);
}
stringify$5.getOuterHTML = getOuterHTML$1;
function getInnerHTML$1(node2, options2) {
  return (0, domhandler_1$b.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML$1(node3, options2);
  }).join("") : "";
}
stringify$5.getInnerHTML = getInnerHTML$1;
function getText$1(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$1).join("");
  if ((0, domhandler_1$b.isTag)(node2))
    return node2.name === "br" ? "\n" : getText$1(node2.children);
  if ((0, domhandler_1$b.isCDATA)(node2))
    return getText$1(node2.children);
  if ((0, domhandler_1$b.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.getText = getText$1;
function textContent$1(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent$1).join("");
  if ((0, domhandler_1$b.hasChildren)(node2) && !(0, domhandler_1$b.isComment)(node2)) {
    return textContent$1(node2.children);
  }
  if ((0, domhandler_1$b.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.textContent = textContent$1;
function innerText$1(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText$1).join("");
  if ((0, domhandler_1$b.hasChildren)(node2) && (node2.type === domelementtype_1$3.ElementType.Tag || (0, domhandler_1$b.isCDATA)(node2))) {
    return innerText$1(node2.children);
  }
  if ((0, domhandler_1$b.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.innerText = innerText$1;
var traversal$1 = {};
Object.defineProperty(traversal$1, "__esModule", { value: true });
traversal$1.prevElementSibling = traversal$1.nextElementSibling = traversal$1.getName = traversal$1.hasAttrib = traversal$1.getAttributeValue = traversal$1.getSiblings = traversal$1.getParent = traversal$1.getChildren = void 0;
var domhandler_1$a = lib$8;
function getChildren$1(elem) {
  return (0, domhandler_1$a.hasChildren)(elem) ? elem.children : [];
}
traversal$1.getChildren = getChildren$1;
function getParent$1(elem) {
  return elem.parent || null;
}
traversal$1.getParent = getParent$1;
function getSiblings$1(elem) {
  var _a, _b;
  var parent = getParent$1(elem);
  if (parent != null)
    return getChildren$1(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal$1.getSiblings = getSiblings$1;
function getAttributeValue$1(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal$1.getAttributeValue = getAttributeValue$1;
function hasAttrib$1(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal$1.hasAttrib = hasAttrib$1;
function getName$1(elem) {
  return elem.name;
}
traversal$1.getName = getName$1;
function nextElementSibling$1(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$a.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal$1.nextElementSibling = nextElementSibling$1;
function prevElementSibling$1(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$a.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal$1.prevElementSibling = prevElementSibling$1;
var manipulation$2 = {};
Object.defineProperty(manipulation$2, "__esModule", { value: true });
manipulation$2.prepend = manipulation$2.prependChild = manipulation$2.append = manipulation$2.appendChild = manipulation$2.replaceElement = manipulation$2.removeElement = void 0;
function removeElement$1(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation$2.removeElement = removeElement$1;
function replaceElement$1(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation$2.replaceElement = replaceElement$1;
function appendChild$1(parent, child) {
  removeElement$1(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation$2.appendChild = appendChild$1;
function append$1(elem, next) {
  removeElement$1(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation$2.append = append$1;
function prependChild$1(parent, child) {
  removeElement$1(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation$2.prependChild = prependChild$1;
function prepend$1(elem, prev) {
  removeElement$1(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation$2.prepend = prepend$1;
var querying$1 = {};
Object.defineProperty(querying$1, "__esModule", { value: true });
querying$1.findAll = querying$1.existsOne = querying$1.findOne = querying$1.findOneChild = querying$1.find = querying$1.filter = void 0;
var domhandler_1$9 = lib$8;
function filter$2(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$3(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying$1.filter = filter$2;
function find$3(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$9.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$1.find = find$3;
function findOneChild$1(test2, nodes) {
  return nodes.find(test2);
}
querying$1.findOneChild = findOneChild$1;
function findOne$1(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
    var node2 = nodes[i2];
    if (!(0, domhandler_1$9.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne$1(test2, node2.children, true);
    }
  }
  return elem;
}
querying$1.findOne = findOne$1;
function existsOne$1(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$9.isTag)(checked2) && (test2(checked2) || existsOne$1(test2, checked2.children));
  });
}
querying$1.existsOne = existsOne$1;
function findAll$1(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$9.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying$1.findAll = findAll$1;
var legacy$1 = {};
Object.defineProperty(legacy$1, "__esModule", { value: true });
legacy$1.getElementsByTagType = legacy$1.getElementsByTagName = legacy$1.getElementById = legacy$1.getElements = legacy$1.testElement = void 0;
var domhandler_1$8 = lib$8;
var querying_js_1$1 = querying$1;
var Checks$1 = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1$8.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1$8.isTag;
    }
    return function(elem) {
      return (0, domhandler_1$8.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1$8.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1$8.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck$1(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1$8.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1$8.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs$1(a2, b2) {
  return function(elem) {
    return a2(elem) || b2(elem);
  };
}
function compileTest$1(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks$1, key2) ? Checks$1[key2](value) : getAttribCheck$1(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$1);
}
function testElement$1(options2, node2) {
  var test2 = compileTest$1(options2);
  return test2 ? test2(node2) : true;
}
legacy$1.testElement = testElement$1;
function getElements$1(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest$1(options2);
  return test2 ? (0, querying_js_1$1.filter)(test2, nodes, recurse, limit) : [];
}
legacy$1.getElements = getElements$1;
function getElementById$1(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1$1.findOne)(getAttribCheck$1("id", id2), nodes, recurse);
}
legacy$1.getElementById = getElementById$1;
function getElementsByTagName$1(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$1.filter)(Checks$1["tag_name"](tagName), nodes, recurse, limit);
}
legacy$1.getElementsByTagName = getElementsByTagName$1;
function getElementsByTagType$1(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1$1.filter)(Checks$1["tag_type"](type), nodes, recurse, limit);
}
legacy$1.getElementsByTagType = getElementsByTagType$1;
var helpers$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$8;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i2, arr) {
      return !arr.includes(node2, i2 + 1);
    });
    nodes.sort(function(a2, b2) {
      var relative = compareDocumentPosition(a2, b2);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers$2);
var feeds$1 = {};
Object.defineProperty(feeds$1, "__esModule", { value: true });
feeds$1.getFeed = void 0;
var stringify_js_1$1 = stringify$5;
var legacy_js_1$1 = legacy$1;
function getFeed$1(doc) {
  var feedRoot = getOneElement$1(isValidFeed$1, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed$1(feedRoot) : getRssFeed$1(feedRoot);
}
feeds$1.getFeed = getFeed$1;
function getAtomFeed$1(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1$1.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements$1(children) };
      addConditionally$1(entry, "id", "id", children);
      addConditionally$1(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement$1("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$1("summary", children) || fetch$1("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$1("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally$1(feed, "id", "id", childs);
  addConditionally$1(feed, "title", "title", childs);
  var href = (_a = getOneElement$1("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$1(feed, "description", "subtitle", childs);
  var updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$1(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed$1(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement$1("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1$1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements$1(children) };
      addConditionally$1(entry, "id", "guid", children);
      addConditionally$1(entry, "title", "title", children);
      addConditionally$1(entry, "link", "link", children);
      addConditionally$1(entry, "description", "description", children);
      var pubDate = fetch$1("pubDate", children) || fetch$1("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally$1(feed, "title", "title", childs);
  addConditionally$1(feed, "link", "link", childs);
  addConditionally$1(feed, "description", "description", childs);
  var updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$1(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING$1 = ["url", "type", "lang"];
var MEDIA_KEYS_INT$1 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements$1(where) {
  return (0, legacy_js_1$1.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING$1; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT$1; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement$1(tagName, node2) {
  return (0, legacy_js_1$1.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1$1.textContent)((0, legacy_js_1$1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally$1(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch$1(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed$1(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$5, exports2);
  __exportStar(traversal$1, exports2);
  __exportStar(manipulation$2, exports2);
  __exportStar(querying$1, exports2);
  __exportStar(legacy$1, exports2);
  __exportStar(helpers$2, exports2);
  __exportStar(feeds$1, exports2);
  var domhandler_12 = lib$8;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$9);
var helpers$1 = {};
var positionals = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getLimit = exports2.isFilter = exports2.filterNames = void 0;
  exports2.filterNames = /* @__PURE__ */ new Set([
    "first",
    "last",
    "eq",
    "gt",
    "nth",
    "lt",
    "even",
    "odd"
  ]);
  function isFilter(s2) {
    if (s2.type !== "pseudo")
      return false;
    if (exports2.filterNames.has(s2.name))
      return true;
    if (s2.name === "not" && Array.isArray(s2.data)) {
      return s2.data.some(function(s3) {
        return s3.some(isFilter);
      });
    }
    return false;
  }
  exports2.isFilter = isFilter;
  function getLimit(filter2, data2, partLimit) {
    var num = data2 != null ? parseInt(data2, 10) : NaN;
    switch (filter2) {
      case "first":
        return 1;
      case "nth":
      case "eq":
        return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
      case "lt":
        return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
      case "gt":
        return isFinite(num) ? Infinity : 0;
      case "odd":
        return 2 * partLimit;
      case "even":
        return 2 * partLimit - 1;
      case "last":
      case "not":
        return Infinity;
    }
  }
  exports2.getLimit = getLimit;
})(positionals);
Object.defineProperty(helpers$1, "__esModule", { value: true });
helpers$1.groupSelectors = helpers$1.getDocumentRoot = void 0;
var positionals_js_1 = positionals;
function getDocumentRoot(node2) {
  while (node2.parent)
    node2 = node2.parent;
  return node2;
}
helpers$1.getDocumentRoot = getDocumentRoot;
function groupSelectors(selectors) {
  var filteredSelectors = [];
  var plainSelectors = [];
  for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
    var selector2 = selectors_1[_i];
    if (selector2.some(positionals_js_1.isFilter)) {
      filteredSelectors.push(selector2);
    } else {
      plainSelectors.push(selector2);
    }
  }
  return [plainSelectors, filteredSelectors];
}
helpers$1.groupSelectors = groupSelectors;
(function(exports2) {
  var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign2 = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign2.apply(this, arguments);
  };
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.select = exports2.filter = exports2.some = exports2.is = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
  var css_what_12 = require$$0$1;
  var css_select_1 = lib$e;
  var DomUtils = __importStar2(lib$9);
  var boolbase$12 = __importStar2(boolbase);
  var helpers_js_1 = helpers$1;
  var positionals_js_12 = positionals;
  var css_select_2 = lib$e;
  Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
    return css_select_2.filters;
  } });
  Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
    return css_select_2.pseudos;
  } });
  Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
    return css_select_2.aliases;
  } });
  var UNIVERSAL_SELECTOR = {
    type: css_what_12.SelectorType.Universal,
    namespace: null
  };
  var SCOPE_PSEUDO = {
    type: css_what_12.SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  function is3(element2, selector2, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return some([element2], selector2, options2);
  }
  exports2.is = is3;
  function some(elements, selector2, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (typeof selector2 === "function")
      return elements.some(selector2);
    var _a = (0, helpers_js_1.groupSelectors)((0, css_what_12.parse)(selector2)), plain = _a[0], filtered = _a[1];
    return plain.length > 0 && elements.some((0, css_select_1._compileToken)(plain, options2)) || filtered.some(function(sel) {
      return filterBySelector(sel, elements, options2).length > 0;
    });
  }
  exports2.some = some;
  function filterByPosition(filter3, elems, data2, options2) {
    var num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
    switch (filter3) {
      case "first":
      case "lt":
        return elems;
      case "last":
        return elems.length > 0 ? [elems[elems.length - 1]] : elems;
      case "nth":
      case "eq":
        return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
      case "gt":
        return isFinite(num) ? elems.slice(num + 1) : [];
      case "even":
        return elems.filter(function(_2, i2) {
          return i2 % 2 === 0;
        });
      case "odd":
        return elems.filter(function(_2, i2) {
          return i2 % 2 === 1;
        });
      case "not": {
        var filtered_1 = new Set(filterParsed(data2, elems, options2));
        return elems.filter(function(e2) {
          return !filtered_1.has(e2);
        });
      }
    }
  }
  function filter2(selector2, elements, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return filterParsed((0, css_what_12.parse)(selector2), elements, options2);
  }
  exports2.filter = filter2;
  function filterParsed(selector2, elements, options2) {
    if (elements.length === 0)
      return [];
    var _a = (0, helpers_js_1.groupSelectors)(selector2), plainSelectors = _a[0], filteredSelectors = _a[1];
    var found;
    if (plainSelectors.length) {
      var filtered = filterElements(elements, plainSelectors, options2);
      if (filteredSelectors.length === 0) {
        return filtered;
      }
      if (filtered.length) {
        found = new Set(filtered);
      }
    }
    for (var i2 = 0; i2 < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i2++) {
      var filteredSelector = filteredSelectors[i2];
      var missing = found ? elements.filter(function(e2) {
        return DomUtils.isTag(e2) && !found.has(e2);
      }) : elements;
      if (missing.length === 0)
        break;
      var filtered = filterBySelector(filteredSelector, elements, options2);
      if (filtered.length) {
        if (!found) {
          if (i2 === filteredSelectors.length - 1) {
            return filtered;
          }
          found = new Set(filtered);
        } else {
          filtered.forEach(function(el) {
            return found.add(el);
          });
        }
      }
    }
    return typeof found !== "undefined" ? found.size === elements.length ? elements : (
      // Filter elements to preserve order
      elements.filter(function(el) {
        return found.has(el);
      })
    ) : [];
  }
  function filterBySelector(selector2, elements, options2) {
    var _a;
    if (selector2.some(css_what_12.isTraversal)) {
      var root2 = (_a = options2.root) !== null && _a !== void 0 ? _a : (0, helpers_js_1.getDocumentRoot)(elements[0]);
      var opts = __assign2(__assign2({}, options2), { context: elements, relativeSelector: false });
      selector2.push(SCOPE_PSEUDO);
      return findFilterElements(root2, selector2, opts, true, elements.length);
    }
    return findFilterElements(elements, selector2, options2, false, elements.length);
  }
  function select2(selector2, root2, options2, limit) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (limit === void 0) {
      limit = Infinity;
    }
    if (typeof selector2 === "function") {
      return find2(root2, selector2);
    }
    var _a = (0, helpers_js_1.groupSelectors)((0, css_what_12.parse)(selector2)), plain = _a[0], filtered = _a[1];
    var results = filtered.map(function(sel) {
      return findFilterElements(root2, sel, options2, true, limit);
    });
    if (plain.length) {
      results.push(findElements(root2, plain, options2, limit));
    }
    if (results.length === 0) {
      return [];
    }
    if (results.length === 1) {
      return results[0];
    }
    return DomUtils.uniqueSort(results.reduce(function(a2, b2) {
      return __spreadArray2(__spreadArray2([], a2, true), b2, true);
    }));
  }
  exports2.select = select2;
  function findFilterElements(root2, selector2, options2, queryForSelector, totalLimit) {
    var filterIndex = selector2.findIndex(positionals_js_12.isFilter);
    var sub = selector2.slice(0, filterIndex);
    var filter3 = selector2[filterIndex];
    var partLimit = selector2.length - 1 === filterIndex ? totalLimit : Infinity;
    var limit = (0, positionals_js_12.getLimit)(filter3.name, filter3.data, partLimit);
    if (limit === 0)
      return [];
    var elemsNoLimit = sub.length === 0 && !Array.isArray(root2) ? DomUtils.getChildren(root2).filter(DomUtils.isTag) : sub.length === 0 ? (Array.isArray(root2) ? root2 : [root2]).filter(DomUtils.isTag) : queryForSelector || sub.some(css_what_12.isTraversal) ? findElements(root2, [sub], options2, limit) : filterElements(root2, [sub], options2);
    var elems = elemsNoLimit.slice(0, limit);
    var result = filterByPosition(filter3.name, elems, filter3.data, options2);
    if (result.length === 0 || selector2.length === filterIndex + 1) {
      return result;
    }
    var remainingSelector = selector2.slice(filterIndex + 1);
    var remainingHasTraversal = remainingSelector.some(css_what_12.isTraversal);
    if (remainingHasTraversal) {
      if ((0, css_what_12.isTraversal)(remainingSelector[0])) {
        var type = remainingSelector[0].type;
        if (type === css_what_12.SelectorType.Sibling || type === css_what_12.SelectorType.Adjacent) {
          result = (0, css_select_1.prepareContext)(result, DomUtils, true);
        }
        remainingSelector.unshift(UNIVERSAL_SELECTOR);
      }
      options2 = __assign2(__assign2({}, options2), {
        // Avoid absolutizing the selector
        relativeSelector: false,
        /*
         * Add a custom root func, to make sure traversals don't match elements
         * that aren't a part of the considered tree.
         */
        rootFunc: function(el) {
          return result.includes(el);
        }
      });
    } else if (options2.rootFunc && options2.rootFunc !== boolbase$12.trueFunc) {
      options2 = __assign2(__assign2({}, options2), { rootFunc: boolbase$12.trueFunc });
    }
    return remainingSelector.some(positionals_js_12.isFilter) ? findFilterElements(result, remainingSelector, options2, false, totalLimit) : remainingHasTraversal ? (
      // Query existing elements to resolve traversal.
      findElements(result, [remainingSelector], options2, totalLimit)
    ) : (
      // If we don't have any more traversals, simply filter elements.
      filterElements(result, [remainingSelector], options2)
    );
  }
  function findElements(root2, sel, options2, limit) {
    var query = (0, css_select_1._compileToken)(sel, options2, root2);
    return find2(root2, query, limit);
  }
  function find2(root2, query, limit) {
    if (limit === void 0) {
      limit = Infinity;
    }
    var elems = (0, css_select_1.prepareContext)(root2, DomUtils, query.shouldTestNextSiblings);
    return DomUtils.find(function(node2) {
      return DomUtils.isTag(node2) && query(node2);
    }, elems, true, limit);
  }
  function filterElements(elements, sel, options2) {
    var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);
    if (els.length === 0)
      return els;
    var query = (0, css_select_1._compileToken)(sel, options2);
    return query === boolbase$12.trueFunc ? els : els.filter(query);
  }
})(lib$f);
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$4(result, mod, k2);
  }
  __setModuleDefault$4(result, mod);
  return result;
};
var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(traversing, "__esModule", { value: true });
traversing.addBack = traversing.add = traversing.end = traversing.slice = traversing.index = traversing.toArray = traversing.get = traversing.eq = traversing.last = traversing.first = traversing.has = traversing.not = traversing.is = traversing.filterArray = traversing.filter = traversing.map = traversing.each = traversing.contents = traversing.children = traversing.siblings = traversing.prevUntil = traversing.prevAll = traversing.prev = traversing.nextUntil = traversing.nextAll = traversing.next = traversing.closest = traversing.parentsUntil = traversing.parents = traversing.parent = traversing.find = void 0;
var domhandler_1$7 = lib$j;
var select = __importStar$4(lib$f);
var utils_js_1$4 = utils$2;
var static_js_1$1 = _static;
var domutils_1$2 = lib$k;
var reSiblingSelector = /^\s*[~+]/;
function find$2(selectorOrHaystack) {
  var _a;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  var context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    var haystack = (0, utils_js_1$4.isCheerio)(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    return this._make(haystack.filter(function(elem) {
      return context.some(function(node2) {
        return (0, static_js_1$1.contains)(node2, elem);
      });
    }));
  }
  var elems = reSiblingSelector.test(selectorOrHaystack) ? context : this.children().toArray();
  var options2 = {
    context,
    root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select.select(selectorOrHaystack, elems, options2));
}
traversing.find = find$2;
function _getMatcher(matchMap) {
  return function(fn) {
    var postFns = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      postFns[_i - 1] = arguments[_i];
    }
    return function(selector2) {
      var _a;
      var matched = matchMap(fn, this);
      if (selector2) {
        matched = filterArray(matched, selector2, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce(function(elems, fn2) {
          return fn2(elems);
        }, matched) : matched
      );
    };
  };
}
var _matcher = _getMatcher(function(fn, elems) {
  var _a;
  var ret = [];
  for (var i2 = 0; i2 < elems.length; i2++) {
    var value = fn(elems[i2]);
    ret.push(value);
  }
  return (_a = new Array()).concat.apply(_a, ret);
});
var _singleMatcher = _getMatcher(function(fn, elems) {
  var ret = [];
  for (var i2 = 0; i2 < elems.length; i2++) {
    var value = fn(elems[i2]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem) {
  var postFns = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    postFns[_i - 1] = arguments[_i];
  }
  var matches = null;
  var innerMatcher = _getMatcher(function(nextElem2, elems) {
    var matched = [];
    (0, utils_js_1$4.domEach)(elems, function(elem) {
      for (var next_1; next_1 = nextElem2(elem); elem = next_1) {
        if (matches === null || matches === void 0 ? void 0 : matches(next_1, matched.length))
          break;
        matched.push(next_1);
      }
    });
    return matched;
  }).apply(void 0, __spreadArray$2([nextElem], postFns, false));
  return function(selector2, filterSelector) {
    var _this = this;
    matches = typeof selector2 === "string" ? function(elem) {
      return select.is(elem, selector2, _this.options);
    } : selector2 ? getFilterFn(selector2) : null;
    var ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
traversing.parent = _singleMatcher(function(_a) {
  var parent = _a.parent;
  return parent && !(0, domhandler_1$7.isDocument)(parent) ? parent : null;
}, _removeDuplicates);
traversing.parents = _matcher(function(elem) {
  var matched = [];
  while (elem.parent && !(0, domhandler_1$7.isDocument)(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, domutils_1$2.uniqueSort, function(elems) {
  return elems.reverse();
});
traversing.parentsUntil = _matchUntil(function(_a) {
  var parent = _a.parent;
  return parent && !(0, domhandler_1$7.isDocument)(parent) ? parent : null;
}, domutils_1$2.uniqueSort, function(elems) {
  return elems.reverse();
});
function closest(selector2) {
  var _a;
  var set = [];
  if (!selector2) {
    return this._make(set);
  }
  var selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]
  };
  var selectFn = typeof selector2 === "string" ? function(elem) {
    return select.is(elem, selector2, selectOpts);
  } : getFilterFn(selector2);
  (0, utils_js_1$4.domEach)(this, function(elem) {
    while (elem && (0, utils_js_1$4.isTag)(elem)) {
      if (selectFn(elem, 0)) {
        if (!set.includes(elem)) {
          set.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set);
}
traversing.closest = closest;
traversing.next = _singleMatcher(function(elem) {
  return (0, domutils_1$2.nextElementSibling)(elem);
});
traversing.nextAll = _matcher(function(elem) {
  var matched = [];
  while (elem.next) {
    elem = elem.next;
    if ((0, utils_js_1$4.isTag)(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
traversing.nextUntil = _matchUntil(function(el) {
  return (0, domutils_1$2.nextElementSibling)(el);
}, _removeDuplicates);
traversing.prev = _singleMatcher(function(elem) {
  return (0, domutils_1$2.prevElementSibling)(elem);
});
traversing.prevAll = _matcher(function(elem) {
  var matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if ((0, utils_js_1$4.isTag)(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
traversing.prevUntil = _matchUntil(function(el) {
  return (0, domutils_1$2.prevElementSibling)(el);
}, _removeDuplicates);
traversing.siblings = _matcher(function(elem) {
  return (0, domutils_1$2.getSiblings)(elem).filter(function(el) {
    return (0, utils_js_1$4.isTag)(el) && el !== elem;
  });
}, domutils_1$2.uniqueSort);
traversing.children = _matcher(function(elem) {
  return (0, domutils_1$2.getChildren)(elem).filter(utils_js_1$4.isTag);
}, _removeDuplicates);
function contents() {
  var elems = this.toArray().reduce(function(newElems, elem) {
    return (0, domhandler_1$7.hasChildren)(elem) ? newElems.concat(elem.children) : newElems;
  }, []);
  return this._make(elems);
}
traversing.contents = contents;
function each(fn) {
  var i2 = 0;
  var len = this.length;
  while (i2 < len && fn.call(this[i2], i2, this[i2]) !== false)
    ++i2;
  return this;
}
traversing.each = each;
function map(fn) {
  var elems = [];
  for (var i2 = 0; i2 < this.length; i2++) {
    var el = this[i2];
    var val2 = fn.call(el, i2, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
traversing.map = map;
function getFilterFn(match) {
  if (typeof match === "function") {
    return function(el, i2) {
      return match.call(el, i2, el);
    };
  }
  if ((0, utils_js_1$4.isCheerio)(match)) {
    return function(el) {
      return Array.prototype.includes.call(match, el);
    };
  }
  return function(el) {
    return match === el;
  };
}
function filter$1(match) {
  var _a;
  return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));
}
traversing.filter = filter$1;
function filterArray(nodes, match, xmlMode, root2) {
  return typeof match === "string" ? select.filter(match, nodes, { xmlMode, root: root2 }) : nodes.filter(getFilterFn(match));
}
traversing.filterArray = filterArray;
function is$1(selector2) {
  var nodes = this.toArray();
  return typeof selector2 === "string" ? select.some(nodes.filter(utils_js_1$4.isTag), selector2, this.options) : selector2 ? nodes.some(getFilterFn(selector2)) : false;
}
traversing.is = is$1;
function not$1(match) {
  var nodes = this.toArray();
  if (typeof match === "string") {
    var matches_1 = new Set(select.filter(match, nodes, this.options));
    nodes = nodes.filter(function(el) {
      return !matches_1.has(el);
    });
  } else {
    var filterFn_1 = getFilterFn(match);
    nodes = nodes.filter(function(el, i2) {
      return !filterFn_1(el, i2);
    });
  }
  return this._make(nodes);
}
traversing.not = not$1;
function has$1(selectorOrHaystack) {
  var _this = this;
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    ":has(".concat(selectorOrHaystack, ")")
  ) : function(_2, el) {
    return _this._make(el).find(selectorOrHaystack).length > 0;
  });
}
traversing.has = has$1;
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
traversing.first = first;
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
traversing.last = last;
function eq(i2) {
  var _a;
  i2 = +i2;
  if (i2 === 0 && this.length <= 1)
    return this;
  if (i2 < 0)
    i2 = this.length + i2;
  return this._make((_a = this[i2]) !== null && _a !== void 0 ? _a : []);
}
traversing.eq = eq;
function get(i2) {
  if (i2 == null) {
    return this.toArray();
  }
  return this[i2 < 0 ? this.length + i2 : i2];
}
traversing.get = get;
function toArray() {
  return Array.prototype.slice.call(this);
}
traversing.toArray = toArray;
function index$1(selectorOrNeedle) {
  var $haystack;
  var needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = (0, utils_js_1$4.isCheerio)(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
traversing.index = index$1;
function slice$1(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
traversing.slice = slice$1;
function end() {
  var _a;
  return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);
}
traversing.end = end;
function add$1(other, context) {
  var selection = this._make(other, context);
  var contents2 = (0, domutils_1$2.uniqueSort)(__spreadArray$2(__spreadArray$2([], this.get(), true), selection.get(), true));
  return this._make(contents2);
}
traversing.add = add$1;
function addBack(selector2) {
  return this.prevObject ? this.add(selector2 ? this.prevObject.filter(selector2) : this.prevObject) : this;
}
traversing.addBack = addBack;
var manipulation$1 = {};
var parse$5 = {};
Object.defineProperty(parse$5, "__esModule", { value: true });
parse$5.update = parse$5.getParse = void 0;
var domutils_1$1 = lib$k;
var domhandler_1$6 = lib$j;
function getParse(parser2) {
  return function parse2(content, options2, isDocument2, context) {
    if (typeof dist.Buffer !== "undefined" && dist.Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser2(content, options2, isDocument2, context);
    }
    var doc = content;
    if (!Array.isArray(doc) && (0, domhandler_1$6.isDocument)(doc)) {
      return doc;
    }
    var root2 = new domhandler_1$6.Document([]);
    update(doc, root2);
    return root2;
  };
}
parse$5.getParse = getParse;
function update(newChilds, parent) {
  var arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent) {
    parent.children = arr;
  } else {
    parent = null;
  }
  for (var i2 = 0; i2 < arr.length; i2++) {
    var node2 = arr[i2];
    if (node2.parent && node2.parent.children !== arr) {
      (0, domutils_1$1.removeElement)(node2);
    }
    if (parent) {
      node2.prev = arr[i2 - 1] || null;
      node2.next = arr[i2 + 1] || null;
    } else {
      node2.prev = node2.next = null;
    }
    node2.parent = parent;
  }
  return parent;
}
parse$5.update = update;
var __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(manipulation$1, "__esModule", { value: true });
manipulation$1.clone = manipulation$1.text = manipulation$1.toString = manipulation$1.html = manipulation$1.empty = manipulation$1.replaceWith = manipulation$1.remove = manipulation$1.insertBefore = manipulation$1.before = manipulation$1.insertAfter = manipulation$1.after = manipulation$1.wrapAll = manipulation$1.unwrap = manipulation$1.wrapInner = manipulation$1.wrap = manipulation$1.prepend = manipulation$1.append = manipulation$1.prependTo = manipulation$1.appendTo = manipulation$1._makeDomArray = void 0;
var domhandler_1$5 = lib$j;
var parse_js_1 = parse$5;
var static_js_1 = _static;
var utils_js_1$3 = utils$2;
var domutils_1 = lib$k;
function _makeDomArray(elem, clone2) {
  var _this = this;
  if (elem == null) {
    return [];
  }
  if ((0, utils_js_1$3.isCheerio)(elem)) {
    return clone2 ? (0, utils_js_1$3.cloneDom)(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce(function(newElems, el) {
      return newElems.concat(_this._makeDomArray(el, clone2));
    }, []);
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone2 ? (0, utils_js_1$3.cloneDom)([elem]) : [elem];
}
manipulation$1._makeDomArray = _makeDomArray;
function _insert(concatenator) {
  return function() {
    var _this = this;
    var elems = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      elems[_i] = arguments[_i];
    }
    var lastIdx = this.length - 1;
    return (0, utils_js_1$3.domEach)(this, function(el, i2) {
      if (!(0, domhandler_1$5.hasChildren)(el))
        return;
      var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i2, _this._render(el.children)) : elems;
      var dom = _this._makeDomArray(domSrc, i2 < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
  var _a, _b;
  var spliceArgs = __spreadArray$1([
    spliceIdx,
    spliceCount
  ], newElems, true);
  var prev = spliceIdx === 0 ? null : array[spliceIdx - 1];
  var next = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (var idx = 0; idx < newElems.length; ++idx) {
    var node2 = newElems[idx];
    var oldParent = node2.parent;
    if (oldParent) {
      var oldSiblings = oldParent.children;
      var prevIdx = oldSiblings.indexOf(node2);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node2.parent = parent;
    if (node2.prev) {
      node2.prev.next = (_a = node2.next) !== null && _a !== void 0 ? _a : null;
    }
    if (node2.next) {
      node2.next.prev = (_b = node2.prev) !== null && _b !== void 0 ? _b : null;
    }
    node2.prev = idx === 0 ? prev : newElems[idx - 1];
    node2.next = idx === newElems.length - 1 ? next : newElems[idx + 1];
  }
  if (prev) {
    prev.next = newElems[0];
  }
  if (next) {
    next.prev = newElems[newElems.length - 1];
  }
  return array.splice.apply(array, spliceArgs);
}
function appendTo(target) {
  var appendTarget = (0, utils_js_1$3.isCheerio)(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
manipulation$1.appendTo = appendTo;
function prependTo(target) {
  var prependTarget = (0, utils_js_1$3.isCheerio)(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
manipulation$1.prependTo = prependTo;
manipulation$1.append = _insert(function(dom, children, parent) {
  uniqueSplice(children, children.length, 0, dom, parent);
});
manipulation$1.prepend = _insert(function(dom, children, parent) {
  uniqueSplice(children, 0, 0, dom, parent);
});
function _wrap(insert) {
  return function(wrapper) {
    var lastIdx = this.length - 1;
    var lastParent = this.parents().last();
    for (var i2 = 0; i2 < this.length; i2++) {
      var el = this[i2];
      var wrap_1 = typeof wrapper === "function" ? wrapper.call(el, i2, el) : typeof wrapper === "string" && !(0, utils_js_1$3.isHtml)(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
      var wrapperDom = this._makeDomArray(wrap_1, i2 < lastIdx)[0];
      if (!wrapperDom || !(0, domhandler_1$5.hasChildren)(wrapperDom))
        continue;
      var elInsertLocation = wrapperDom;
      var j2 = 0;
      while (j2 < elInsertLocation.children.length) {
        var child = elInsertLocation.children[j2];
        if ((0, utils_js_1$3.isTag)(child)) {
          elInsertLocation = child;
          j2 = 0;
        } else {
          j2++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
manipulation$1.wrap = _wrap(function(el, elInsertLocation, wrapperDom) {
  var parent = el.parent;
  if (!parent)
    return;
  var siblings2 = parent.children;
  var index2 = siblings2.indexOf(el);
  (0, parse_js_1.update)([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent);
});
manipulation$1.wrapInner = _wrap(function(el, elInsertLocation, wrapperDom) {
  if (!(0, domhandler_1$5.hasChildren)(el))
    return;
  (0, parse_js_1.update)(el.children, elInsertLocation);
  (0, parse_js_1.update)(wrapperDom, el);
});
function unwrap(selector2) {
  var _this = this;
  this.parent(selector2).not("body").each(function(_2, el) {
    _this._make(el).replaceWith(el.children);
  });
  return this;
}
manipulation$1.unwrap = unwrap;
function wrapAll(wrapper) {
  var el = this[0];
  if (el) {
    var wrap_2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
    var elInsertLocation = void 0;
    for (var i2 = 0; i2 < wrap_2.length; i2++) {
      if (wrap_2[i2].type === "tag")
        elInsertLocation = wrap_2[i2];
    }
    var j2 = 0;
    while (elInsertLocation && j2 < elInsertLocation.children.length) {
      var child = elInsertLocation.children[j2];
      if (child.type === "tag") {
        elInsertLocation = child;
        j2 = 0;
      } else {
        j2++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
manipulation$1.wrapAll = wrapAll;
function after() {
  var _this = this;
  var elems = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    elems[_i] = arguments[_i];
  }
  var lastIdx = this.length - 1;
  return (0, utils_js_1$3.domEach)(this, function(el, i2) {
    var parent = el.parent;
    if (!(0, domhandler_1$5.hasChildren)(el) || !parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i2, _this._render(el.children)) : elems;
    var dom = _this._makeDomArray(domSrc, i2 < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, parent);
  });
}
manipulation$1.after = after;
function insertAfter(target) {
  var _this = this;
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  var clones = [];
  this._makeDomArray(target).forEach(function(el) {
    var clonedSelf = _this.clone().toArray();
    var parent = el.parent;
    if (!parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent);
    clones.push.apply(clones, clonedSelf);
  });
  return this._make(clones);
}
manipulation$1.insertAfter = insertAfter;
function before() {
  var _this = this;
  var elems = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    elems[_i] = arguments[_i];
  }
  var lastIdx = this.length - 1;
  return (0, utils_js_1$3.domEach)(this, function(el, i2) {
    var parent = el.parent;
    if (!(0, domhandler_1$5.hasChildren)(el) || !parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    var domSrc = typeof elems[0] === "function" ? elems[0].call(el, i2, _this._render(el.children)) : elems;
    var dom = _this._makeDomArray(domSrc, i2 < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, parent);
  });
}
manipulation$1.before = before;
function insertBefore(target) {
  var _this = this;
  var targetArr = this._make(target);
  this.remove();
  var clones = [];
  (0, utils_js_1$3.domEach)(targetArr, function(el) {
    var clonedSelf = _this.clone().toArray();
    var parent = el.parent;
    if (!parent) {
      return;
    }
    var siblings2 = parent.children;
    var index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent);
    clones.push.apply(clones, clonedSelf);
  });
  return this._make(clones);
}
manipulation$1.insertBefore = insertBefore;
function remove(selector2) {
  var elems = selector2 ? this.filter(selector2) : this;
  (0, utils_js_1$3.domEach)(elems, function(el) {
    (0, domutils_1.removeElement)(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
manipulation$1.remove = remove;
function replaceWith(content) {
  var _this = this;
  return (0, utils_js_1$3.domEach)(this, function(el, i2) {
    var parent = el.parent;
    if (!parent) {
      return;
    }
    var siblings2 = parent.children;
    var cont = typeof content === "function" ? content.call(el, i2, el) : content;
    var dom = _this._makeDomArray(cont);
    (0, parse_js_1.update)(dom, null);
    var index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom, parent);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
manipulation$1.replaceWith = replaceWith;
function empty$4() {
  return (0, utils_js_1$3.domEach)(this, function(el) {
    if (!(0, domhandler_1$5.hasChildren)(el))
      return;
    el.children.forEach(function(child) {
      child.next = child.prev = child.parent = null;
    });
    el.children.length = 0;
  });
}
manipulation$1.empty = empty$4;
function html$5(str) {
  var _this = this;
  if (str === void 0) {
    var el = this[0];
    if (!el || !(0, domhandler_1$5.hasChildren)(el))
      return null;
    return this._render(el.children);
  }
  return (0, utils_js_1$3.domEach)(this, function(el2) {
    if (!(0, domhandler_1$5.hasChildren)(el2))
      return;
    el2.children.forEach(function(child) {
      child.next = child.prev = child.parent = null;
    });
    var content = (0, utils_js_1$3.isCheerio)(str) ? str.toArray() : _this._parse("".concat(str), _this.options, false, el2).children;
    (0, parse_js_1.update)(content, el2);
  });
}
manipulation$1.html = html$5;
function toString$1() {
  return this._render(this);
}
manipulation$1.toString = toString$1;
function text$1(str) {
  var _this = this;
  if (str === void 0) {
    return (0, static_js_1.text)(this);
  }
  if (typeof str === "function") {
    return (0, utils_js_1$3.domEach)(this, function(el, i2) {
      return _this._make(el).text(str.call(el, i2, (0, static_js_1.text)([el])));
    });
  }
  return (0, utils_js_1$3.domEach)(this, function(el) {
    if (!(0, domhandler_1$5.hasChildren)(el))
      return;
    el.children.forEach(function(child) {
      child.next = child.prev = child.parent = null;
    });
    var textNode = new domhandler_1$5.Text("".concat(str));
    (0, parse_js_1.update)(textNode, el);
  });
}
manipulation$1.text = text$1;
function clone() {
  return this._make((0, utils_js_1$3.cloneDom)(this.get()));
}
manipulation$1.clone = clone;
var css$1 = {};
Object.defineProperty(css$1, "__esModule", { value: true });
css$1.css = void 0;
var utils_js_1$2 = utils$2;
function css(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return (0, utils_js_1$2.domEach)(this, function(el, i2) {
      if ((0, utils_js_1$2.isTag)(el)) {
        setCss(el, prop2, val2, i2);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
css$1.css = css;
function setCss(el, prop2, value, idx) {
  if (typeof prop2 === "string") {
    var styles = getCss(el);
    var val2 = typeof value === "function" ? value.call(el, idx, styles[prop2]) : value;
    if (val2 === "") {
      delete styles[prop2];
    } else if (val2 != null) {
      styles[prop2] = val2;
    }
    el.attribs["style"] = stringify$4(styles);
  } else if (typeof prop2 === "object") {
    Object.keys(prop2).forEach(function(k2, i2) {
      setCss(el, k2, prop2[k2], i2);
    });
  }
}
function getCss(el, prop2) {
  if (!el || !(0, utils_js_1$2.isTag)(el))
    return;
  var styles = parse$4(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles[prop2];
  }
  if (Array.isArray(prop2)) {
    var newStyles_1 = {};
    prop2.forEach(function(item) {
      if (styles[item] != null) {
        newStyles_1[item] = styles[item];
      }
    });
    return newStyles_1;
  }
  return styles;
}
function stringify$4(obj) {
  return Object.keys(obj).reduce(function(str, prop2) {
    return "".concat(str).concat(str ? " " : "").concat(prop2, ": ").concat(obj[prop2], ";");
  }, "");
}
function parse$4(styles) {
  styles = (styles || "").trim();
  if (!styles)
    return {};
  var obj = {};
  var key2;
  for (var _i = 0, _a = styles.split(";"); _i < _a.length; _i++) {
    var str = _a[_i];
    var n2 = str.indexOf(":");
    if (n2 < 1 || n2 === str.length - 1) {
      var trimmed = str.trimEnd();
      if (trimmed.length > 0 && key2 !== void 0) {
        obj[key2] += ";".concat(trimmed);
      }
    } else {
      key2 = str.slice(0, n2).trim();
      obj[key2] = str.slice(n2 + 1).trim();
    }
  }
  return obj;
}
var forms = {};
Object.defineProperty(forms, "__esModule", { value: true });
forms.serializeArray = forms.serialize = void 0;
var utils_js_1$1 = utils$2;
var submittableSelector = "input,select,textarea,keygen";
var r20 = /%20/g;
var rCRLF = /\r?\n/g;
function serialize$1() {
  var arr = this.serializeArray();
  var retArr = arr.map(function(data2) {
    return "".concat(encodeURIComponent(data2.name), "=").concat(encodeURIComponent(data2.value));
  });
  return retArr.join("&").replace(r20, "+");
}
forms.serialize = serialize$1;
function serializeArray() {
  var _this = this;
  return this.map(function(_2, elem) {
    var $elem = _this._make(elem);
    if ((0, utils_js_1$1.isTag)(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
  ).map(function(_2, elem) {
    var _a;
    var $elem = _this._make(elem);
    var name2 = $elem.attr("name");
    var value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : "";
    if (Array.isArray(value)) {
      return value.map(function(val2) {
        return { name: name2, value: val2.replace(rCRLF, "\r\n") };
      });
    }
    return { name: name2, value: value.replace(rCRLF, "\r\n") };
  }).toArray();
}
forms.serializeArray = serializeArray;
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$3(result, mod, k2);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
Object.defineProperty(cheerio$1, "__esModule", { value: true });
cheerio$1.Cheerio = void 0;
var Attributes = __importStar$3(attributes$3);
var Traversing = __importStar$3(traversing);
var Manipulation = __importStar$3(manipulation$1);
var Css = __importStar$3(css$1);
var Forms = __importStar$3(forms);
var Cheerio = (
  /** @class */
  function() {
    function Cheerio2(elements, root2, options2) {
      this.length = 0;
      this.options = options2;
      this._root = root2;
      if (elements) {
        for (var idx = 0; idx < elements.length; idx++) {
          this[idx] = elements[idx];
        }
        this.length = elements.length;
      }
    }
    return Cheerio2;
  }()
);
cheerio$1.Cheerio = Cheerio;
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$3 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$2(result, mod, k2);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
Object.defineProperty(load, "__esModule", { value: true });
load.getLoad = void 0;
var options_js_1 = __importStar$2(options);
var staticMethods = __importStar$2(_static);
var cheerio_js_1 = cheerio$1;
var utils_js_1 = utils$2;
function getLoad(parse2, render2) {
  return function load2(content, options2, isDocument2) {
    if (isDocument2 === void 0) {
      isDocument2 = true;
    }
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    var internalOpts = __assign$3(__assign$3({}, options_js_1.default), (0, options_js_1.flatten)(options2));
    var initialRoot = parse2(content, internalOpts, isDocument2, null);
    var LoadedCheerio = (
      /** @class */
      function(_super) {
        __extends$2(LoadedCheerio2, _super);
        function LoadedCheerio2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        LoadedCheerio2.prototype._make = function(selector2, context) {
          var cheerio2 = initialize(selector2, context);
          cheerio2.prevObject = this;
          return cheerio2;
        };
        LoadedCheerio2.prototype._parse = function(content2, options3, isDocument3, context) {
          return parse2(content2, options3, isDocument3, context);
        };
        LoadedCheerio2.prototype._render = function(dom) {
          return render2(dom, this.options);
        };
        return LoadedCheerio2;
      }(cheerio_js_1.Cheerio)
    );
    function initialize(selector2, context, root2, opts) {
      if (root2 === void 0) {
        root2 = initialRoot;
      }
      if (selector2 && (0, utils_js_1.isCheerio)(selector2))
        return selector2;
      var options3 = __assign$3(__assign$3({}, internalOpts), (0, options_js_1.flatten)(opts));
      var r2 = typeof root2 === "string" ? [parse2(root2, options3, false, null)] : "length" in root2 ? root2 : [root2];
      var rootInstance = (0, utils_js_1.isCheerio)(r2) ? r2 : new LoadedCheerio(r2, null, options3);
      rootInstance._root = rootInstance;
      if (!selector2) {
        return new LoadedCheerio(void 0, rootInstance, options3);
      }
      var elements = typeof selector2 === "string" && (0, utils_js_1.isHtml)(selector2) ? (
        // $(<html>)
        parse2(selector2, options3, false, null).children
      ) : isNode(selector2) ? (
        // $(dom)
        [selector2]
      ) : Array.isArray(selector2) ? (
        // $([dom])
        selector2
      ) : void 0;
      var instance = new LoadedCheerio(elements, rootInstance, options3);
      if (elements) {
        return instance;
      }
      if (typeof selector2 !== "string") {
        throw new Error("Unexpected type of selector");
      }
      var search2 = selector2;
      var searchContext = !context ? (
        // If we don't have a context, maybe we have a root, from loading
        rootInstance
      ) : typeof context === "string" ? (0, utils_js_1.isHtml)(context) ? (
        // $('li', '<ul>...</ul>')
        new LoadedCheerio([parse2(context, options3, false, null)], rootInstance, options3)
      ) : (
        // $('li', 'ul')
        (search2 = "".concat(context, " ").concat(search2), rootInstance)
      ) : (0, utils_js_1.isCheerio)(context) ? (
        // $('li', $)
        context
      ) : (
        // $('li', node), $('li', [nodes])
        new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options3)
      );
      if (!searchContext)
        return instance;
      return searchContext.find(search2);
    }
    Object.assign(initialize, staticMethods, {
      load: load2,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
load.getLoad = getLoad;
function isNode(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}
var parse5Adapter = {};
var cjs$1 = {};
var parser$2 = {};
var tokenizer = {};
var preprocessor = {};
var unicode$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isUndefinedCodePoint = exports2.isControlCodePoint = exports2.getSurrogatePairCodePoint = exports2.isSurrogatePair = exports2.isSurrogate = exports2.SEQUENCES = exports2.CODE_POINTS = exports2.REPLACEMENT_CHARACTER = void 0;
  const UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
    65534,
    65535,
    131070,
    131071,
    196606,
    196607,
    262142,
    262143,
    327678,
    327679,
    393214,
    393215,
    458750,
    458751,
    524286,
    524287,
    589822,
    589823,
    655358,
    655359,
    720894,
    720895,
    786430,
    786431,
    851966,
    851967,
    917502,
    917503,
    983038,
    983039,
    1048574,
    1048575,
    1114110,
    1114111
  ]);
  exports2.REPLACEMENT_CHARACTER = "";
  (function(CODE_POINTS) {
    CODE_POINTS[CODE_POINTS["EOF"] = -1] = "EOF";
    CODE_POINTS[CODE_POINTS["NULL"] = 0] = "NULL";
    CODE_POINTS[CODE_POINTS["TABULATION"] = 9] = "TABULATION";
    CODE_POINTS[CODE_POINTS["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
    CODE_POINTS[CODE_POINTS["LINE_FEED"] = 10] = "LINE_FEED";
    CODE_POINTS[CODE_POINTS["FORM_FEED"] = 12] = "FORM_FEED";
    CODE_POINTS[CODE_POINTS["SPACE"] = 32] = "SPACE";
    CODE_POINTS[CODE_POINTS["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
    CODE_POINTS[CODE_POINTS["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
    CODE_POINTS[CODE_POINTS["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
    CODE_POINTS[CODE_POINTS["AMPERSAND"] = 38] = "AMPERSAND";
    CODE_POINTS[CODE_POINTS["APOSTROPHE"] = 39] = "APOSTROPHE";
    CODE_POINTS[CODE_POINTS["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
    CODE_POINTS[CODE_POINTS["SOLIDUS"] = 47] = "SOLIDUS";
    CODE_POINTS[CODE_POINTS["DIGIT_0"] = 48] = "DIGIT_0";
    CODE_POINTS[CODE_POINTS["DIGIT_9"] = 57] = "DIGIT_9";
    CODE_POINTS[CODE_POINTS["SEMICOLON"] = 59] = "SEMICOLON";
    CODE_POINTS[CODE_POINTS["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
    CODE_POINTS[CODE_POINTS["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
    CODE_POINTS[CODE_POINTS["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
    CODE_POINTS[CODE_POINTS["QUESTION_MARK"] = 63] = "QUESTION_MARK";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
    CODE_POINTS[CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
    CODE_POINTS[CODE_POINTS["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
    CODE_POINTS[CODE_POINTS["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
    CODE_POINTS[CODE_POINTS["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
  })(exports2.CODE_POINTS || (exports2.CODE_POINTS = {}));
  exports2.SEQUENCES = {
    DASH_DASH: "--",
    CDATA_START: "[CDATA[",
    DOCTYPE: "doctype",
    SCRIPT: "script",
    PUBLIC: "public",
    SYSTEM: "system"
  };
  function isSurrogate(cp) {
    return cp >= 55296 && cp <= 57343;
  }
  exports2.isSurrogate = isSurrogate;
  function isSurrogatePair(cp) {
    return cp >= 56320 && cp <= 57343;
  }
  exports2.isSurrogatePair = isSurrogatePair;
  function getSurrogatePairCodePoint(cp1, cp2) {
    return (cp1 - 55296) * 1024 + 9216 + cp2;
  }
  exports2.getSurrogatePairCodePoint = getSurrogatePairCodePoint;
  function isControlCodePoint(cp) {
    return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
  }
  exports2.isControlCodePoint = isControlCodePoint;
  function isUndefinedCodePoint(cp) {
    return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
  }
  exports2.isUndefinedCodePoint = isUndefinedCodePoint;
})(unicode$1);
var errorCodes = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ERR = void 0;
  (function(ERR) {
    ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
    ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
    ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
    ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
    ERR["endTagWithAttributes"] = "end-tag-with-attributes";
    ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
    ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
    ERR["unexpectedNullCharacter"] = "unexpected-null-character";
    ERR["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
    ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
    ERR["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
    ERR["missingEndTagName"] = "missing-end-tag-name";
    ERR["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
    ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
    ERR["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
    ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
    ERR["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
    ERR["eofBeforeTagName"] = "eof-before-tag-name";
    ERR["eofInTag"] = "eof-in-tag";
    ERR["missingAttributeValue"] = "missing-attribute-value";
    ERR["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
    ERR["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
    ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
    ERR["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
    ERR["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
    ERR["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
    ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
    ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
    ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
    ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
    ERR["cdataInHtmlContent"] = "cdata-in-html-content";
    ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
    ERR["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
    ERR["eofInDoctype"] = "eof-in-doctype";
    ERR["nestedComment"] = "nested-comment";
    ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
    ERR["eofInComment"] = "eof-in-comment";
    ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
    ERR["eofInCdata"] = "eof-in-cdata";
    ERR["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
    ERR["nullCharacterReference"] = "null-character-reference";
    ERR["surrogateCharacterReference"] = "surrogate-character-reference";
    ERR["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
    ERR["controlCharacterReference"] = "control-character-reference";
    ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
    ERR["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
    ERR["missingDoctypeName"] = "missing-doctype-name";
    ERR["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
    ERR["duplicateAttribute"] = "duplicate-attribute";
    ERR["nonConformingDoctype"] = "non-conforming-doctype";
    ERR["missingDoctype"] = "missing-doctype";
    ERR["misplacedDoctype"] = "misplaced-doctype";
    ERR["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
    ERR["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
    ERR["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
    ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
    ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
    ERR["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
    ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
    ERR["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
  })(exports2.ERR || (exports2.ERR = {}));
})(errorCodes);
Object.defineProperty(preprocessor, "__esModule", { value: true });
preprocessor.Preprocessor = void 0;
const unicode_js_1$1 = unicode$1;
const error_codes_js_1$2 = errorCodes;
const DEFAULT_BUFFER_WATERLINE = 1 << 16;
class Preprocessor {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code2) {
    const { line, col, offset } = this;
    return {
      code: code2,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset
    };
  }
  _err(code2) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code2));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if ((0, unicode_js_1$1.isSurrogatePair)(nextCp)) {
        this.pos++;
        this._addGap();
        return (0, unicode_js_1$1.getSurrogatePairCodePoint)(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return unicode_js_1$1.CODE_POINTS.EOF;
    }
    this._err(error_codes_js_1$2.ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i2 = 0; i2 < pattern.length; i2++) {
      const cp = this.html.charCodeAt(this.pos + i2) | 32;
      if (cp !== pattern.charCodeAt(i2)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return unicode_js_1$1.CODE_POINTS.EOF;
    }
    const code2 = this.html.charCodeAt(pos);
    return code2 === unicode_js_1$1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1$1.CODE_POINTS.LINE_FEED : code2;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return unicode_js_1$1.CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === unicode_js_1$1.CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return unicode_js_1$1.CODE_POINTS.LINE_FEED;
    }
    if (cp === unicode_js_1$1.CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if ((0, unicode_js_1$1.isSurrogate)(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === unicode_js_1$1.CODE_POINTS.LINE_FEED || cp === unicode_js_1$1.CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if ((0, unicode_js_1$1.isControlCodePoint)(cp)) {
      this._err(error_codes_js_1$2.ERR.controlCharacterInInputStream);
    } else if ((0, unicode_js_1$1.isUndefinedCodePoint)(cp)) {
      this._err(error_codes_js_1$2.ERR.noncharacterInInputStream);
    }
  }
  retreat(count2) {
    this.pos -= count2;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
}
preprocessor.Preprocessor = Preprocessor;
var token = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getTokenAttr = exports2.TokenType = void 0;
  (function(TokenType) {
    TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
    TokenType[TokenType["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
    TokenType[TokenType["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
    TokenType[TokenType["START_TAG"] = 3] = "START_TAG";
    TokenType[TokenType["END_TAG"] = 4] = "END_TAG";
    TokenType[TokenType["COMMENT"] = 5] = "COMMENT";
    TokenType[TokenType["DOCTYPE"] = 6] = "DOCTYPE";
    TokenType[TokenType["EOF"] = 7] = "EOF";
    TokenType[TokenType["HIBERNATION"] = 8] = "HIBERNATION";
  })(exports2.TokenType || (exports2.TokenType = {}));
  function getTokenAttr(token2, attrName) {
    for (let i2 = token2.attrs.length - 1; i2 >= 0; i2--) {
      if (token2.attrs[i2].name === attrName) {
        return token2.attrs[i2].value;
      }
    }
    return null;
  }
  exports2.getTokenAttr = getTokenAttr;
})(token);
var decode$1 = {};
var decodeDataHtml$1 = {};
Object.defineProperty(decodeDataHtml$1, "__esModule", { value: true });
decodeDataHtml$1.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decodeDataXml$1 = {};
Object.defineProperty(decodeDataXml$1, "__esModule", { value: true });
decodeDataXml$1.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decode_codepoint$1 = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml$1);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml$1);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint$1);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint$1;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode$1);
var html$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasUnescapedText = exports2.isNumberedHeader = exports2.SPECIAL_ELEMENTS = exports2.getTagID = exports2.TAG_ID = exports2.TAG_NAMES = exports2.DOCUMENT_MODE = exports2.ATTRS = exports2.NS = void 0;
  var NS;
  (function(NS2) {
    NS2["HTML"] = "http://www.w3.org/1999/xhtml";
    NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
    NS2["SVG"] = "http://www.w3.org/2000/svg";
    NS2["XLINK"] = "http://www.w3.org/1999/xlink";
    NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
    NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
  })(NS = exports2.NS || (exports2.NS = {}));
  (function(ATTRS) {
    ATTRS["TYPE"] = "type";
    ATTRS["ACTION"] = "action";
    ATTRS["ENCODING"] = "encoding";
    ATTRS["PROMPT"] = "prompt";
    ATTRS["NAME"] = "name";
    ATTRS["COLOR"] = "color";
    ATTRS["FACE"] = "face";
    ATTRS["SIZE"] = "size";
  })(exports2.ATTRS || (exports2.ATTRS = {}));
  (function(DOCUMENT_MODE) {
    DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
    DOCUMENT_MODE["QUIRKS"] = "quirks";
    DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
  })(exports2.DOCUMENT_MODE || (exports2.DOCUMENT_MODE = {}));
  var TAG_NAMES;
  (function(TAG_NAMES2) {
    TAG_NAMES2["A"] = "a";
    TAG_NAMES2["ADDRESS"] = "address";
    TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
    TAG_NAMES2["APPLET"] = "applet";
    TAG_NAMES2["AREA"] = "area";
    TAG_NAMES2["ARTICLE"] = "article";
    TAG_NAMES2["ASIDE"] = "aside";
    TAG_NAMES2["B"] = "b";
    TAG_NAMES2["BASE"] = "base";
    TAG_NAMES2["BASEFONT"] = "basefont";
    TAG_NAMES2["BGSOUND"] = "bgsound";
    TAG_NAMES2["BIG"] = "big";
    TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
    TAG_NAMES2["BODY"] = "body";
    TAG_NAMES2["BR"] = "br";
    TAG_NAMES2["BUTTON"] = "button";
    TAG_NAMES2["CAPTION"] = "caption";
    TAG_NAMES2["CENTER"] = "center";
    TAG_NAMES2["CODE"] = "code";
    TAG_NAMES2["COL"] = "col";
    TAG_NAMES2["COLGROUP"] = "colgroup";
    TAG_NAMES2["DD"] = "dd";
    TAG_NAMES2["DESC"] = "desc";
    TAG_NAMES2["DETAILS"] = "details";
    TAG_NAMES2["DIALOG"] = "dialog";
    TAG_NAMES2["DIR"] = "dir";
    TAG_NAMES2["DIV"] = "div";
    TAG_NAMES2["DL"] = "dl";
    TAG_NAMES2["DT"] = "dt";
    TAG_NAMES2["EM"] = "em";
    TAG_NAMES2["EMBED"] = "embed";
    TAG_NAMES2["FIELDSET"] = "fieldset";
    TAG_NAMES2["FIGCAPTION"] = "figcaption";
    TAG_NAMES2["FIGURE"] = "figure";
    TAG_NAMES2["FONT"] = "font";
    TAG_NAMES2["FOOTER"] = "footer";
    TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
    TAG_NAMES2["FORM"] = "form";
    TAG_NAMES2["FRAME"] = "frame";
    TAG_NAMES2["FRAMESET"] = "frameset";
    TAG_NAMES2["H1"] = "h1";
    TAG_NAMES2["H2"] = "h2";
    TAG_NAMES2["H3"] = "h3";
    TAG_NAMES2["H4"] = "h4";
    TAG_NAMES2["H5"] = "h5";
    TAG_NAMES2["H6"] = "h6";
    TAG_NAMES2["HEAD"] = "head";
    TAG_NAMES2["HEADER"] = "header";
    TAG_NAMES2["HGROUP"] = "hgroup";
    TAG_NAMES2["HR"] = "hr";
    TAG_NAMES2["HTML"] = "html";
    TAG_NAMES2["I"] = "i";
    TAG_NAMES2["IMG"] = "img";
    TAG_NAMES2["IMAGE"] = "image";
    TAG_NAMES2["INPUT"] = "input";
    TAG_NAMES2["IFRAME"] = "iframe";
    TAG_NAMES2["KEYGEN"] = "keygen";
    TAG_NAMES2["LABEL"] = "label";
    TAG_NAMES2["LI"] = "li";
    TAG_NAMES2["LINK"] = "link";
    TAG_NAMES2["LISTING"] = "listing";
    TAG_NAMES2["MAIN"] = "main";
    TAG_NAMES2["MALIGNMARK"] = "malignmark";
    TAG_NAMES2["MARQUEE"] = "marquee";
    TAG_NAMES2["MATH"] = "math";
    TAG_NAMES2["MENU"] = "menu";
    TAG_NAMES2["META"] = "meta";
    TAG_NAMES2["MGLYPH"] = "mglyph";
    TAG_NAMES2["MI"] = "mi";
    TAG_NAMES2["MO"] = "mo";
    TAG_NAMES2["MN"] = "mn";
    TAG_NAMES2["MS"] = "ms";
    TAG_NAMES2["MTEXT"] = "mtext";
    TAG_NAMES2["NAV"] = "nav";
    TAG_NAMES2["NOBR"] = "nobr";
    TAG_NAMES2["NOFRAMES"] = "noframes";
    TAG_NAMES2["NOEMBED"] = "noembed";
    TAG_NAMES2["NOSCRIPT"] = "noscript";
    TAG_NAMES2["OBJECT"] = "object";
    TAG_NAMES2["OL"] = "ol";
    TAG_NAMES2["OPTGROUP"] = "optgroup";
    TAG_NAMES2["OPTION"] = "option";
    TAG_NAMES2["P"] = "p";
    TAG_NAMES2["PARAM"] = "param";
    TAG_NAMES2["PLAINTEXT"] = "plaintext";
    TAG_NAMES2["PRE"] = "pre";
    TAG_NAMES2["RB"] = "rb";
    TAG_NAMES2["RP"] = "rp";
    TAG_NAMES2["RT"] = "rt";
    TAG_NAMES2["RTC"] = "rtc";
    TAG_NAMES2["RUBY"] = "ruby";
    TAG_NAMES2["S"] = "s";
    TAG_NAMES2["SCRIPT"] = "script";
    TAG_NAMES2["SECTION"] = "section";
    TAG_NAMES2["SELECT"] = "select";
    TAG_NAMES2["SOURCE"] = "source";
    TAG_NAMES2["SMALL"] = "small";
    TAG_NAMES2["SPAN"] = "span";
    TAG_NAMES2["STRIKE"] = "strike";
    TAG_NAMES2["STRONG"] = "strong";
    TAG_NAMES2["STYLE"] = "style";
    TAG_NAMES2["SUB"] = "sub";
    TAG_NAMES2["SUMMARY"] = "summary";
    TAG_NAMES2["SUP"] = "sup";
    TAG_NAMES2["TABLE"] = "table";
    TAG_NAMES2["TBODY"] = "tbody";
    TAG_NAMES2["TEMPLATE"] = "template";
    TAG_NAMES2["TEXTAREA"] = "textarea";
    TAG_NAMES2["TFOOT"] = "tfoot";
    TAG_NAMES2["TD"] = "td";
    TAG_NAMES2["TH"] = "th";
    TAG_NAMES2["THEAD"] = "thead";
    TAG_NAMES2["TITLE"] = "title";
    TAG_NAMES2["TR"] = "tr";
    TAG_NAMES2["TRACK"] = "track";
    TAG_NAMES2["TT"] = "tt";
    TAG_NAMES2["U"] = "u";
    TAG_NAMES2["UL"] = "ul";
    TAG_NAMES2["SVG"] = "svg";
    TAG_NAMES2["VAR"] = "var";
    TAG_NAMES2["WBR"] = "wbr";
    TAG_NAMES2["XMP"] = "xmp";
  })(TAG_NAMES = exports2.TAG_NAMES || (exports2.TAG_NAMES = {}));
  var TAG_ID;
  (function(TAG_ID2) {
    TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
    TAG_ID2[TAG_ID2["A"] = 1] = "A";
    TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
    TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
    TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
    TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
    TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
    TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
    TAG_ID2[TAG_ID2["B"] = 8] = "B";
    TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
    TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
    TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
    TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
    TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
    TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
    TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
    TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
    TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
    TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
    TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
    TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
    TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
    TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
    TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
    TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
    TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
    TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
    TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
    TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
    TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
    TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
    TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
    TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
    TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
    TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
    TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
    TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
    TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
    TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
    TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
    TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
    TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
    TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
    TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
    TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
    TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
    TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
    TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
    TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
    TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
    TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
    TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
    TAG_ID2[TAG_ID2["I"] = 52] = "I";
    TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
    TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
    TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
    TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
    TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
    TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
    TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
    TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
    TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
    TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
    TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
    TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
    TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
    TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
    TAG_ID2[TAG_ID2["META"] = 67] = "META";
    TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
    TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
    TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
    TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
    TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
    TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
    TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
    TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
    TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
    TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
    TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
    TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
    TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
    TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
    TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
    TAG_ID2[TAG_ID2["P"] = 83] = "P";
    TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
    TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
    TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
    TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
    TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
    TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
    TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
    TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
    TAG_ID2[TAG_ID2["S"] = 92] = "S";
    TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
    TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
    TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
    TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
    TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
    TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
    TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
    TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
    TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
    TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
    TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
    TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
    TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
    TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
    TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
    TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
    TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
    TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
    TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
    TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
    TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
    TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
    TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
    TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
    TAG_ID2[TAG_ID2["U"] = 117] = "U";
    TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
    TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
    TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
    TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
    TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
  })(TAG_ID = exports2.TAG_ID || (exports2.TAG_ID = {}));
  const TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
    [TAG_NAMES.A, TAG_ID.A],
    [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
    [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
    [TAG_NAMES.APPLET, TAG_ID.APPLET],
    [TAG_NAMES.AREA, TAG_ID.AREA],
    [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
    [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
    [TAG_NAMES.B, TAG_ID.B],
    [TAG_NAMES.BASE, TAG_ID.BASE],
    [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
    [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
    [TAG_NAMES.BIG, TAG_ID.BIG],
    [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
    [TAG_NAMES.BODY, TAG_ID.BODY],
    [TAG_NAMES.BR, TAG_ID.BR],
    [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
    [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
    [TAG_NAMES.CENTER, TAG_ID.CENTER],
    [TAG_NAMES.CODE, TAG_ID.CODE],
    [TAG_NAMES.COL, TAG_ID.COL],
    [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
    [TAG_NAMES.DD, TAG_ID.DD],
    [TAG_NAMES.DESC, TAG_ID.DESC],
    [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
    [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
    [TAG_NAMES.DIR, TAG_ID.DIR],
    [TAG_NAMES.DIV, TAG_ID.DIV],
    [TAG_NAMES.DL, TAG_ID.DL],
    [TAG_NAMES.DT, TAG_ID.DT],
    [TAG_NAMES.EM, TAG_ID.EM],
    [TAG_NAMES.EMBED, TAG_ID.EMBED],
    [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
    [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
    [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
    [TAG_NAMES.FONT, TAG_ID.FONT],
    [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
    [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
    [TAG_NAMES.FORM, TAG_ID.FORM],
    [TAG_NAMES.FRAME, TAG_ID.FRAME],
    [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
    [TAG_NAMES.H1, TAG_ID.H1],
    [TAG_NAMES.H2, TAG_ID.H2],
    [TAG_NAMES.H3, TAG_ID.H3],
    [TAG_NAMES.H4, TAG_ID.H4],
    [TAG_NAMES.H5, TAG_ID.H5],
    [TAG_NAMES.H6, TAG_ID.H6],
    [TAG_NAMES.HEAD, TAG_ID.HEAD],
    [TAG_NAMES.HEADER, TAG_ID.HEADER],
    [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
    [TAG_NAMES.HR, TAG_ID.HR],
    [TAG_NAMES.HTML, TAG_ID.HTML],
    [TAG_NAMES.I, TAG_ID.I],
    [TAG_NAMES.IMG, TAG_ID.IMG],
    [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
    [TAG_NAMES.INPUT, TAG_ID.INPUT],
    [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
    [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
    [TAG_NAMES.LABEL, TAG_ID.LABEL],
    [TAG_NAMES.LI, TAG_ID.LI],
    [TAG_NAMES.LINK, TAG_ID.LINK],
    [TAG_NAMES.LISTING, TAG_ID.LISTING],
    [TAG_NAMES.MAIN, TAG_ID.MAIN],
    [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
    [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
    [TAG_NAMES.MATH, TAG_ID.MATH],
    [TAG_NAMES.MENU, TAG_ID.MENU],
    [TAG_NAMES.META, TAG_ID.META],
    [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
    [TAG_NAMES.MI, TAG_ID.MI],
    [TAG_NAMES.MO, TAG_ID.MO],
    [TAG_NAMES.MN, TAG_ID.MN],
    [TAG_NAMES.MS, TAG_ID.MS],
    [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
    [TAG_NAMES.NAV, TAG_ID.NAV],
    [TAG_NAMES.NOBR, TAG_ID.NOBR],
    [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
    [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
    [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
    [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
    [TAG_NAMES.OL, TAG_ID.OL],
    [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
    [TAG_NAMES.OPTION, TAG_ID.OPTION],
    [TAG_NAMES.P, TAG_ID.P],
    [TAG_NAMES.PARAM, TAG_ID.PARAM],
    [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
    [TAG_NAMES.PRE, TAG_ID.PRE],
    [TAG_NAMES.RB, TAG_ID.RB],
    [TAG_NAMES.RP, TAG_ID.RP],
    [TAG_NAMES.RT, TAG_ID.RT],
    [TAG_NAMES.RTC, TAG_ID.RTC],
    [TAG_NAMES.RUBY, TAG_ID.RUBY],
    [TAG_NAMES.S, TAG_ID.S],
    [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
    [TAG_NAMES.SECTION, TAG_ID.SECTION],
    [TAG_NAMES.SELECT, TAG_ID.SELECT],
    [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
    [TAG_NAMES.SMALL, TAG_ID.SMALL],
    [TAG_NAMES.SPAN, TAG_ID.SPAN],
    [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
    [TAG_NAMES.STRONG, TAG_ID.STRONG],
    [TAG_NAMES.STYLE, TAG_ID.STYLE],
    [TAG_NAMES.SUB, TAG_ID.SUB],
    [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
    [TAG_NAMES.SUP, TAG_ID.SUP],
    [TAG_NAMES.TABLE, TAG_ID.TABLE],
    [TAG_NAMES.TBODY, TAG_ID.TBODY],
    [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
    [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
    [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
    [TAG_NAMES.TD, TAG_ID.TD],
    [TAG_NAMES.TH, TAG_ID.TH],
    [TAG_NAMES.THEAD, TAG_ID.THEAD],
    [TAG_NAMES.TITLE, TAG_ID.TITLE],
    [TAG_NAMES.TR, TAG_ID.TR],
    [TAG_NAMES.TRACK, TAG_ID.TRACK],
    [TAG_NAMES.TT, TAG_ID.TT],
    [TAG_NAMES.U, TAG_ID.U],
    [TAG_NAMES.UL, TAG_ID.UL],
    [TAG_NAMES.SVG, TAG_ID.SVG],
    [TAG_NAMES.VAR, TAG_ID.VAR],
    [TAG_NAMES.WBR, TAG_ID.WBR],
    [TAG_NAMES.XMP, TAG_ID.XMP]
  ]);
  function getTagID(tagName) {
    var _a;
    return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0 ? _a : TAG_ID.UNKNOWN;
  }
  exports2.getTagID = getTagID;
  const $2 = TAG_ID;
  exports2.SPECIAL_ELEMENTS = {
    [NS.HTML]: /* @__PURE__ */ new Set([
      $2.ADDRESS,
      $2.APPLET,
      $2.AREA,
      $2.ARTICLE,
      $2.ASIDE,
      $2.BASE,
      $2.BASEFONT,
      $2.BGSOUND,
      $2.BLOCKQUOTE,
      $2.BODY,
      $2.BR,
      $2.BUTTON,
      $2.CAPTION,
      $2.CENTER,
      $2.COL,
      $2.COLGROUP,
      $2.DD,
      $2.DETAILS,
      $2.DIR,
      $2.DIV,
      $2.DL,
      $2.DT,
      $2.EMBED,
      $2.FIELDSET,
      $2.FIGCAPTION,
      $2.FIGURE,
      $2.FOOTER,
      $2.FORM,
      $2.FRAME,
      $2.FRAMESET,
      $2.H1,
      $2.H2,
      $2.H3,
      $2.H4,
      $2.H5,
      $2.H6,
      $2.HEAD,
      $2.HEADER,
      $2.HGROUP,
      $2.HR,
      $2.HTML,
      $2.IFRAME,
      $2.IMG,
      $2.INPUT,
      $2.LI,
      $2.LINK,
      $2.LISTING,
      $2.MAIN,
      $2.MARQUEE,
      $2.MENU,
      $2.META,
      $2.NAV,
      $2.NOEMBED,
      $2.NOFRAMES,
      $2.NOSCRIPT,
      $2.OBJECT,
      $2.OL,
      $2.P,
      $2.PARAM,
      $2.PLAINTEXT,
      $2.PRE,
      $2.SCRIPT,
      $2.SECTION,
      $2.SELECT,
      $2.SOURCE,
      $2.STYLE,
      $2.SUMMARY,
      $2.TABLE,
      $2.TBODY,
      $2.TD,
      $2.TEMPLATE,
      $2.TEXTAREA,
      $2.TFOOT,
      $2.TH,
      $2.THEAD,
      $2.TITLE,
      $2.TR,
      $2.TRACK,
      $2.UL,
      $2.WBR,
      $2.XMP
    ]),
    [NS.MATHML]: /* @__PURE__ */ new Set([$2.MI, $2.MO, $2.MN, $2.MS, $2.MTEXT, $2.ANNOTATION_XML]),
    [NS.SVG]: /* @__PURE__ */ new Set([$2.TITLE, $2.FOREIGN_OBJECT, $2.DESC]),
    [NS.XLINK]: /* @__PURE__ */ new Set(),
    [NS.XML]: /* @__PURE__ */ new Set(),
    [NS.XMLNS]: /* @__PURE__ */ new Set()
  };
  function isNumberedHeader(tn) {
    return tn === $2.H1 || tn === $2.H2 || tn === $2.H3 || tn === $2.H4 || tn === $2.H5 || tn === $2.H6;
  }
  exports2.isNumberedHeader = isNumberedHeader;
  const UNESCAPED_TEXT = /* @__PURE__ */ new Set([
    TAG_NAMES.STYLE,
    TAG_NAMES.SCRIPT,
    TAG_NAMES.XMP,
    TAG_NAMES.IFRAME,
    TAG_NAMES.NOEMBED,
    TAG_NAMES.NOFRAMES,
    TAG_NAMES.PLAINTEXT
  ]);
  function hasUnescapedText(tn, scriptingEnabled) {
    return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
  }
  exports2.hasUnescapedText = hasUnescapedText;
})(html$4);
Object.defineProperty(tokenizer, "__esModule", { value: true });
tokenizer.Tokenizer = tokenizer.TokenizerMode = void 0;
const preprocessor_js_1 = preprocessor;
const unicode_js_1 = unicode$1;
const token_js_1$1 = token;
const decode_js_1$1 = decode$1;
const error_codes_js_1$1 = errorCodes;
const html_js_1$4 = html$4;
const C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var State;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
  State2[State2["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
  State2[State2["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
  State2[State2["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State || (State = {}));
tokenizer.TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.DIGIT_0 && cp <= unicode_js_1.CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === unicode_js_1.CODE_POINTS.SPACE || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.TABULATION || cp === unicode_js_1.CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd(nextCp) {
  return nextCp === unicode_js_1.CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === unicode_js_1.CODE_POINTS.SOLIDUS || cp === unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN;
}
let Tokenizer$1 = class Tokenizer {
  constructor(options2, handler) {
    this.options = options2;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new preprocessor_js_1.Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code2) {
    var _a, _b;
    (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code2));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count2) {
    this.consumedAfterSnapshot -= count2;
    this.preprocessor.retreat(count2);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count2) {
    this.consumedAfterSnapshot += count2;
    for (let i2 = 0; i2 < count2; i2++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: token_js_1$1.TokenType.START_TAG,
      tagName: "",
      tagID: html_js_1$4.TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: token_js_1$1.TokenType.END_TAG,
      tagName: "",
      tagID: html_js_1$4.TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: token_js_1$1.TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: token_js_1$1.TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a;
    var _b;
    const token2 = this.currentToken;
    if ((0, token_js_1$1.getTokenAttr)(token2, this.currentAttr.name) === null) {
      token2.attrs.push(this.currentAttr);
      if (token2.location && this.currentLocation) {
        const attrLocations = (_a = (_b = token2.location).attrs) !== null && _a !== void 0 ? _a : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(error_codes_js_1$1.ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct2) {
    this._emitCurrentCharacterToken(ct2.location);
    this.currentToken = null;
    if (ct2.location) {
      ct2.location.endLine = this.preprocessor.line;
      ct2.location.endCol = this.preprocessor.col + 1;
      ct2.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct2 = this.currentToken;
    this.prepareToken(ct2);
    ct2.tagID = (0, html_js_1$4.getTagID)(ct2.tagName);
    if (ct2.type === token_js_1$1.TokenType.START_TAG) {
      this.lastStartTagName = ct2.tagName;
      this.handler.onStartTag(ct2);
    } else {
      if (ct2.attrs.length > 0) {
        this._err(error_codes_js_1$1.ERR.endTagWithAttributes);
      }
      if (ct2.selfClosing) {
        this._err(error_codes_js_1$1.ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct2);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct2) {
    this.prepareToken(ct2);
    this.handler.onComment(ct2);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct2) {
    this.prepareToken(ct2);
    this.handler.onDoctype(ct2);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case token_js_1$1.TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case token_js_1$1.TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case token_js_1$1.TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location2 = this.getCurrentLocation(0);
    if (location2) {
      location2.endLine = location2.startLine;
      location2.endCol = location2.startCol;
      location2.endOffset = location2.startOffset;
    }
    this._emitCurrentCharacterToken(location2);
    this.handler.onEof({ type: token_js_1$1.TokenType.EOF, location: location2 });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace(cp) ? token_js_1$1.TokenType.WHITESPACE_CHARACTER : cp === unicode_js_1.CODE_POINTS.NULL ? token_js_1$1.TokenType.NULL_CHARACTER : token_js_1$1.TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(token_js_1$1.TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i2 = 0, current = decode_js_1$1.htmlDecodeTree[0]; i2 >= 0; cp = this._consume()) {
      i2 = (0, decode_js_1$1.determineBranch)(decode_js_1$1.htmlDecodeTree, current, i2 + 1, cp);
      if (i2 < 0)
        break;
      excess += 1;
      current = decode_js_1$1.htmlDecodeTree[i2];
      const masked = current & decode_js_1$1.BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (cp !== unicode_js_1.CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))) {
          result = [unicode_js_1.CODE_POINTS.AMPERSAND];
          i2 += valueLength;
        } else {
          result = valueLength === 0 ? [decode_js_1$1.htmlDecodeTree[i2] & ~decode_js_1$1.BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_js_1$1.htmlDecodeTree[++i2]] : [decode_js_1$1.htmlDecodeTree[++i2], decode_js_1$1.htmlDecodeTree[++i2]];
          excess = 0;
          withoutSemicolon = cp !== unicode_js_1.CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(error_codes_js_1$1.ERR.missingSemicolonAfterCharacterReference);
    }
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.DATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.RCDATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case unicode_js_1.CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case unicode_js_1.CODE_POINTS.QUESTION_MARK: {
          this._err(error_codes_js_1$1.ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case unicode_js_1.CODE_POINTS.EOF: {
          this._err(error_codes_js_1$1.ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(error_codes_js_1$1.ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(error_codes_js_1$1.ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case unicode_js_1.CODE_POINTS.EOF: {
          this._err(error_codes_js_1$1.ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(error_codes_js_1$1.ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.tagName += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token2 = this.currentToken;
    token2.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i2 = 0; i2 < unicode_js_1.SEQUENCES.SCRIPT.length; i2++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i2 = 0; i2 < unicode_js_1.SEQUENCES.SCRIPT.length; i2++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
        this._err(error_codes_js_1$1.ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
      case unicode_js_1.CODE_POINTS.SOLIDUS:
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.name += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
      case unicode_js_1.CODE_POINTS.GRAVE_ACCENT: {
        this._err(error_codes_js_1$1.ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        const token2 = this.currentToken;
        token2.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.data += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token2.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(unicode_js_1.SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(unicode_js_1.SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(error_codes_js_1$1.ERR.cdataInHtmlContent);
        this._createCommentToken(unicode_js_1.SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(error_codes_js_1$1.ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token2 = this.currentToken;
        this.emitCurrentComment(token2);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        token2.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.data += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
        token2.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
        token2.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN && cp !== unicode_js_1.CODE_POINTS.EOF) {
      this._err(error_codes_js_1$1.ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        token2.data += "-";
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
        token2.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInComment);
        this.emitCurrentComment(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token2 = this.currentToken;
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case unicode_js_1.CODE_POINTS.SPACE:
        case unicode_js_1.CODE_POINTS.LINE_FEED:
        case unicode_js_1.CODE_POINTS.TABULATION:
        case unicode_js_1.CODE_POINTS.FORM_FEED: {
          break;
        }
        case unicode_js_1.CODE_POINTS.NULL: {
          this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
          this._createDoctypeToken(unicode_js_1.REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(error_codes_js_1$1.ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token2 = this.currentToken;
          token2.forceQuirks = true;
          this.emitCurrentDoctype(token2);
          this.state = State.DATA;
          break;
        }
        case unicode_js_1.CODE_POINTS.EOF: {
          this._err(error_codes_js_1$1.ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token2 = this.currentToken;
          token2.forceQuirks = true;
          this.emitCurrentDoctype(token2);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.name += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(error_codes_js_1$1.ERR.invalidCharacterSequenceAfterDoctypeName);
          token2.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        token2.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypePublicIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this._err(error_codes_js_1$1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        token2.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.missingDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token2);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        token2.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(error_codes_js_1$1.ERR.abruptDoctypeSystemIdentifier);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        token2.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED: {
        break;
      }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInDoctype);
        token2.forceQuirks = true;
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(error_codes_js_1$1.ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token2 = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token2);
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.NULL: {
        this._err(error_codes_js_1$1.ERR.unexpectedNullCharacter);
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token2);
        this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case unicode_js_1.CODE_POINTS.EOF: {
        this._err(error_codes_js_1$1.ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === unicode_js_1.CODE_POINTS.NUMBER_SIGN) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric(cp)) {
      this.state = State.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    if (this._ensureHibernation())
      ;
    else if (matchResult) {
      for (let i2 = 0; i2 < matchResult.length; i2++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i2]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this.state = State.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
        this._err(error_codes_js_1$1.ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (cp === unicode_js_1.CODE_POINTS.LATIN_SMALL_X || cp === unicode_js_1.CODE_POINTS.LATIN_CAPITAL_X) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;
    } else if (isAsciiDigit(cp)) {
      this.state = State.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(error_codes_js_1$1.ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(error_codes_js_1$1.ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 55;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 87;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 48;
    } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(error_codes_js_1$1.ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 48;
    } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(error_codes_js_1$1.ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === unicode_js_1.CODE_POINTS.NULL) {
      this._err(error_codes_js_1$1.ERR.nullCharacterReference);
      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(error_codes_js_1$1.ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if ((0, unicode_js_1.isSurrogate)(this.charRefCode)) {
      this._err(error_codes_js_1$1.ERR.surrogateCharacterReference);
      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if ((0, unicode_js_1.isUndefinedCodePoint)(this.charRefCode)) {
      this._err(error_codes_js_1$1.ERR.noncharacterCharacterReference);
    } else if ((0, unicode_js_1.isControlCodePoint)(this.charRefCode) || this.charRefCode === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
      this._err(error_codes_js_1$1.ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      if (replacement !== void 0) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};
tokenizer.Tokenizer = Tokenizer$1;
var openElementStack = {};
Object.defineProperty(openElementStack, "__esModule", { value: true });
openElementStack.OpenElementStack = void 0;
const html_js_1$3 = html$4;
const IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([html_js_1$3.TAG_ID.DD, html_js_1$3.TAG_ID.DT, html_js_1$3.TAG_ID.LI, html_js_1$3.TAG_ID.OPTGROUP, html_js_1$3.TAG_ID.OPTION, html_js_1$3.TAG_ID.P, html_js_1$3.TAG_ID.RB, html_js_1$3.TAG_ID.RP, html_js_1$3.TAG_ID.RT, html_js_1$3.TAG_ID.RTC]);
const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  html_js_1$3.TAG_ID.CAPTION,
  html_js_1$3.TAG_ID.COLGROUP,
  html_js_1$3.TAG_ID.TBODY,
  html_js_1$3.TAG_ID.TD,
  html_js_1$3.TAG_ID.TFOOT,
  html_js_1$3.TAG_ID.TH,
  html_js_1$3.TAG_ID.THEAD,
  html_js_1$3.TAG_ID.TR
]);
const SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
  [html_js_1$3.TAG_ID.APPLET, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.CAPTION, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.HTML, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.MARQUEE, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.OBJECT, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TABLE, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TD, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.TH, html_js_1$3.NS.HTML],
  [html_js_1$3.TAG_ID.ANNOTATION_XML, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MI, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MN, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MO, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MS, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.MTEXT, html_js_1$3.NS.MATHML],
  [html_js_1$3.TAG_ID.DESC, html_js_1$3.NS.SVG],
  [html_js_1$3.TAG_ID.FOREIGN_OBJECT, html_js_1$3.NS.SVG],
  [html_js_1$3.TAG_ID.TITLE, html_js_1$3.NS.SVG]
]);
const NAMED_HEADERS = [html_js_1$3.TAG_ID.H1, html_js_1$3.TAG_ID.H2, html_js_1$3.TAG_ID.H3, html_js_1$3.TAG_ID.H4, html_js_1$3.TAG_ID.H5, html_js_1$3.TAG_ID.H6];
const TABLE_ROW_CONTEXT = [html_js_1$3.TAG_ID.TR, html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.TAG_ID.HTML];
const TABLE_BODY_CONTEXT = [html_js_1$3.TAG_ID.TBODY, html_js_1$3.TAG_ID.TFOOT, html_js_1$3.TAG_ID.THEAD, html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.TAG_ID.HTML];
const TABLE_CONTEXT = [html_js_1$3.TAG_ID.TABLE, html_js_1$3.TAG_ID.TEMPLATE, html_js_1$3.TAG_ID.HTML];
const TABLE_CELLS = [html_js_1$3.TAG_ID.TD, html_js_1$3.TAG_ID.TH];
class OpenElementStack {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document2, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = html_js_1$3.TAG_ID.UNKNOWN;
    this.current = document2;
  }
  //Index of element
  _indexOf(element2) {
    return this.items.lastIndexOf(element2, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === html_js_1$3.TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === html_js_1$3.NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element2, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element2;
    this.current = element2;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element2, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== html_js_1$3.NS.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element2) {
    const idx = this._indexOf(element2);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, html_js_1$3.NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, html_js_1$3.NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      if (tagNames.includes(this.tagIDs[i2]) && this.treeAdapter.getNamespaceURI(this.items[i2]) === namespace) {
        return i2;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, html_js_1$3.NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, html_js_1$3.NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, html_js_1$3.NS.HTML);
  }
  remove(element2) {
    const idx = this._indexOf(element2);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element2, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === html_js_1$3.TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element2) {
    return this._indexOf(element2) > -1;
  }
  getCommonAncestor(element2) {
    const elementIdx = this._indexOf(element2) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === html_js_1$3.TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (tn === tagName && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if ((0, html_js_1$3.isNumberedHeader)(tn) && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (tn === tagName && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if ((tn === html_js_1$3.TAG_ID.UL || tn === html_js_1$3.TAG_ID.OL) && ns === html_js_1$3.NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (tn === tagName && ns === html_js_1$3.NS.HTML) {
        return true;
      }
      if (tn === html_js_1$3.TAG_ID.BUTTON && ns === html_js_1$3.NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (ns !== html_js_1$3.NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === html_js_1$3.TAG_ID.TABLE || tn === html_js_1$3.TAG_ID.TEMPLATE || tn === html_js_1$3.TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (ns !== html_js_1$3.NS.HTML) {
        continue;
      }
      if (tn === html_js_1$3.TAG_ID.TBODY || tn === html_js_1$3.TAG_ID.THEAD || tn === html_js_1$3.TAG_ID.TFOOT) {
        return true;
      }
      if (tn === html_js_1$3.TAG_ID.TABLE || tn === html_js_1$3.TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (ns !== html_js_1$3.NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== html_js_1$3.TAG_ID.OPTION && tn !== html_js_1$3.TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
}
openElementStack.OpenElementStack = OpenElementStack;
var formattingElementList = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.FormattingElementList = exports2.EntryType = void 0;
  const NOAH_ARK_CAPACITY = 3;
  var EntryType;
  (function(EntryType2) {
    EntryType2[EntryType2["Marker"] = 0] = "Marker";
    EntryType2[EntryType2["Element"] = 1] = "Element";
  })(EntryType = exports2.EntryType || (exports2.EntryType = {}));
  const MARKER = { type: EntryType.Marker };
  class FormattingElementList {
    constructor(treeAdapter) {
      this.treeAdapter = treeAdapter;
      this.entries = [];
      this.bookmark = null;
    }
    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement, neAttrs) {
      const candidates = [];
      const neAttrsLength = neAttrs.length;
      const neTagName = this.treeAdapter.getTagName(newElement);
      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
      for (let i2 = 0; i2 < this.entries.length; i2++) {
        const entry = this.entries[i2];
        if (entry.type === EntryType.Marker) {
          break;
        }
        const { element: element2 } = entry;
        if (this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI) {
          const elementAttrs = this.treeAdapter.getAttrList(element2);
          if (elementAttrs.length === neAttrsLength) {
            candidates.push({ idx: i2, attrs: elementAttrs });
          }
        }
      }
      return candidates;
    }
    _ensureNoahArkCondition(newElement) {
      if (this.entries.length < NOAH_ARK_CAPACITY)
        return;
      const neAttrs = this.treeAdapter.getAttrList(newElement);
      const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
      if (candidates.length < NOAH_ARK_CAPACITY)
        return;
      const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
      let validCandidates = 0;
      for (let i2 = 0; i2 < candidates.length; i2++) {
        const candidate = candidates[i2];
        if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
          validCandidates += 1;
          if (validCandidates >= NOAH_ARK_CAPACITY) {
            this.entries.splice(candidate.idx, 1);
          }
        }
      }
    }
    //Mutations
    insertMarker() {
      this.entries.unshift(MARKER);
    }
    pushElement(element2, token2) {
      this._ensureNoahArkCondition(element2);
      this.entries.unshift({
        type: EntryType.Element,
        element: element2,
        token: token2
      });
    }
    insertElementAfterBookmark(element2, token2) {
      const bookmarkIdx = this.entries.indexOf(this.bookmark);
      this.entries.splice(bookmarkIdx, 0, {
        type: EntryType.Element,
        element: element2,
        token: token2
      });
    }
    removeEntry(entry) {
      const entryIndex = this.entries.indexOf(entry);
      if (entryIndex >= 0) {
        this.entries.splice(entryIndex, 1);
      }
    }
    /**
     * Clears the list of formatting elements up to the last marker.
     *
     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
     */
    clearToLastMarker() {
      const markerIdx = this.entries.indexOf(MARKER);
      if (markerIdx >= 0) {
        this.entries.splice(0, markerIdx + 1);
      } else {
        this.entries.length = 0;
      }
    }
    //Search
    getElementEntryInScopeWithTagName(tagName) {
      const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
      return entry && entry.type === EntryType.Element ? entry : null;
    }
    getElementEntry(element2) {
      return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element2);
    }
  }
  exports2.FormattingElementList = FormattingElementList;
})(formattingElementList);
var _default = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.defaultTreeAdapter = void 0;
  const html_js_12 = html$4;
  function createTextNode(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  }
  exports2.defaultTreeAdapter = {
    //Node construction
    createDocument() {
      return {
        nodeName: "#document",
        mode: html_js_12.DOCUMENT_MODE.NO_QUIRKS,
        childNodes: []
      };
    },
    createDocumentFragment() {
      return {
        nodeName: "#document-fragment",
        childNodes: []
      };
    },
    createElement(tagName, namespaceURI, attrs) {
      return {
        nodeName: tagName,
        tagName,
        attrs,
        namespaceURI,
        childNodes: [],
        parentNode: null
      };
    },
    createCommentNode(data2) {
      return {
        nodeName: "#comment",
        data: data2,
        parentNode: null
      };
    },
    //Tree mutation
    appendChild(parentNode, newNode) {
      parentNode.childNodes.push(newNode);
      newNode.parentNode = parentNode;
    },
    insertBefore(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
      parentNode.childNodes.splice(insertionIdx, 0, newNode);
      newNode.parentNode = parentNode;
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(document2, name2, publicId, systemId) {
      const doctypeNode = document2.childNodes.find((node2) => node2.nodeName === "#documentType");
      if (doctypeNode) {
        doctypeNode.name = name2;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
      } else {
        const node2 = {
          nodeName: "#documentType",
          name: name2,
          publicId,
          systemId,
          parentNode: null
        };
        exports2.defaultTreeAdapter.appendChild(document2, node2);
      }
    },
    setDocumentMode(document2, mode) {
      document2.mode = mode;
    },
    getDocumentMode(document2) {
      return document2.mode;
    },
    detachNode(node2) {
      if (node2.parentNode) {
        const idx = node2.parentNode.childNodes.indexOf(node2);
        node2.parentNode.childNodes.splice(idx, 1);
        node2.parentNode = null;
      }
    },
    insertText(parentNode, text2) {
      if (parentNode.childNodes.length > 0) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
        if (exports2.defaultTreeAdapter.isTextNode(prevNode)) {
          prevNode.value += text2;
          return;
        }
      }
      exports2.defaultTreeAdapter.appendChild(parentNode, createTextNode(text2));
    },
    insertTextBefore(parentNode, text2, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode && exports2.defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text2;
      } else {
        exports2.defaultTreeAdapter.insertBefore(parentNode, createTextNode(text2), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
      for (let j2 = 0; j2 < attrs.length; j2++) {
        if (!recipientAttrsMap.has(attrs[j2].name)) {
          recipient.attrs.push(attrs[j2]);
        }
      }
    },
    //Tree traversing
    getFirstChild(node2) {
      return node2.childNodes[0];
    },
    getChildNodes(node2) {
      return node2.childNodes;
    },
    getParentNode(node2) {
      return node2.parentNode;
    },
    getAttrList(element2) {
      return element2.attrs;
    },
    //Node data
    getTagName(element2) {
      return element2.tagName;
    },
    getNamespaceURI(element2) {
      return element2.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.value;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.data;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode.name;
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode.publicId;
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode.systemId;
    },
    //Node types
    isTextNode(node2) {
      return node2.nodeName === "#text";
    },
    isCommentNode(node2) {
      return node2.nodeName === "#comment";
    },
    isDocumentTypeNode(node2) {
      return node2.nodeName === "#documentType";
    },
    isElementNode(node2) {
      return Object.prototype.hasOwnProperty.call(node2, "tagName");
    },
    // Source code location
    setNodeSourceCodeLocation(node2, location2) {
      node2.sourceCodeLocation = location2;
    },
    getNodeSourceCodeLocation(node2) {
      return node2.sourceCodeLocation;
    },
    updateNodeSourceCodeLocation(node2, endLocation) {
      node2.sourceCodeLocation = Object.assign(Object.assign({}, node2.sourceCodeLocation), endLocation);
    }
  };
})(_default);
var doctype$2 = {};
Object.defineProperty(doctype$2, "__esModule", { value: true });
doctype$2.getDocumentMode = doctype$2.isConforming = void 0;
const html_js_1$2 = html$4;
const VALID_DOCTYPE_NAME = "html";
const VALID_SYSTEM_ID = "about:legacy-compat";
const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
const QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token2) {
  return token2.name === VALID_DOCTYPE_NAME && token2.publicId === null && (token2.systemId === null || token2.systemId === VALID_SYSTEM_ID);
}
doctype$2.isConforming = isConforming;
function getDocumentMode(token2) {
  if (token2.name !== VALID_DOCTYPE_NAME) {
    return html_js_1$2.DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token2;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return html_js_1$2.DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token2;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return html_js_1$2.DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return html_js_1$2.DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return html_js_1$2.DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return html_js_1$2.DOCUMENT_MODE.NO_QUIRKS;
}
doctype$2.getDocumentMode = getDocumentMode;
var foreignContent$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isIntegrationPoint = exports2.adjustTokenSVGTagName = exports2.adjustTokenXMLAttrs = exports2.adjustTokenSVGAttrs = exports2.adjustTokenMathMLAttrs = exports2.causesExit = exports2.SVG_TAG_NAMES_ADJUSTMENT_MAP = void 0;
  const html_js_12 = html$4;
  const MIME_TYPES = {
    TEXT_HTML: "text/html",
    APPLICATION_XML: "application/xhtml+xml"
  };
  const DEFINITION_URL_ATTR = "definitionurl";
  const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
  const SVG_ATTRS_ADJUSTMENT_MAP = new Map([
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((attr2) => [attr2.toLowerCase(), attr2]));
  const XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
    ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: html_js_12.NS.XLINK }],
    ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: html_js_12.NS.XLINK }],
    ["xlink:href", { prefix: "xlink", name: "href", namespace: html_js_12.NS.XLINK }],
    ["xlink:role", { prefix: "xlink", name: "role", namespace: html_js_12.NS.XLINK }],
    ["xlink:show", { prefix: "xlink", name: "show", namespace: html_js_12.NS.XLINK }],
    ["xlink:title", { prefix: "xlink", name: "title", namespace: html_js_12.NS.XLINK }],
    ["xlink:type", { prefix: "xlink", name: "type", namespace: html_js_12.NS.XLINK }],
    ["xml:base", { prefix: "xml", name: "base", namespace: html_js_12.NS.XML }],
    ["xml:lang", { prefix: "xml", name: "lang", namespace: html_js_12.NS.XML }],
    ["xml:space", { prefix: "xml", name: "space", namespace: html_js_12.NS.XML }],
    ["xmlns", { prefix: "", name: "xmlns", namespace: html_js_12.NS.XMLNS }],
    ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: html_js_12.NS.XMLNS }]
  ]);
  exports2.SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((tn) => [tn.toLowerCase(), tn]));
  const EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
    html_js_12.TAG_ID.B,
    html_js_12.TAG_ID.BIG,
    html_js_12.TAG_ID.BLOCKQUOTE,
    html_js_12.TAG_ID.BODY,
    html_js_12.TAG_ID.BR,
    html_js_12.TAG_ID.CENTER,
    html_js_12.TAG_ID.CODE,
    html_js_12.TAG_ID.DD,
    html_js_12.TAG_ID.DIV,
    html_js_12.TAG_ID.DL,
    html_js_12.TAG_ID.DT,
    html_js_12.TAG_ID.EM,
    html_js_12.TAG_ID.EMBED,
    html_js_12.TAG_ID.H1,
    html_js_12.TAG_ID.H2,
    html_js_12.TAG_ID.H3,
    html_js_12.TAG_ID.H4,
    html_js_12.TAG_ID.H5,
    html_js_12.TAG_ID.H6,
    html_js_12.TAG_ID.HEAD,
    html_js_12.TAG_ID.HR,
    html_js_12.TAG_ID.I,
    html_js_12.TAG_ID.IMG,
    html_js_12.TAG_ID.LI,
    html_js_12.TAG_ID.LISTING,
    html_js_12.TAG_ID.MENU,
    html_js_12.TAG_ID.META,
    html_js_12.TAG_ID.NOBR,
    html_js_12.TAG_ID.OL,
    html_js_12.TAG_ID.P,
    html_js_12.TAG_ID.PRE,
    html_js_12.TAG_ID.RUBY,
    html_js_12.TAG_ID.S,
    html_js_12.TAG_ID.SMALL,
    html_js_12.TAG_ID.SPAN,
    html_js_12.TAG_ID.STRONG,
    html_js_12.TAG_ID.STRIKE,
    html_js_12.TAG_ID.SUB,
    html_js_12.TAG_ID.SUP,
    html_js_12.TAG_ID.TABLE,
    html_js_12.TAG_ID.TT,
    html_js_12.TAG_ID.U,
    html_js_12.TAG_ID.UL,
    html_js_12.TAG_ID.VAR
  ]);
  function causesExit(startTagToken) {
    const tn = startTagToken.tagID;
    const isFontWithAttrs = tn === html_js_12.TAG_ID.FONT && startTagToken.attrs.some(({ name: name2 }) => name2 === html_js_12.ATTRS.COLOR || name2 === html_js_12.ATTRS.SIZE || name2 === html_js_12.ATTRS.FACE);
    return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
  }
  exports2.causesExit = causesExit;
  function adjustTokenMathMLAttrs(token2) {
    for (let i2 = 0; i2 < token2.attrs.length; i2++) {
      if (token2.attrs[i2].name === DEFINITION_URL_ATTR) {
        token2.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR;
        break;
      }
    }
  }
  exports2.adjustTokenMathMLAttrs = adjustTokenMathMLAttrs;
  function adjustTokenSVGAttrs(token2) {
    for (let i2 = 0; i2 < token2.attrs.length; i2++) {
      const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token2.attrs[i2].name);
      if (adjustedAttrName != null) {
        token2.attrs[i2].name = adjustedAttrName;
      }
    }
  }
  exports2.adjustTokenSVGAttrs = adjustTokenSVGAttrs;
  function adjustTokenXMLAttrs(token2) {
    for (let i2 = 0; i2 < token2.attrs.length; i2++) {
      const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token2.attrs[i2].name);
      if (adjustedAttrEntry) {
        token2.attrs[i2].prefix = adjustedAttrEntry.prefix;
        token2.attrs[i2].name = adjustedAttrEntry.name;
        token2.attrs[i2].namespace = adjustedAttrEntry.namespace;
      }
    }
  }
  exports2.adjustTokenXMLAttrs = adjustTokenXMLAttrs;
  function adjustTokenSVGTagName(token2) {
    const adjustedTagName = exports2.SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token2.tagName);
    if (adjustedTagName != null) {
      token2.tagName = adjustedTagName;
      token2.tagID = (0, html_js_12.getTagID)(token2.tagName);
    }
  }
  exports2.adjustTokenSVGTagName = adjustTokenSVGTagName;
  function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === html_js_12.NS.MATHML && (tn === html_js_12.TAG_ID.MI || tn === html_js_12.TAG_ID.MO || tn === html_js_12.TAG_ID.MN || tn === html_js_12.TAG_ID.MS || tn === html_js_12.TAG_ID.MTEXT);
  }
  function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === html_js_12.NS.MATHML && tn === html_js_12.TAG_ID.ANNOTATION_XML) {
      for (let i2 = 0; i2 < attrs.length; i2++) {
        if (attrs[i2].name === html_js_12.ATTRS.ENCODING) {
          const value = attrs[i2].value.toLowerCase();
          return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
        }
      }
    }
    return ns === html_js_12.NS.SVG && (tn === html_js_12.TAG_ID.FOREIGN_OBJECT || tn === html_js_12.TAG_ID.DESC || tn === html_js_12.TAG_ID.TITLE);
  }
  function isIntegrationPoint(tn, ns, attrs, foreignNS) {
    return (!foreignNS || foreignNS === html_js_12.NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === html_js_12.NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
  }
  exports2.isIntegrationPoint = isIntegrationPoint;
})(foreignContent$1);
Object.defineProperty(parser$2, "__esModule", { value: true });
parser$2.Parser = void 0;
const index_js_1 = tokenizer;
const open_element_stack_js_1 = openElementStack;
const formatting_element_list_js_1 = formattingElementList;
const default_js_1$1 = _default;
const doctype$1 = doctype$2;
const foreignContent = foreignContent$1;
const error_codes_js_1 = errorCodes;
const unicode = unicode$1;
const html_js_1$1 = html$4;
const token_js_1 = token;
const HIDDEN_INPUT_TYPE = "hidden";
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
const TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([html_js_1$1.TAG_ID.TABLE, html_js_1$1.TAG_ID.TBODY, html_js_1$1.TAG_ID.TFOOT, html_js_1$1.TAG_ID.THEAD, html_js_1$1.TAG_ID.TR]);
const defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: default_js_1$1.defaultTreeAdapter,
  onParseError: null
};
let Parser$3 = class Parser {
  constructor(options2, document2, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = Object.assign(Object.assign({}, defaultParserOptions), options2);
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document2 !== null && document2 !== void 0 ? document2 : this.treeAdapter.createDocument();
    this.tokenizer = new index_js_1.Tokenizer(this.options, this);
    this.activeFormattingElements = new formatting_element_list_js_1.FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? (0, html_js_1$1.getTagID)(this.treeAdapter.getTagName(fragmentContext)) : html_js_1$1.TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new open_element_stack_js_1.OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html2, options2) {
    const parser2 = new this(options2);
    parser2.tokenizer.write(html2, true);
    return parser2.document;
  }
  static getFragmentParser(fragmentContext, options2) {
    const opts = Object.assign(Object.assign({}, defaultParserOptions), options2);
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(html_js_1$1.TAG_NAMES.TEMPLATE, html_js_1$1.NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", html_js_1$1.NS.HTML, []);
    const parser2 = new this(opts, documentMock, fragmentContext);
    if (parser2.fragmentContextID === html_js_1$1.TAG_ID.TEMPLATE) {
      parser2.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser2._initTokenizerForFragmentParsing();
    parser2._insertFakeRootElement();
    parser2._resetInsertionMode();
    parser2._findFormInFragmentContext();
    return parser2;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token2, code2, beforeToken) {
    var _a;
    if (!this.onParseError)
      return;
    const loc = (_a = token2.location) !== null && _a !== void 0 ? _a : BASE_LOC;
    const err = {
      code: code2,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  onItemPush(node2, tid, isTop) {
    var _a, _b;
    (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a, node2);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node2, tid);
  }
  onItemPop(node2, isTop) {
    var _a, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node2, this.currentToken);
    }
    (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a, node2, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === html_js_1$1.NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, html_js_1$1.NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node2 = this.fragmentContext;
    while (node2) {
      if (this.treeAdapter.getTagName(node2) === html_js_1$1.TAG_NAMES.FORM) {
        this.formElement = node2;
        break;
      }
      node2 = this.treeAdapter.getParentNode(node2);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== html_js_1$1.NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case html_js_1$1.TAG_ID.TITLE:
      case html_js_1$1.TAG_ID.TEXTAREA: {
        this.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
        break;
      }
      case html_js_1$1.TAG_ID.STYLE:
      case html_js_1$1.TAG_ID.XMP:
      case html_js_1$1.TAG_ID.IFRAME:
      case html_js_1$1.TAG_ID.NOEMBED:
      case html_js_1$1.TAG_ID.NOFRAMES:
      case html_js_1$1.TAG_ID.NOSCRIPT: {
        this.tokenizer.state = index_js_1.TokenizerMode.RAWTEXT;
        break;
      }
      case html_js_1$1.TAG_ID.SCRIPT: {
        this.tokenizer.state = index_js_1.TokenizerMode.SCRIPT_DATA;
        break;
      }
      case html_js_1$1.TAG_ID.PLAINTEXT: {
        this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
        break;
      }
    }
  }
  //Tree mutation
  _setDocumentType(token2) {
    const name2 = token2.name || "";
    const publicId = token2.publicId || "";
    const systemId = token2.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    if (token2.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node2) => this.treeAdapter.isDocumentTypeNode(node2));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token2.location);
      }
    }
  }
  _attachElementToTree(element2, location2) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location2 && Object.assign(Object.assign({}, location2), { startTag: location2 });
      this.treeAdapter.setNodeSourceCodeLocation(element2, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element2);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent, element2);
    }
  }
  _appendElement(token2, namespaceURI) {
    const element2 = this.treeAdapter.createElement(token2.tagName, namespaceURI, token2.attrs);
    this._attachElementToTree(element2, token2.location);
  }
  _insertElement(token2, namespaceURI) {
    const element2 = this.treeAdapter.createElement(token2.tagName, namespaceURI, token2.attrs);
    this._attachElementToTree(element2, token2.location);
    this.openElements.push(element2, token2.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element2 = this.treeAdapter.createElement(tagName, html_js_1$1.NS.HTML, []);
    this._attachElementToTree(element2, null);
    this.openElements.push(element2, tagID);
  }
  _insertTemplate(token2) {
    const tmpl = this.treeAdapter.createElement(token2.tagName, html_js_1$1.NS.HTML, token2.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token2.location);
    this.openElements.push(tmpl, token2.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element2 = this.treeAdapter.createElement(html_js_1$1.TAG_NAMES.HTML, html_js_1$1.NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element2, null);
    this.treeAdapter.appendChild(this.openElements.current, element2);
    this.openElements.push(element2, html_js_1$1.TAG_ID.HTML);
  }
  _appendCommentNode(token2, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token2.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token2.location);
    }
  }
  _insertCharacters(token2) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token2.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token2.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token2.chars);
    }
    if (!token2.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token2.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token2.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element2, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element2) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element2);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === token_js_1.TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: Object.assign({}, ctLoc),
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element2, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token2) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token2.tagID === html_js_1$1.TAG_ID.SVG && this.treeAdapter.getTagName(current) === html_js_1$1.TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === html_js_1$1.NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token2.tagID === html_js_1$1.TAG_ID.MGLYPH || token2.tagID === html_js_1$1.TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, html_js_1$1.NS.HTML)
    );
  }
  _processToken(token2) {
    switch (token2.type) {
      case token_js_1.TokenType.CHARACTER: {
        this.onCharacter(token2);
        break;
      }
      case token_js_1.TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token2);
        break;
      }
      case token_js_1.TokenType.COMMENT: {
        this.onComment(token2);
        break;
      }
      case token_js_1.TokenType.DOCTYPE: {
        this.onDoctype(token2);
        break;
      }
      case token_js_1.TokenType.START_TAG: {
        this._processStartTag(token2);
        break;
      }
      case token_js_1.TokenType.END_TAG: {
        this.onEndTag(token2);
        break;
      }
      case token_js_1.TokenType.EOF: {
        this.onEof(token2);
        break;
      }
      case token_js_1.TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token2);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element2, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element2);
    const attrs = this.treeAdapter.getAttrList(element2);
    return foreignContent.isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === formatting_element_list_js_1.EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i2 = unopenIdx; i2 >= 0; i2--) {
        const entry = this.activeFormattingElements.entries[i2];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(html_js_1$1.TAG_ID.P);
    this.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
      switch (i2 === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i2]) {
        case html_js_1$1.TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case html_js_1$1.TAG_ID.TBODY:
        case html_js_1$1.TAG_ID.THEAD:
        case html_js_1$1.TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case html_js_1$1.TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case html_js_1$1.TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case html_js_1$1.TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case html_js_1$1.TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case html_js_1$1.TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case html_js_1$1.TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i2);
          return;
        }
        case html_js_1$1.TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case html_js_1$1.TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case html_js_1$1.TAG_ID.TD:
        case html_js_1$1.TAG_ID.TH: {
          if (i2 > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case html_js_1$1.TAG_ID.HEAD: {
          if (i2 > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i2 = selectIdx - 1; i2 > 0; i2--) {
        const tn = this.openElements.tagIDs[i2];
        if (tn === html_js_1$1.TAG_ID.TEMPLATE) {
          break;
        } else if (tn === html_js_1$1.TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
      const openElement = this.openElements.items[i2];
      switch (this.openElements.tagIDs[i2]) {
        case html_js_1$1.TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === html_js_1$1.NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case html_js_1$1.TAG_ID.TABLE: {
          const parent = this.treeAdapter.getParentNode(openElement);
          if (parent) {
            return { parent, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i2 - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element2) {
    const location2 = this._findFosterParentingLocation();
    if (location2.beforeElement) {
      this.treeAdapter.insertBefore(location2.parent, element2, location2.beforeElement);
    } else {
      this.treeAdapter.appendChild(location2.parent, element2);
    }
  }
  //Special elements
  _isSpecialElement(element2, id2) {
    const ns = this.treeAdapter.getNamespaceURI(element2);
    return html_js_1$1.SPECIAL_ELEMENTS[ns].has(id2);
  }
  onCharacter(token2) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token2);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token2);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token2);
        break;
      }
    }
  }
  onNullCharacter(token2) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token2);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token2);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token2);
        break;
      }
    }
  }
  onComment(token2) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token2);
        break;
      }
    }
  }
  onDoctype(token2) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token2, error_codes_js_1.ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
    }
  }
  onStartTag(token2) {
    this.skipNextNewLine = false;
    this.currentToken = token2;
    this._processStartTag(token2);
    if (token2.selfClosing && !token2.ackSelfClosing) {
      this._err(token2, error_codes_js_1.ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token2) {
    if (this.shouldProcessStartTagTokenInForeignContent(token2)) {
      startTagInForeignContent(this, token2);
    } else {
      this._startTagOutsideForeignContent(token2);
    }
  }
  _startTagOutsideForeignContent(token2) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token2);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token2);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token2);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token2);
        break;
      }
    }
  }
  onEndTag(token2) {
    this.skipNextNewLine = false;
    this.currentToken = token2;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token2);
    } else {
      this._endTagOutsideForeignContent(token2);
    }
  }
  _endTagOutsideForeignContent(token2) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token2);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token2);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token2);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token2);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token2);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token2);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token2);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token2);
        break;
      }
    }
  }
  onEof(token2) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token2);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token2);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token2);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token2);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token2);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token2);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token2);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token2);
        break;
      }
    }
  }
  onWhitespaceCharacter(token2) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token2.chars.charCodeAt(0) === unicode.CODE_POINTS.LINE_FEED) {
        if (token2.chars.length === 1) {
          return;
        }
        token2.chars = token2.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token2);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token2);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token2);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token2);
        break;
      }
    }
  }
};
parser$2.Parser = Parser$3;
function aaObtainFormattingElementEntry(p2, token2) {
  let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(token2.tagName);
  if (formattingElementEntry) {
    if (!p2.openElements.contains(formattingElementEntry.element)) {
      p2.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p2.openElements.hasInScope(token2.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p2, token2);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p2, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p2.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element2 = p2.openElements.items[idx];
    if (element2 === formattingElementEntry.element) {
      break;
    }
    if (p2._isSpecialElement(element2, p2.openElements.tagIDs[idx])) {
      furthestBlock = element2;
    }
  }
  if (!furthestBlock) {
    p2.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p2.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p2, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
  for (let i2 = 0, element2 = nextElement; element2 !== formattingElement; i2++, element2 = nextElement) {
    nextElement = p2.openElements.getCommonAncestor(element2);
    const elementEntry = p2.activeFormattingElements.getElementEntry(element2);
    const counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p2.activeFormattingElements.removeEntry(elementEntry);
      }
      p2.openElements.remove(element2);
    } else {
      element2 = aaRecreateElementFromEntry(p2, elementEntry);
      if (lastElement === furthestBlock) {
        p2.activeFormattingElements.bookmark = elementEntry;
      }
      p2.treeAdapter.detachNode(lastElement);
      p2.treeAdapter.appendChild(element2, lastElement);
      lastElement = element2;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p2, elementEntry) {
  const ns = p2.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p2.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p2.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
  const tn = p2.treeAdapter.getTagName(commonAncestor);
  const tid = (0, html_js_1$1.getTagID)(tn);
  if (p2._isElementCausesFosterParenting(tid)) {
    p2._fosterParentElement(lastElement);
  } else {
    const ns = p2.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === html_js_1$1.TAG_ID.TEMPLATE && ns === html_js_1$1.NS.HTML) {
      commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
    }
    p2.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
  const ns = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token: token2 } = formattingElementEntry;
  const newElement = p2.treeAdapter.createElement(token2.tagName, ns, token2.attrs);
  p2._adoptNodes(furthestBlock, newElement);
  p2.treeAdapter.appendChild(furthestBlock, newElement);
  p2.activeFormattingElements.insertElementAfterBookmark(newElement, token2);
  p2.activeFormattingElements.removeEntry(formattingElementEntry);
  p2.openElements.remove(formattingElementEntry.element);
  p2.openElements.insertAfter(furthestBlock, newElement, token2.tagID);
}
function callAdoptionAgency(p2, token2) {
  for (let i2 = 0; i2 < AA_OUTER_LOOP_ITER; i2++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p2, token2);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p2.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
    p2.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
    aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p2, token2) {
  p2._appendCommentNode(token2, p2.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p2, token2) {
  p2._appendCommentNode(token2, p2.openElements.items[0]);
}
function appendCommentToDocument(p2, token2) {
  p2._appendCommentNode(token2, p2.document);
}
function stopParsing(p2, token2) {
  p2.stopped = true;
  if (token2.location) {
    const target = p2.fragmentContext ? 0 : 2;
    for (let i2 = p2.openElements.stackTop; i2 >= target; i2--) {
      p2._setEndLocation(p2.openElements.items[i2], token2);
    }
    if (!p2.fragmentContext && p2.openElements.stackTop >= 0) {
      const htmlElement = p2.openElements.items[0];
      const htmlLocation = p2.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p2._setEndLocation(htmlElement, token2);
        if (p2.openElements.stackTop >= 1) {
          const bodyElement = p2.openElements.items[1];
          const bodyLocation = p2.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p2._setEndLocation(bodyElement, token2);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p2, token2) {
  p2._setDocumentType(token2);
  const mode = token2.forceQuirks ? html_js_1$1.DOCUMENT_MODE.QUIRKS : doctype$1.getDocumentMode(token2);
  if (!doctype$1.isConforming(token2)) {
    p2._err(token2, error_codes_js_1.ERR.nonConformingDoctype);
  }
  p2.treeAdapter.setDocumentMode(p2.document, mode);
  p2.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p2, token2) {
  p2._err(token2, error_codes_js_1.ERR.missingDoctype, true);
  p2.treeAdapter.setDocumentMode(p2.document, html_js_1$1.DOCUMENT_MODE.QUIRKS);
  p2.insertionMode = InsertionMode.BEFORE_HTML;
  p2._processToken(token2);
}
function startTagBeforeHtml(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    p2.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p2, token2);
  }
}
function endTagBeforeHtml(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.HTML || tn === html_js_1$1.TAG_ID.HEAD || tn === html_js_1$1.TAG_ID.BODY || tn === html_js_1$1.TAG_ID.BR) {
    tokenBeforeHtml(p2, token2);
  }
}
function tokenBeforeHtml(p2, token2) {
  p2._insertFakeRootElement();
  p2.insertionMode = InsertionMode.BEFORE_HEAD;
  p2._processToken(token2);
}
function startTagBeforeHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HEAD: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.headElement = p2.openElements.current;
      p2.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p2, token2);
    }
  }
}
function endTagBeforeHead(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.HEAD || tn === html_js_1$1.TAG_ID.BODY || tn === html_js_1$1.TAG_ID.HTML || tn === html_js_1$1.TAG_ID.BR) {
    tokenBeforeHead(p2, token2);
  } else {
    p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p2, token2) {
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.HEAD, html_js_1$1.TAG_ID.HEAD);
  p2.headElement = p2.openElements.current;
  p2.insertionMode = InsertionMode.IN_HEAD;
  p2._processToken(token2);
}
function startTagInHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META: {
      p2._appendElement(token2, html_js_1$1.NS.HTML);
      token2.ackSelfClosing = true;
      break;
    }
    case html_js_1$1.TAG_ID.TITLE: {
      p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RCDATA);
      break;
    }
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      if (p2.options.scriptingEnabled) {
        p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
      } else {
        p2._insertElement(token2, html_js_1$1.NS.HTML);
        p2.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.STYLE: {
      p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
      break;
    }
    case html_js_1$1.TAG_ID.SCRIPT: {
      p2._switchToTextParsing(token2, index_js_1.TokenizerMode.SCRIPT_DATA);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      p2._insertTemplate(token2);
      p2.activeFormattingElements.insertMarker();
      p2.framesetOk = false;
      p2.insertionMode = InsertionMode.IN_TEMPLATE;
      p2.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case html_js_1$1.TAG_ID.HEAD: {
      p2._err(token2, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p2, token2);
    }
  }
}
function endTagInHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HEAD: {
      p2.openElements.pop();
      p2.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.BR:
    case html_js_1$1.TAG_ID.HTML: {
      tokenInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    default: {
      p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p2, token2) {
  if (p2.openElements.tmplCount > 0) {
    p2.openElements.generateImpliedEndTagsThoroughly();
    if (p2.openElements.currentTagId !== html_js_1$1.TAG_ID.TEMPLATE) {
      p2._err(token2, error_codes_js_1.ERR.closingOfElementWithOpenChildElements);
    }
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TEMPLATE);
    p2.activeFormattingElements.clearToLastMarker();
    p2.tmplInsertionModeStack.shift();
    p2._resetInsertionMode();
  } else {
    p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p2, token2) {
  p2.openElements.pop();
  p2.insertionMode = InsertionMode.AFTER_HEAD;
  p2._processToken(token2);
}
function startTagInHeadNoScript(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.HEAD:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.STYLE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      p2._err(token2, error_codes_js_1.ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p2, token2);
    }
  }
}
function endTagInHeadNoScript(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      p2.openElements.pop();
      p2.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case html_js_1$1.TAG_ID.BR: {
      tokenInHeadNoScript(p2, token2);
      break;
    }
    default: {
      p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p2, token2) {
  const errCode = token2.type === token_js_1.TokenType.EOF ? error_codes_js_1.ERR.openElementsLeftAfterEof : error_codes_js_1.ERR.disallowedContentInNoscriptInHead;
  p2._err(token2, errCode);
  p2.openElements.pop();
  p2.insertionMode = InsertionMode.IN_HEAD;
  p2._processToken(token2);
}
function startTagAfterHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.framesetOk = false;
      p2.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case html_js_1$1.TAG_ID.FRAMESET: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.TEMPLATE:
    case html_js_1$1.TAG_ID.TITLE: {
      p2._err(token2, error_codes_js_1.ERR.abandonedHeadElementChild);
      p2.openElements.push(p2.headElement, html_js_1$1.TAG_ID.HEAD);
      startTagInHead(p2, token2);
      p2.openElements.remove(p2.headElement);
      break;
    }
    case html_js_1$1.TAG_ID.HEAD: {
      p2._err(token2, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p2, token2);
    }
  }
}
function endTagAfterHead(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.BR: {
      tokenAfterHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    default: {
      p2._err(token2, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p2, token2) {
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.BODY, html_js_1$1.TAG_ID.BODY);
  p2.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p2, token2);
}
function modeInBody(p2, token2) {
  switch (token2.type) {
    case token_js_1.TokenType.CHARACTER: {
      characterInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.COMMENT: {
      appendComment(p2, token2);
      break;
    }
    case token_js_1.TokenType.START_TAG: {
      startTagInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.END_TAG: {
      endTagInBody(p2, token2);
      break;
    }
    case token_js_1.TokenType.EOF: {
      eofInBody(p2, token2);
      break;
    }
  }
}
function whitespaceCharacterInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertCharacters(token2);
}
function characterInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertCharacters(token2);
  p2.framesetOk = false;
}
function htmlStartTagInBody(p2, token2) {
  if (p2.openElements.tmplCount === 0) {
    p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token2.attrs);
  }
}
function bodyStartTagInBody(p2, token2) {
  const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p2.openElements.tmplCount === 0) {
    p2.framesetOk = false;
    p2.treeAdapter.adoptAttributes(bodyElement, token2.attrs);
  }
}
function framesetStartTagInBody(p2, token2) {
  const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
  if (p2.framesetOk && bodyElement) {
    p2.treeAdapter.detachNode(bodyElement);
    p2.openElements.popAllUpToHtmlElement();
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    p2.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function numberedHeaderStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  if ((0, html_js_1$1.isNumberedHeader)(p2.openElements.currentTagId)) {
    p2.openElements.pop();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function preStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.skipNextNewLine = true;
  p2.framesetOk = false;
}
function formStartTagInBody(p2, token2) {
  const inTemplate = p2.openElements.tmplCount > 0;
  if (!p2.formElement || inTemplate) {
    if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
      p2._closePElement();
    }
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    if (!inTemplate) {
      p2.formElement = p2.openElements.current;
    }
  }
}
function listItemStartTagInBody(p2, token2) {
  p2.framesetOk = false;
  const tn = token2.tagID;
  for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
    const elementId = p2.openElements.tagIDs[i2];
    if (tn === html_js_1$1.TAG_ID.LI && elementId === html_js_1$1.TAG_ID.LI || (tn === html_js_1$1.TAG_ID.DD || tn === html_js_1$1.TAG_ID.DT) && (elementId === html_js_1$1.TAG_ID.DD || elementId === html_js_1$1.TAG_ID.DT)) {
      p2.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p2.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== html_js_1$1.TAG_ID.ADDRESS && elementId !== html_js_1$1.TAG_ID.DIV && elementId !== html_js_1$1.TAG_ID.P && p2._isSpecialElement(p2.openElements.items[i2], elementId)) {
      break;
    }
  }
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function plaintextStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.BUTTON)) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.BUTTON);
  }
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
}
function aStartTagInBody(p2, token2) {
  const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(html_js_1$1.TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p2, token2);
    p2.openElements.remove(activeElementEntry.element);
    p2.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
}
function bStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
}
function nobrStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.NOBR)) {
    callAdoptionAgency(p2, token2);
    p2._reconstructActiveFormattingElements();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
}
function appletStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.activeFormattingElements.insertMarker();
  p2.framesetOk = false;
}
function tableStartTagInBody(p2, token2) {
  if (p2.treeAdapter.getDocumentMode(p2.document) !== html_js_1$1.DOCUMENT_MODE.QUIRKS && p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  p2.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  token2.ackSelfClosing = true;
}
function isHiddenInput(token2) {
  const inputType = (0, token_js_1.getTokenAttr)(token2, html_js_1$1.ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  if (!isHiddenInput(token2)) {
    p2.framesetOk = false;
  }
  token2.ackSelfClosing = true;
}
function paramStartTagInBody(p2, token2) {
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  token2.ackSelfClosing = true;
}
function hrStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._appendElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  token2.ackSelfClosing = true;
}
function imageStartTagInBody(p2, token2) {
  token2.tagName = html_js_1$1.TAG_NAMES.IMG;
  token2.tagID = html_js_1$1.TAG_ID.IMG;
  areaStartTagInBody(p2, token2);
}
function textareaStartTagInBody(p2, token2) {
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.skipNextNewLine = true;
  p2.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
  p2.originalInsertionMode = p2.insertionMode;
  p2.framesetOk = false;
  p2.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p2, token2) {
  if (p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._closePElement();
  }
  p2._reconstructActiveFormattingElements();
  p2.framesetOk = false;
  p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p2, token2) {
  p2.framesetOk = false;
  p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody(p2, token2) {
  p2._switchToTextParsing(token2, index_js_1.TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.framesetOk = false;
  p2.insertionMode = p2.insertionMode === InsertionMode.IN_TABLE || p2.insertionMode === InsertionMode.IN_CAPTION || p2.insertionMode === InsertionMode.IN_TABLE_BODY || p2.insertionMode === InsertionMode.IN_ROW || p2.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p2, token2) {
  if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
    p2.openElements.pop();
  }
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function rbStartTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.RUBY)) {
    p2.openElements.generateImpliedEndTags();
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function rtStartTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.RUBY)) {
    p2.openElements.generateImpliedEndTagsWithExclusion(html_js_1$1.TAG_ID.RTC);
  }
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function mathStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  foreignContent.adjustTokenMathMLAttrs(token2);
  foreignContent.adjustTokenXMLAttrs(token2);
  if (token2.selfClosing) {
    p2._appendElement(token2, html_js_1$1.NS.MATHML);
  } else {
    p2._insertElement(token2, html_js_1$1.NS.MATHML);
  }
  token2.ackSelfClosing = true;
}
function svgStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  foreignContent.adjustTokenSVGAttrs(token2);
  foreignContent.adjustTokenXMLAttrs(token2);
  if (token2.selfClosing) {
    p2._appendElement(token2, html_js_1$1.NS.SVG);
  } else {
    p2._insertElement(token2, html_js_1$1.NS.SVG);
  }
  token2.ackSelfClosing = true;
}
function genericStartTagInBody(p2, token2) {
  p2._reconstructActiveFormattingElements();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
}
function startTagInBody(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.I:
    case html_js_1$1.TAG_ID.S:
    case html_js_1$1.TAG_ID.B:
    case html_js_1$1.TAG_ID.U:
    case html_js_1$1.TAG_ID.EM:
    case html_js_1$1.TAG_ID.TT:
    case html_js_1$1.TAG_ID.BIG:
    case html_js_1$1.TAG_ID.CODE:
    case html_js_1$1.TAG_ID.FONT:
    case html_js_1$1.TAG_ID.SMALL:
    case html_js_1$1.TAG_ID.STRIKE:
    case html_js_1$1.TAG_ID.STRONG: {
      bStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.A: {
      aStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.H1:
    case html_js_1$1.TAG_ID.H2:
    case html_js_1$1.TAG_ID.H3:
    case html_js_1$1.TAG_ID.H4:
    case html_js_1$1.TAG_ID.H5:
    case html_js_1$1.TAG_ID.H6: {
      numberedHeaderStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.P:
    case html_js_1$1.TAG_ID.DL:
    case html_js_1$1.TAG_ID.OL:
    case html_js_1$1.TAG_ID.UL:
    case html_js_1$1.TAG_ID.DIV:
    case html_js_1$1.TAG_ID.DIR:
    case html_js_1$1.TAG_ID.NAV:
    case html_js_1$1.TAG_ID.MAIN:
    case html_js_1$1.TAG_ID.MENU:
    case html_js_1$1.TAG_ID.ASIDE:
    case html_js_1$1.TAG_ID.CENTER:
    case html_js_1$1.TAG_ID.FIGURE:
    case html_js_1$1.TAG_ID.FOOTER:
    case html_js_1$1.TAG_ID.HEADER:
    case html_js_1$1.TAG_ID.HGROUP:
    case html_js_1$1.TAG_ID.DIALOG:
    case html_js_1$1.TAG_ID.DETAILS:
    case html_js_1$1.TAG_ID.ADDRESS:
    case html_js_1$1.TAG_ID.ARTICLE:
    case html_js_1$1.TAG_ID.SECTION:
    case html_js_1$1.TAG_ID.SUMMARY:
    case html_js_1$1.TAG_ID.FIELDSET:
    case html_js_1$1.TAG_ID.BLOCKQUOTE:
    case html_js_1$1.TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.LI:
    case html_js_1$1.TAG_ID.DD:
    case html_js_1$1.TAG_ID.DT: {
      listItemStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BR:
    case html_js_1$1.TAG_ID.IMG:
    case html_js_1$1.TAG_ID.WBR:
    case html_js_1$1.TAG_ID.AREA:
    case html_js_1$1.TAG_ID.EMBED:
    case html_js_1$1.TAG_ID.KEYGEN: {
      areaStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HR: {
      hrStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.RB:
    case html_js_1$1.TAG_ID.RTC: {
      rbStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.RT:
    case html_js_1$1.TAG_ID.RP: {
      rtStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.PRE:
    case html_js_1$1.TAG_ID.LISTING: {
      preStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.XMP: {
      xmpStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.SVG: {
      svgStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HTML: {
      htmlStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.TITLE:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY: {
      bodyStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FORM: {
      formStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOBR: {
      nobrStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.MATH: {
      mathStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      tableStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.INPUT: {
      inputStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.PARAM:
    case html_js_1$1.TAG_ID.TRACK:
    case html_js_1$1.TAG_ID.SOURCE: {
      paramStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.IMAGE: {
      imageStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BUTTON: {
      buttonStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.APPLET:
    case html_js_1$1.TAG_ID.OBJECT:
    case html_js_1$1.TAG_ID.MARQUEE: {
      appletStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.IFRAME: {
      iframeStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.SELECT: {
      selectStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.OPTION:
    case html_js_1$1.TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOEMBED: {
      noembedStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FRAMESET: {
      framesetStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOSCRIPT: {
      if (p2.options.scriptingEnabled) {
        noembedStartTagInBody(p2, token2);
      } else {
        genericStartTagInBody(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TR:
    case html_js_1$1.TAG_ID.HEAD:
    case html_js_1$1.TAG_ID.FRAME:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p2, token2);
    }
  }
}
function bodyEndTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.BODY)) {
    p2.insertionMode = InsertionMode.AFTER_BODY;
    if (p2.options.sourceCodeLocationInfo) {
      const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p2._setEndLocation(bodyElement, token2);
      }
    }
  }
}
function htmlEndTagInBody(p2, token2) {
  if (p2.openElements.hasInScope(html_js_1$1.TAG_ID.BODY)) {
    p2.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p2, token2);
  }
}
function addressEndTagInBody(p2, token2) {
  const tn = token2.tagID;
  if (p2.openElements.hasInScope(tn)) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p2) {
  const inTemplate = p2.openElements.tmplCount > 0;
  const { formElement } = p2;
  if (!inTemplate) {
    p2.formElement = null;
  }
  if ((formElement || inTemplate) && p2.openElements.hasInScope(html_js_1$1.TAG_ID.FORM)) {
    p2.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.FORM);
    } else if (formElement) {
      p2.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p2) {
  if (!p2.openElements.hasInButtonScope(html_js_1$1.TAG_ID.P)) {
    p2._insertFakeElement(html_js_1$1.TAG_NAMES.P, html_js_1$1.TAG_ID.P);
  }
  p2._closePElement();
}
function liEndTagInBody(p2) {
  if (p2.openElements.hasInListItemScope(html_js_1$1.TAG_ID.LI)) {
    p2.openElements.generateImpliedEndTagsWithExclusion(html_js_1$1.TAG_ID.LI);
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.LI);
  }
}
function ddEndTagInBody(p2, token2) {
  const tn = token2.tagID;
  if (p2.openElements.hasInScope(tn)) {
    p2.openElements.generateImpliedEndTagsWithExclusion(tn);
    p2.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p2) {
  if (p2.openElements.hasNumberedHeaderInScope()) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p2, token2) {
  const tn = token2.tagID;
  if (p2.openElements.hasInScope(tn)) {
    p2.openElements.generateImpliedEndTags();
    p2.openElements.popUntilTagNamePopped(tn);
    p2.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p2) {
  p2._reconstructActiveFormattingElements();
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.BR, html_js_1$1.TAG_ID.BR);
  p2.openElements.pop();
  p2.framesetOk = false;
}
function genericEndTagInBody(p2, token2) {
  const tn = token2.tagName;
  const tid = token2.tagID;
  for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
    const element2 = p2.openElements.items[i2];
    const elementId = p2.openElements.tagIDs[i2];
    if (tid === elementId && (tid !== html_js_1$1.TAG_ID.UNKNOWN || p2.treeAdapter.getTagName(element2) === tn)) {
      p2.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p2.openElements.stackTop >= i2)
        p2.openElements.shortenToLength(i2);
      break;
    }
    if (p2._isSpecialElement(element2, elementId)) {
      break;
    }
  }
}
function endTagInBody(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.A:
    case html_js_1$1.TAG_ID.B:
    case html_js_1$1.TAG_ID.I:
    case html_js_1$1.TAG_ID.S:
    case html_js_1$1.TAG_ID.U:
    case html_js_1$1.TAG_ID.EM:
    case html_js_1$1.TAG_ID.TT:
    case html_js_1$1.TAG_ID.BIG:
    case html_js_1$1.TAG_ID.CODE:
    case html_js_1$1.TAG_ID.FONT:
    case html_js_1$1.TAG_ID.NOBR:
    case html_js_1$1.TAG_ID.SMALL:
    case html_js_1$1.TAG_ID.STRIKE:
    case html_js_1$1.TAG_ID.STRONG: {
      callAdoptionAgency(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.P: {
      pEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.DL:
    case html_js_1$1.TAG_ID.UL:
    case html_js_1$1.TAG_ID.OL:
    case html_js_1$1.TAG_ID.DIR:
    case html_js_1$1.TAG_ID.DIV:
    case html_js_1$1.TAG_ID.NAV:
    case html_js_1$1.TAG_ID.PRE:
    case html_js_1$1.TAG_ID.MAIN:
    case html_js_1$1.TAG_ID.MENU:
    case html_js_1$1.TAG_ID.ASIDE:
    case html_js_1$1.TAG_ID.BUTTON:
    case html_js_1$1.TAG_ID.CENTER:
    case html_js_1$1.TAG_ID.FIGURE:
    case html_js_1$1.TAG_ID.FOOTER:
    case html_js_1$1.TAG_ID.HEADER:
    case html_js_1$1.TAG_ID.HGROUP:
    case html_js_1$1.TAG_ID.DIALOG:
    case html_js_1$1.TAG_ID.ADDRESS:
    case html_js_1$1.TAG_ID.ARTICLE:
    case html_js_1$1.TAG_ID.DETAILS:
    case html_js_1$1.TAG_ID.SECTION:
    case html_js_1$1.TAG_ID.SUMMARY:
    case html_js_1$1.TAG_ID.LISTING:
    case html_js_1$1.TAG_ID.FIELDSET:
    case html_js_1$1.TAG_ID.BLOCKQUOTE:
    case html_js_1$1.TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.LI: {
      liEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.DD:
    case html_js_1$1.TAG_ID.DT: {
      ddEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.H1:
    case html_js_1$1.TAG_ID.H2:
    case html_js_1$1.TAG_ID.H3:
    case html_js_1$1.TAG_ID.H4:
    case html_js_1$1.TAG_ID.H5:
    case html_js_1$1.TAG_ID.H6: {
      numberedHeaderEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.BR: {
      brEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY: {
      bodyEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.HTML: {
      htmlEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FORM: {
      formEndTagInBody(p2);
      break;
    }
    case html_js_1$1.TAG_ID.APPLET:
    case html_js_1$1.TAG_ID.OBJECT:
    case html_js_1$1.TAG_ID.MARQUEE: {
      appletEndTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    default: {
      genericEndTagInBody(p2, token2);
    }
  }
}
function eofInBody(p2, token2) {
  if (p2.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p2, token2);
  } else {
    stopParsing(p2, token2);
  }
}
function endTagInText(p2, token2) {
  var _a;
  if (token2.tagID === html_js_1$1.TAG_ID.SCRIPT) {
    (_a = p2.scriptHandler) === null || _a === void 0 ? void 0 : _a.call(p2, p2.openElements.current);
  }
  p2.openElements.pop();
  p2.insertionMode = p2.originalInsertionMode;
}
function eofInText(p2, token2) {
  p2._err(token2, error_codes_js_1.ERR.eofInElementThatCanContainOnlyText);
  p2.openElements.pop();
  p2.insertionMode = p2.originalInsertionMode;
  p2.onEof(token2);
}
function characterInTable(p2, token2) {
  if (TABLE_STRUCTURE_TAGS.has(p2.openElements.currentTagId)) {
    p2.pendingCharacterTokens.length = 0;
    p2.hasNonWhitespacePendingCharacterToken = false;
    p2.originalInsertionMode = p2.insertionMode;
    p2.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token2.type) {
      case token_js_1.TokenType.CHARACTER: {
        characterInTableText(p2, token2);
        break;
      }
      case token_js_1.TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p2, token2);
        break;
      }
    }
  } else {
    tokenInTable(p2, token2);
  }
}
function captionStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2.activeFormattingElements.insertMarker();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.COLGROUP, html_js_1$1.TAG_ID.COLGROUP);
  p2.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p2, token2);
}
function tbodyStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertElement(token2, html_js_1$1.NS.HTML);
  p2.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p2, token2) {
  p2.openElements.clearBackToTableContext();
  p2._insertFakeElement(html_js_1$1.TAG_NAMES.TBODY, html_js_1$1.TAG_ID.TBODY);
  p2.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p2, token2);
}
function tableStartTagInTable(p2, token2) {
  if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TABLE)) {
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TABLE);
    p2._resetInsertionMode();
    p2._processStartTag(token2);
  }
}
function inputStartTagInTable(p2, token2) {
  if (isHiddenInput(token2)) {
    p2._appendElement(token2, html_js_1$1.NS.HTML);
  } else {
    tokenInTable(p2, token2);
  }
  token2.ackSelfClosing = true;
}
function formStartTagInTable(p2, token2) {
  if (!p2.formElement && p2.openElements.tmplCount === 0) {
    p2._insertElement(token2, html_js_1$1.NS.HTML);
    p2.formElement = p2.openElements.current;
    p2.openElements.pop();
  }
}
function startTagInTable(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TR: {
      tdStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      colStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FORM: {
      formStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      tableStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      tbodyStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.INPUT: {
      inputStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION: {
      captionStartTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p2, token2);
      break;
    }
    default: {
      tokenInTable(p2, token2);
    }
  }
}
function endTagInTable(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TABLE)) {
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TABLE);
        p2._resetInsertionMode();
      }
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p2, token2);
    }
  }
}
function tokenInTable(p2, token2) {
  const savedFosterParentingState = p2.fosterParentingEnabled;
  p2.fosterParentingEnabled = true;
  modeInBody(p2, token2);
  p2.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p2, token2) {
  p2.pendingCharacterTokens.push(token2);
}
function characterInTableText(p2, token2) {
  p2.pendingCharacterTokens.push(token2);
  p2.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p2, token2) {
  let i2 = 0;
  if (p2.hasNonWhitespacePendingCharacterToken) {
    for (; i2 < p2.pendingCharacterTokens.length; i2++) {
      tokenInTable(p2, p2.pendingCharacterTokens[i2]);
    }
  } else {
    for (; i2 < p2.pendingCharacterTokens.length; i2++) {
      p2._insertCharacters(p2.pendingCharacterTokens[i2]);
    }
  }
  p2.insertionMode = p2.originalInsertionMode;
  p2._processToken(token2);
}
const TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([html_js_1$1.TAG_ID.CAPTION, html_js_1$1.TAG_ID.COL, html_js_1$1.TAG_ID.COLGROUP, html_js_1$1.TAG_ID.TBODY, html_js_1$1.TAG_ID.TD, html_js_1$1.TAG_ID.TFOOT, html_js_1$1.TAG_ID.TH, html_js_1$1.TAG_ID.THEAD, html_js_1$1.TAG_ID.TR]);
function startTagInCaption(p2, token2) {
  const tn = token2.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.CAPTION)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.CAPTION);
      p2.activeFormattingElements.clearToLastMarker();
      p2.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p2, token2);
    }
  } else {
    startTagInBody(p2, token2);
  }
}
function endTagInCaption(p2, token2) {
  const tn = token2.tagID;
  switch (tn) {
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.CAPTION)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.CAPTION);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = InsertionMode.IN_TABLE;
        if (tn === html_js_1$1.TAG_ID.TABLE) {
          endTagInTable(p2, token2);
        }
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p2, token2);
    }
  }
}
function startTagInColumnGroup(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      p2._appendElement(token2, html_js_1$1.NS.HTML);
      token2.ackSelfClosing = true;
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
    default: {
      tokenInColumnGroup(p2, token2);
    }
  }
}
function endTagInColumnGroup(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.COLGROUP: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.COLGROUP) {
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p2, token2);
    }
  }
}
function tokenInColumnGroup(p2, token2) {
  if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.COLGROUP) {
    p2.openElements.pop();
    p2.insertionMode = InsertionMode.IN_TABLE;
    p2._processToken(token2);
  }
}
function startTagInTableBody(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TR: {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TD: {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertFakeElement(html_js_1$1.TAG_NAMES.TR, html_js_1$1.TAG_ID.TR);
      p2.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p2, token2);
      }
      break;
    }
    default: {
      startTagInTable(p2, token2);
    }
  }
}
function endTagInTableBody(p2, token2) {
  const tn = token2.tagID;
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p2, token2);
    }
  }
}
function startTagInRow(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TH:
    case html_js_1$1.TAG_ID.TD: {
      p2.openElements.clearBackToTableRowContext();
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      p2.insertionMode = InsertionMode.IN_CELL;
      p2.activeFormattingElements.insertMarker();
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p2, token2);
      }
      break;
    }
    default: {
      startTagInTable(p2, token2);
    }
  }
}
function endTagInRow(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.TR: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TABLE: {
      if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      if (p2.openElements.hasInTableScope(token2.tagID) || p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML:
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p2, token2);
    }
  }
}
function startTagInCell(p2, token2) {
  const tn = token2.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TD) || p2.openElements.hasInTableScope(html_js_1$1.TAG_ID.TH)) {
      p2._closeTableCell();
      startTagInRow(p2, token2);
    }
  } else {
    startTagInBody(p2, token2);
  }
}
function endTagInCell(p2, token2) {
  const tn = token2.tagID;
  switch (tn) {
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH: {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case html_js_1$1.TAG_ID.TABLE:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD:
    case html_js_1$1.TAG_ID.TR: {
      if (p2.openElements.hasInTableScope(tn)) {
        p2._closeTableCell();
        endTagInRow(p2, token2);
      }
      break;
    }
    case html_js_1$1.TAG_ID.BODY:
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COL:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p2, token2);
    }
  }
}
function startTagInSelect(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.OPTION: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
        p2.openElements.pop();
      }
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      break;
    }
    case html_js_1$1.TAG_ID.OPTGROUP: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTGROUP) {
        p2.openElements.pop();
      }
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      break;
    }
    case html_js_1$1.TAG_ID.INPUT:
    case html_js_1$1.TAG_ID.KEYGEN:
    case html_js_1$1.TAG_ID.TEXTAREA:
    case html_js_1$1.TAG_ID.SELECT: {
      if (p2.openElements.hasInSelectScope(html_js_1$1.TAG_ID.SELECT)) {
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
        p2._resetInsertionMode();
        if (token2.tagID !== html_js_1$1.TAG_ID.SELECT) {
          p2._processStartTag(token2);
        }
      }
      break;
    }
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.TEMPLATE: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function endTagInSelect(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.OPTGROUP: {
      if (p2.openElements.stackTop > 0 && p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION && p2.openElements.tagIDs[p2.openElements.stackTop - 1] === html_js_1$1.TAG_ID.OPTGROUP) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTGROUP) {
        p2.openElements.pop();
      }
      break;
    }
    case html_js_1$1.TAG_ID.OPTION: {
      if (p2.openElements.currentTagId === html_js_1$1.TAG_ID.OPTION) {
        p2.openElements.pop();
      }
      break;
    }
    case html_js_1$1.TAG_ID.SELECT: {
      if (p2.openElements.hasInSelectScope(html_js_1$1.TAG_ID.SELECT)) {
        p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
        p2._resetInsertionMode();
      }
      break;
    }
    case html_js_1$1.TAG_ID.TEMPLATE: {
      templateEndTagInHead(p2, token2);
      break;
    }
  }
}
function startTagInSelectInTable(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.CAPTION || tn === html_js_1$1.TAG_ID.TABLE || tn === html_js_1$1.TAG_ID.TBODY || tn === html_js_1$1.TAG_ID.TFOOT || tn === html_js_1$1.TAG_ID.THEAD || tn === html_js_1$1.TAG_ID.TR || tn === html_js_1$1.TAG_ID.TD || tn === html_js_1$1.TAG_ID.TH) {
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
    p2._resetInsertionMode();
    p2._processStartTag(token2);
  } else {
    startTagInSelect(p2, token2);
  }
}
function endTagInSelectInTable(p2, token2) {
  const tn = token2.tagID;
  if (tn === html_js_1$1.TAG_ID.CAPTION || tn === html_js_1$1.TAG_ID.TABLE || tn === html_js_1$1.TAG_ID.TBODY || tn === html_js_1$1.TAG_ID.TFOOT || tn === html_js_1$1.TAG_ID.THEAD || tn === html_js_1$1.TAG_ID.TR || tn === html_js_1$1.TAG_ID.TD || tn === html_js_1$1.TAG_ID.TH) {
    if (p2.openElements.hasInTableScope(tn)) {
      p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.SELECT);
      p2._resetInsertionMode();
      p2.onEndTag(token2);
    }
  } else {
    endTagInSelect(p2, token2);
  }
}
function startTagInTemplate(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.BASE:
    case html_js_1$1.TAG_ID.BASEFONT:
    case html_js_1$1.TAG_ID.BGSOUND:
    case html_js_1$1.TAG_ID.LINK:
    case html_js_1$1.TAG_ID.META:
    case html_js_1$1.TAG_ID.NOFRAMES:
    case html_js_1$1.TAG_ID.SCRIPT:
    case html_js_1$1.TAG_ID.STYLE:
    case html_js_1$1.TAG_ID.TEMPLATE:
    case html_js_1$1.TAG_ID.TITLE: {
      startTagInHead(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.CAPTION:
    case html_js_1$1.TAG_ID.COLGROUP:
    case html_js_1$1.TAG_ID.TBODY:
    case html_js_1$1.TAG_ID.TFOOT:
    case html_js_1$1.TAG_ID.THEAD: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p2.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.COL: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p2.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TR: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p2.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.TD:
    case html_js_1$1.TAG_ID.TH: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p2.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p2, token2);
      break;
    }
    default: {
      p2.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p2.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p2, token2);
    }
  }
}
function endTagInTemplate(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.TEMPLATE) {
    templateEndTagInHead(p2, token2);
  }
}
function eofInTemplate(p2, token2) {
  if (p2.openElements.tmplCount > 0) {
    p2.openElements.popUntilTagNamePopped(html_js_1$1.TAG_ID.TEMPLATE);
    p2.activeFormattingElements.clearToLastMarker();
    p2.tmplInsertionModeStack.shift();
    p2._resetInsertionMode();
    p2.onEof(token2);
  } else {
    stopParsing(p2, token2);
  }
}
function startTagAfterBody(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    startTagInBody(p2, token2);
  } else {
    tokenAfterBody(p2, token2);
  }
}
function endTagAfterBody(p2, token2) {
  var _a;
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    if (!p2.fragmentContext) {
      p2.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p2.options.sourceCodeLocationInfo && p2.openElements.tagIDs[0] === html_js_1$1.TAG_ID.HTML) {
      p2._setEndLocation(p2.openElements.items[0], token2);
      const bodyElement = p2.openElements.items[1];
      if (bodyElement && !((_a = p2.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a === void 0 ? void 0 : _a.endTag)) {
        p2._setEndLocation(bodyElement, token2);
      }
    }
  } else {
    tokenAfterBody(p2, token2);
  }
}
function tokenAfterBody(p2, token2) {
  p2.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p2, token2);
}
function startTagInFrameset(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.FRAMESET: {
      p2._insertElement(token2, html_js_1$1.NS.HTML);
      break;
    }
    case html_js_1$1.TAG_ID.FRAME: {
      p2._appendElement(token2, html_js_1$1.NS.HTML);
      token2.ackSelfClosing = true;
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function endTagInFrameset(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
    p2.openElements.pop();
    if (!p2.fragmentContext && p2.openElements.currentTagId !== html_js_1$1.TAG_ID.FRAMESET) {
      p2.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function endTagAfterFrameset(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    p2.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.HTML) {
    startTagInBody(p2, token2);
  } else {
    tokenAfterAfterBody(p2, token2);
  }
}
function tokenAfterAfterBody(p2, token2) {
  p2.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p2, token2);
}
function startTagAfterAfterFrameset(p2, token2) {
  switch (token2.tagID) {
    case html_js_1$1.TAG_ID.HTML: {
      startTagInBody(p2, token2);
      break;
    }
    case html_js_1$1.TAG_ID.NOFRAMES: {
      startTagInHead(p2, token2);
      break;
    }
  }
}
function nullCharacterInForeignContent(p2, token2) {
  token2.chars = unicode.REPLACEMENT_CHARACTER;
  p2._insertCharacters(token2);
}
function characterInForeignContent(p2, token2) {
  p2._insertCharacters(token2);
  p2.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p2) {
  while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== html_js_1$1.NS.HTML && !p2._isIntegrationPoint(p2.openElements.currentTagId, p2.openElements.current)) {
    p2.openElements.pop();
  }
}
function startTagInForeignContent(p2, token2) {
  if (foreignContent.causesExit(token2)) {
    popUntilHtmlOrIntegrationPoint(p2);
    p2._startTagOutsideForeignContent(token2);
  } else {
    const current = p2._getAdjustedCurrentElement();
    const currentNs = p2.treeAdapter.getNamespaceURI(current);
    if (currentNs === html_js_1$1.NS.MATHML) {
      foreignContent.adjustTokenMathMLAttrs(token2);
    } else if (currentNs === html_js_1$1.NS.SVG) {
      foreignContent.adjustTokenSVGTagName(token2);
      foreignContent.adjustTokenSVGAttrs(token2);
    }
    foreignContent.adjustTokenXMLAttrs(token2);
    if (token2.selfClosing) {
      p2._appendElement(token2, currentNs);
    } else {
      p2._insertElement(token2, currentNs);
    }
    token2.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p2, token2) {
  if (token2.tagID === html_js_1$1.TAG_ID.P || token2.tagID === html_js_1$1.TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p2);
    p2._endTagOutsideForeignContent(token2);
    return;
  }
  for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
    const element2 = p2.openElements.items[i2];
    if (p2.treeAdapter.getNamespaceURI(element2) === html_js_1$1.NS.HTML) {
      p2._endTagOutsideForeignContent(token2);
      break;
    }
    const tagName = p2.treeAdapter.getTagName(element2);
    if (tagName.toLowerCase() === token2.tagName) {
      token2.tagName = tagName;
      p2.openElements.shortenToLength(i2);
      break;
    }
  }
}
var serializer = {};
var _escape$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c2, index2) {
      return (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i2 = match.index;
      var char = str.charCodeAt(i2);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i2) + next;
        lastIdx = i2 + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports2.getCodePoint)(str, i2).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape$1);
Object.defineProperty(serializer, "__esModule", { value: true });
serializer.serializeOuter = serializer.serialize = void 0;
const html_js_1 = html$4;
const escape_js_1$1 = _escape$1;
const default_js_1 = _default;
const VOID_ELEMENTS = /* @__PURE__ */ new Set([
  html_js_1.TAG_NAMES.AREA,
  html_js_1.TAG_NAMES.BASE,
  html_js_1.TAG_NAMES.BASEFONT,
  html_js_1.TAG_NAMES.BGSOUND,
  html_js_1.TAG_NAMES.BR,
  html_js_1.TAG_NAMES.COL,
  html_js_1.TAG_NAMES.EMBED,
  html_js_1.TAG_NAMES.FRAME,
  html_js_1.TAG_NAMES.HR,
  html_js_1.TAG_NAMES.IMG,
  html_js_1.TAG_NAMES.INPUT,
  html_js_1.TAG_NAMES.KEYGEN,
  html_js_1.TAG_NAMES.LINK,
  html_js_1.TAG_NAMES.META,
  html_js_1.TAG_NAMES.PARAM,
  html_js_1.TAG_NAMES.SOURCE,
  html_js_1.TAG_NAMES.TRACK,
  html_js_1.TAG_NAMES.WBR
]);
function isVoidElement(node2, options2) {
  return options2.treeAdapter.isElementNode(node2) && options2.treeAdapter.getNamespaceURI(node2) === html_js_1.NS.HTML && VOID_ELEMENTS.has(options2.treeAdapter.getTagName(node2));
}
const defaultOpts = { treeAdapter: default_js_1.defaultTreeAdapter, scriptingEnabled: true };
function serialize(node2, options2) {
  const opts = Object.assign(Object.assign({}, defaultOpts), options2);
  if (isVoidElement(node2, opts)) {
    return "";
  }
  return serializeChildNodes(node2, opts);
}
serializer.serialize = serialize;
function serializeOuter(node2, options2) {
  const opts = Object.assign(Object.assign({}, defaultOpts), options2);
  return serializeNode(node2, opts);
}
serializer.serializeOuter = serializeOuter;
function serializeChildNodes(parentNode, options2) {
  let html2 = "";
  const container = options2.treeAdapter.isElementNode(parentNode) && options2.treeAdapter.getTagName(parentNode) === html_js_1.TAG_NAMES.TEMPLATE && options2.treeAdapter.getNamespaceURI(parentNode) === html_js_1.NS.HTML ? options2.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options2.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html2 += serializeNode(currentNode, options2);
    }
  }
  return html2;
}
function serializeNode(node2, options2) {
  if (options2.treeAdapter.isElementNode(node2)) {
    return serializeElement(node2, options2);
  }
  if (options2.treeAdapter.isTextNode(node2)) {
    return serializeTextNode(node2, options2);
  }
  if (options2.treeAdapter.isCommentNode(node2)) {
    return serializeCommentNode(node2, options2);
  }
  if (options2.treeAdapter.isDocumentTypeNode(node2)) {
    return serializeDocumentTypeNode(node2, options2);
  }
  return "";
}
function serializeElement(node2, options2) {
  const tn = options2.treeAdapter.getTagName(node2);
  return `<${tn}${serializeAttributes$1(node2, options2)}>${isVoidElement(node2, options2) ? "" : `${serializeChildNodes(node2, options2)}</${tn}>`}`;
}
function serializeAttributes$1(node2, { treeAdapter }) {
  let html2 = "";
  for (const attr2 of treeAdapter.getAttrList(node2)) {
    html2 += " ";
    if (!attr2.namespace) {
      html2 += attr2.name;
    } else
      switch (attr2.namespace) {
        case html_js_1.NS.XML: {
          html2 += `xml:${attr2.name}`;
          break;
        }
        case html_js_1.NS.XMLNS: {
          if (attr2.name !== "xmlns") {
            html2 += "xmlns:";
          }
          html2 += attr2.name;
          break;
        }
        case html_js_1.NS.XLINK: {
          html2 += `xlink:${attr2.name}`;
          break;
        }
        default: {
          html2 += `${attr2.prefix}:${attr2.name}`;
        }
      }
    html2 += `="${(0, escape_js_1$1.escapeAttribute)(attr2.value)}"`;
  }
  return html2;
}
function serializeTextNode(node2, options2) {
  const { treeAdapter } = options2;
  const content = treeAdapter.getTextNodeContent(node2);
  const parent = treeAdapter.getParentNode(node2);
  const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
  return parentTn && treeAdapter.getNamespaceURI(parent) === html_js_1.NS.HTML && (0, html_js_1.hasUnescapedText)(parentTn, options2.scriptingEnabled) ? content : (0, escape_js_1$1.escapeText)(content);
}
function serializeCommentNode(node2, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node2)}-->`;
}
function serializeDocumentTypeNode(node2, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node2)}>`;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.parseFragment = exports2.parse = exports2.TokenizerMode = exports2.Tokenizer = exports2.Token = exports2.html = exports2.foreignContent = exports2.ErrorCodes = exports2.serializeOuter = exports2.serialize = exports2.Parser = exports2.defaultTreeAdapter = void 0;
  const index_js_12 = parser$2;
  var default_js_12 = _default;
  Object.defineProperty(exports2, "defaultTreeAdapter", { enumerable: true, get: function() {
    return default_js_12.defaultTreeAdapter;
  } });
  var index_js_2 = parser$2;
  Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
    return index_js_2.Parser;
  } });
  var index_js_3 = serializer;
  Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
    return index_js_3.serialize;
  } });
  Object.defineProperty(exports2, "serializeOuter", { enumerable: true, get: function() {
    return index_js_3.serializeOuter;
  } });
  var error_codes_js_12 = errorCodes;
  Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
    return error_codes_js_12.ERR;
  } });
  exports2.foreignContent = foreignContent$1;
  exports2.html = html$4;
  exports2.Token = token;
  var index_js_4 = tokenizer;
  Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
    return index_js_4.Tokenizer;
  } });
  Object.defineProperty(exports2, "TokenizerMode", { enumerable: true, get: function() {
    return index_js_4.TokenizerMode;
  } });
  function parse2(html2, options2) {
    return index_js_12.Parser.parse(html2, options2);
  }
  exports2.parse = parse2;
  function parseFragment(fragmentContext, html2, options2) {
    if (typeof fragmentContext === "string") {
      options2 = html2;
      html2 = fragmentContext;
      fragmentContext = null;
    }
    const parser2 = index_js_12.Parser.getFragmentParser(fragmentContext, options2);
    parser2.tokenizer.write(html2, true);
    return parser2.getFragment();
  }
  exports2.parseFragment = parseFragment;
})(cjs$1);
var cjs = {};
var lib$5 = {};
var node$1 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
Object.defineProperty(node$1, "__esModule", { value: true });
node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.CDATA = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
var domelementtype_1$2 = lib$i;
var Node$1 = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$1(this, recursive);
    };
    return Node2;
  }()
);
node$1.Node = Node$1;
var DataNode$1 = (
  /** @class */
  function(_super) {
    __extends$1(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$1)
);
node$1.DataNode = DataNode$1;
var Text$1 = (
  /** @class */
  function(_super) {
    __extends$1(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode$1)
);
node$1.Text = Text$1;
var Comment$1 = (
  /** @class */
  function(_super) {
    __extends$1(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode$1)
);
node$1.Comment = Comment$1;
var ProcessingInstruction$1 = (
  /** @class */
  function(_super) {
    __extends$1(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$2.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode$1)
);
node$1.ProcessingInstruction = ProcessingInstruction$1;
var NodeWithChildren$1 = (
  /** @class */
  function(_super) {
    __extends$1(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$1)
);
node$1.NodeWithChildren = NodeWithChildren$1;
var CDATA$1 = (
  /** @class */
  function(_super) {
    __extends$1(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren$1)
);
node$1.CDATA = CDATA$1;
var Document$1 = (
  /** @class */
  function(_super) {
    __extends$1(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$2.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren$1)
);
node$1.Document = Document$1;
var Element$1 = (
  /** @class */
  function(_super) {
    __extends$1(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$2.ElementType.Script : name2 === "style" ? domelementtype_1$2.ElementType.Style : domelementtype_1$2.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren$1)
);
node$1.Element = Element$1;
function isTag$1(node2) {
  return (0, domelementtype_1$2.isTag)(node2);
}
node$1.isTag = isTag$1;
function isCDATA$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.CDATA;
}
node$1.isCDATA = isCDATA$1;
function isText$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Text;
}
node$1.isText = isText$1;
function isComment$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Comment;
}
node$1.isComment = isComment$1;
function isDirective$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Directive;
}
node$1.isDirective = isDirective$1;
function isDocument$1(node2) {
  return node2.type === domelementtype_1$2.ElementType.Root;
}
node$1.isDocument = isDocument$1;
function hasChildren$1(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$1.hasChildren = hasChildren$1;
function cloneNode$1(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$1(node2)) {
    result = new Text$1(node2.data);
  } else if (isComment$1(node2)) {
    result = new Comment$1(node2.data);
  } else if (isTag$1(node2)) {
    var children = recursive ? cloneChildren$1(node2.children) : [];
    var clone_1 = new Element$1(node2.name, __assign$2({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$2({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$2({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$1(node2)) {
    var children = recursive ? cloneChildren$1(node2.children) : [];
    var clone_2 = new CDATA$1(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument$1(node2)) {
    var children = recursive ? cloneChildren$1(node2.children) : [];
    var clone_3 = new Document$1(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$1(node2)) {
    var instruction = new ProcessingInstruction$1(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node$1.cloneNode = cloneNode$1;
function cloneChildren$1(childs) {
  var children = childs.map(function(child) {
    return cloneNode$1(child, true);
  });
  for (var i2 = 1; i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node$1;
  __exportStar(node$1, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$5);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.adapter = exports2.serializeDoctypeContent = void 0;
  const parse5_12 = cjs$1;
  const domhandler_12 = lib$5;
  function createTextNode(value) {
    return new domhandler_12.Text(value);
  }
  function enquoteDoctypeId(id2) {
    const quote = id2.includes('"') ? "'" : '"';
    return quote + id2 + quote;
  }
  function serializeDoctypeContent(name2, publicId, systemId) {
    let str = "!DOCTYPE ";
    if (name2) {
      str += name2;
    }
    if (publicId) {
      str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
    } else if (systemId) {
      str += " SYSTEM";
    }
    if (systemId) {
      str += ` ${enquoteDoctypeId(systemId)}`;
    }
    return str;
  }
  exports2.serializeDoctypeContent = serializeDoctypeContent;
  exports2.adapter = {
    // Re-exports from domhandler
    isCommentNode: domhandler_12.isComment,
    isElementNode: domhandler_12.isTag,
    isTextNode: domhandler_12.isText,
    //Node construction
    createDocument() {
      const node2 = new domhandler_12.Document([]);
      node2["x-mode"] = parse5_12.html.DOCUMENT_MODE.NO_QUIRKS;
      return node2;
    },
    createDocumentFragment() {
      return new domhandler_12.Document([]);
    },
    createElement(tagName, namespaceURI, attrs) {
      const attribs = /* @__PURE__ */ Object.create(null);
      const attribsNamespace = /* @__PURE__ */ Object.create(null);
      const attribsPrefix = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0; i2 < attrs.length; i2++) {
        const attrName = attrs[i2].name;
        attribs[attrName] = attrs[i2].value;
        attribsNamespace[attrName] = attrs[i2].namespace;
        attribsPrefix[attrName] = attrs[i2].prefix;
      }
      const node2 = new domhandler_12.Element(tagName, attribs, []);
      node2.namespace = namespaceURI;
      node2["x-attribsNamespace"] = attribsNamespace;
      node2["x-attribsPrefix"] = attribsPrefix;
      return node2;
    },
    createCommentNode(data2) {
      return new domhandler_12.Comment(data2);
    },
    //Tree mutation
    appendChild(parentNode, newNode) {
      const prev = parentNode.children[parentNode.children.length - 1];
      if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
      }
      parentNode.children.push(newNode);
      newNode.parent = parentNode;
    },
    insertBefore(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.children.indexOf(referenceNode);
      const { prev } = referenceNode;
      if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
      }
      referenceNode.prev = newNode;
      newNode.next = referenceNode;
      parentNode.children.splice(insertionIdx, 0, newNode);
      newNode.parent = parentNode;
    },
    setTemplateContent(templateElement, contentElement) {
      exports2.adapter.appendChild(templateElement, contentElement);
    },
    getTemplateContent(templateElement) {
      return templateElement.children[0];
    },
    setDocumentType(document2, name2, publicId, systemId) {
      const data2 = serializeDoctypeContent(name2, publicId, systemId);
      let doctypeNode = document2.children.find((node2) => (0, domhandler_12.isDirective)(node2) && node2.name === "!doctype");
      if (doctypeNode) {
        doctypeNode.data = data2 !== null && data2 !== void 0 ? data2 : null;
      } else {
        doctypeNode = new domhandler_12.ProcessingInstruction("!doctype", data2);
        exports2.adapter.appendChild(document2, doctypeNode);
      }
      doctypeNode["x-name"] = name2 !== null && name2 !== void 0 ? name2 : void 0;
      doctypeNode["x-publicId"] = publicId !== null && publicId !== void 0 ? publicId : void 0;
      doctypeNode["x-systemId"] = systemId !== null && systemId !== void 0 ? systemId : void 0;
    },
    setDocumentMode(document2, mode) {
      document2["x-mode"] = mode;
    },
    getDocumentMode(document2) {
      return document2["x-mode"];
    },
    detachNode(node2) {
      if (node2.parent) {
        const idx = node2.parent.children.indexOf(node2);
        const { prev, next } = node2;
        node2.prev = null;
        node2.next = null;
        if (prev) {
          prev.next = next;
        }
        if (next) {
          next.prev = prev;
        }
        node2.parent.children.splice(idx, 1);
        node2.parent = null;
      }
    },
    insertText(parentNode, text2) {
      const lastChild2 = parentNode.children[parentNode.children.length - 1];
      if (lastChild2 && (0, domhandler_12.isText)(lastChild2)) {
        lastChild2.data += text2;
      } else {
        exports2.adapter.appendChild(parentNode, createTextNode(text2));
      }
    },
    insertTextBefore(parentNode, text2, referenceNode) {
      const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
      if (prevNode && (0, domhandler_12.isText)(prevNode)) {
        prevNode.data += text2;
      } else {
        exports2.adapter.insertBefore(parentNode, createTextNode(text2), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i2 = 0; i2 < attrs.length; i2++) {
        const attrName = attrs[i2].name;
        if (typeof recipient.attribs[attrName] === "undefined") {
          recipient.attribs[attrName] = attrs[i2].value;
          recipient["x-attribsNamespace"][attrName] = attrs[i2].namespace;
          recipient["x-attribsPrefix"][attrName] = attrs[i2].prefix;
        }
      }
    },
    //Tree traversing
    getFirstChild(node2) {
      return node2.children[0];
    },
    getChildNodes(node2) {
      return node2.children;
    },
    getParentNode(node2) {
      return node2.parent;
    },
    getAttrList(element2) {
      return element2.attributes;
    },
    //Node data
    getTagName(element2) {
      return element2.name;
    },
    getNamespaceURI(element2) {
      return element2.namespace;
    },
    getTextNodeContent(textNode) {
      return textNode.data;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.data;
    },
    getDocumentTypeNodeName(doctypeNode) {
      var _a;
      return (_a = doctypeNode["x-name"]) !== null && _a !== void 0 ? _a : "";
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      var _a;
      return (_a = doctypeNode["x-publicId"]) !== null && _a !== void 0 ? _a : "";
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      var _a;
      return (_a = doctypeNode["x-systemId"]) !== null && _a !== void 0 ? _a : "";
    },
    //Node types
    isDocumentTypeNode(node2) {
      return (0, domhandler_12.isDirective)(node2) && node2.name === "!doctype";
    },
    // Source code location
    setNodeSourceCodeLocation(node2, location2) {
      if (location2) {
        node2.startIndex = location2.startOffset;
        node2.endIndex = location2.endOffset;
      }
      node2.sourceCodeLocation = location2;
    },
    getNodeSourceCodeLocation(node2) {
      return node2.sourceCodeLocation;
    },
    updateNodeSourceCodeLocation(node2, endLocation) {
      if (endLocation.endOffset != null)
        node2.endIndex = endLocation.endOffset;
      node2.sourceCodeLocation = Object.assign(Object.assign({}, node2.sourceCodeLocation), endLocation);
    }
  };
})(cjs);
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(parse5Adapter, "__esModule", { value: true });
parse5Adapter.renderWithParse5 = parse5Adapter.parseWithParse5 = void 0;
var domhandler_1$4 = lib$j;
var parse5_1 = cjs$1;
var parse5_htmlparser2_tree_adapter_1 = cjs;
function parseWithParse5(content, options2, isDocument2, context) {
  var opts = {
    scriptingEnabled: typeof options2.scriptingEnabled === "boolean" ? options2.scriptingEnabled : true,
    treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter,
    sourceCodeLocationInfo: options2.sourceCodeLocationInfo
  };
  return isDocument2 ? (0, parse5_1.parse)(content, opts) : (0, parse5_1.parseFragment)(context, content, opts);
}
parse5Adapter.parseWithParse5 = parseWithParse5;
var renderOpts = { treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter };
function renderWithParse5(dom) {
  var _a;
  var nodes = "length" in dom ? dom : [dom];
  for (var index2 = 0; index2 < nodes.length; index2 += 1) {
    var node2 = nodes[index2];
    if ((0, domhandler_1$4.isDocument)(node2)) {
      (_a = Array.prototype.splice).call.apply(_a, __spreadArray([nodes, index2, 1], node2.children, false));
    }
  }
  var result = "";
  for (var index2 = 0; index2 < nodes.length; index2 += 1) {
    var node2 = nodes[index2];
    result += (0, parse5_1.serializeOuter)(node2, renderOpts);
  }
  return result;
}
parse5Adapter.renderWithParse5 = renderWithParse5;
var lib$4 = {};
var Parser$2 = {};
var Tokenizer2 = {};
var decode = {};
var decodeDataHtml = {};
Object.defineProperty(decodeDataHtml, "__esModule", { value: true });
decodeDataHtml.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decodeDataXml = {};
Object.defineProperty(decodeDataXml, "__esModule", { value: true });
decodeDataXml.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c2) {
    return c2.charCodeAt(0);
  })
);
var decode_codepoint = {};
(function(exports2) {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports2.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports2.default = decodeCodePoint;
})(decode_codepoint);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml);
  exports2.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml);
  exports2.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint);
  exports2.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint;
  Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors2;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end2, base2) {
        if (start !== end2) {
          var digitCount = end2 - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports2.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports2.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports2.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports2.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports2.decodeXML = decodeXML;
})(decode);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.QuoteType = void 0;
  var decode_js_12 = decode;
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
    CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
    CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
    CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes2[CharCodes2["Space"] = 32] = "Space";
    CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes2[CharCodes2["Number"] = 35] = "Number";
    CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
    CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
    CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
    CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
    CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
    CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
    CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
    CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
    CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
    CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
    CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
    CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
    CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
    CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
    CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
    CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
    CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
    CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
    CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  var State2;
  (function(State3) {
    State3[State3["Text"] = 1] = "Text";
    State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
    State3[State3["InTagName"] = 3] = "InTagName";
    State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
    State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State3[State3["InAttributeName"] = 9] = "InAttributeName";
    State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
    State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State3[State3["InDeclaration"] = 16] = "InDeclaration";
    State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State3[State3["BeforeComment"] = 18] = "BeforeComment";
    State3[State3["CDATASequence"] = 19] = "CDATASequence";
    State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
    State3[State3["InCommentLike"] = 21] = "InCommentLike";
    State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
    State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
    State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
    State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
    State3[State3["InHexEntity"] = 29] = "InHexEntity";
  })(State2 || (State2 = {}));
  function isWhitespace2(c2) {
    return c2 === CharCodes.Space || c2 === CharCodes.NewLine || c2 === CharCodes.Tab || c2 === CharCodes.FormFeed || c2 === CharCodes.CarriageReturn;
  }
  function isEndOfTagSection(c2) {
    return c2 === CharCodes.Slash || c2 === CharCodes.Gt || isWhitespace2(c2);
  }
  function isNumber(c2) {
    return c2 >= CharCodes.Zero && c2 <= CharCodes.Nine;
  }
  function isASCIIAlpha(c2) {
    return c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerZ || c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperZ;
  }
  function isHexDigit(c2) {
    return c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperF || c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerF;
  }
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType = exports2.QuoteType || (exports2.QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    // `</title`
  };
  var Tokenizer3 = (
    /** @class */
    function() {
      function Tokenizer4(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        this.state = State2.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State2.Text;
        this.isSpecial = false;
        this.running = true;
        this.offset = 0;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_12.xmlDecodeTree : decode_js_12.htmlDecodeTree;
      }
      Tokenizer4.prototype.reset = function() {
        this.state = State2.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State2.Text;
        this.currentSequence = void 0;
        this.running = true;
        this.offset = 0;
      };
      Tokenizer4.prototype.write = function(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
      };
      Tokenizer4.prototype.end = function() {
        if (this.running)
          this.finish();
      };
      Tokenizer4.prototype.pause = function() {
        this.running = false;
      };
      Tokenizer4.prototype.resume = function() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
          this.parse();
        }
      };
      Tokenizer4.prototype.getIndex = function() {
        return this.index;
      };
      Tokenizer4.prototype.getSectionStart = function() {
        return this.sectionStart;
      };
      Tokenizer4.prototype.stateText = function(c2) {
        if (c2 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = State2.BeforeTagName;
          this.sectionStart = this.index;
        } else if (this.decodeEntities && c2 === CharCodes.Amp) {
          this.state = State2.BeforeEntity;
        }
      };
      Tokenizer4.prototype.stateSpecialStartSequence = function(c2) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c2)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c2 | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.isSpecial = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = State2.InTagName;
        this.stateInTagName(c2);
      };
      Tokenizer4.prototype.stateInSpecialTag = function(c2) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c2 === CharCodes.Gt || isWhitespace2(c2)) {
            var endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              var actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.isSpecial = false;
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c2);
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd) {
            if (this.decodeEntities && c2 === CharCodes.Amp) {
              this.state = State2.BeforeEntity;
            }
          } else if (this.fastForwardTo(CharCodes.Lt)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c2 === CharCodes.Lt);
        }
      };
      Tokenizer4.prototype.stateCDATASequence = function(c2) {
        if (c2 === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = State2.InCommentLike;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = State2.InDeclaration;
          this.stateInDeclaration(c2);
        }
      };
      Tokenizer4.prototype.fastForwardTo = function(c2) {
        while (++this.index < this.buffer.length + this.offset) {
          if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
            return true;
          }
        }
        this.index = this.buffer.length + this.offset - 1;
        return false;
      };
      Tokenizer4.prototype.stateInCommentLike = function(c2) {
        if (c2 === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index, 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index, 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = State2.Text;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      };
      Tokenizer4.prototype.isTagStartChar = function(c2) {
        return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
      };
      Tokenizer4.prototype.startSpecial = function(sequence2, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence2;
        this.sequenceIndex = offset;
        this.state = State2.SpecialStartSequence;
      };
      Tokenizer4.prototype.stateBeforeTagName = function(c2) {
        if (c2 === CharCodes.ExclamationMark) {
          this.state = State2.BeforeDeclaration;
          this.sectionStart = this.index + 1;
        } else if (c2 === CharCodes.Questionmark) {
          this.state = State2.InProcessingInstruction;
          this.sectionStart = this.index + 1;
        } else if (this.isTagStartChar(c2)) {
          var lower = c2 | 32;
          this.sectionStart = this.index;
          if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
            this.startSpecial(Sequences.TitleEnd, 3);
          } else {
            this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
          }
        } else if (c2 === CharCodes.Slash) {
          this.state = State2.BeforeClosingTagName;
        } else {
          this.state = State2.Text;
          this.stateText(c2);
        }
      };
      Tokenizer4.prototype.stateInTagName = function(c2) {
        if (isEndOfTagSection(c2)) {
          this.cbs.onopentagname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c2);
        }
      };
      Tokenizer4.prototype.stateBeforeClosingTagName = function(c2) {
        if (isWhitespace2(c2))
          ;
        else if (c2 === CharCodes.Gt) {
          this.state = State2.Text;
        } else {
          this.state = this.isTagStartChar(c2) ? State2.InClosingTagName : State2.InSpecialComment;
          this.sectionStart = this.index;
        }
      };
      Tokenizer4.prototype.stateInClosingTagName = function(c2) {
        if (c2 === CharCodes.Gt || isWhitespace2(c2)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State2.AfterClosingTagName;
          this.stateAfterClosingTagName(c2);
        }
      };
      Tokenizer4.prototype.stateAfterClosingTagName = function(c2) {
        if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.state = State2.Text;
          this.baseState = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateBeforeAttributeName = function(c2) {
        if (c2 === CharCodes.Gt) {
          this.cbs.onopentagend(this.index);
          if (this.isSpecial) {
            this.state = State2.InSpecialTag;
            this.sequenceIndex = 0;
          } else {
            this.state = State2.Text;
          }
          this.baseState = this.state;
          this.sectionStart = this.index + 1;
        } else if (c2 === CharCodes.Slash) {
          this.state = State2.InSelfClosingTag;
        } else if (!isWhitespace2(c2)) {
          this.state = State2.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer4.prototype.stateInSelfClosingTag = function(c2) {
        if (c2 === CharCodes.Gt) {
          this.cbs.onselfclosingtag(this.index);
          this.state = State2.Text;
          this.baseState = State2.Text;
          this.sectionStart = this.index + 1;
          this.isSpecial = false;
        } else if (!isWhitespace2(c2)) {
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c2);
        }
      };
      Tokenizer4.prototype.stateInAttributeName = function(c2) {
        if (c2 === CharCodes.Eq || isEndOfTagSection(c2)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State2.AfterAttributeName;
          this.stateAfterAttributeName(c2);
        }
      };
      Tokenizer4.prototype.stateAfterAttributeName = function(c2) {
        if (c2 === CharCodes.Eq) {
          this.state = State2.BeforeAttributeValue;
        } else if (c2 === CharCodes.Slash || c2 === CharCodes.Gt) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c2);
        } else if (!isWhitespace2(c2)) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State2.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer4.prototype.stateBeforeAttributeValue = function(c2) {
        if (c2 === CharCodes.DoubleQuote) {
          this.state = State2.InAttributeValueDq;
          this.sectionStart = this.index + 1;
        } else if (c2 === CharCodes.SingleQuote) {
          this.state = State2.InAttributeValueSq;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace2(c2)) {
          this.sectionStart = this.index;
          this.state = State2.InAttributeValueNq;
          this.stateInAttributeValueNoQuotes(c2);
        }
      };
      Tokenizer4.prototype.handleInAttributeValue = function(c2, quote) {
        if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
          this.state = State2.BeforeAttributeName;
        } else if (this.decodeEntities && c2 === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State2.BeforeEntity;
        }
      };
      Tokenizer4.prototype.stateInAttributeValueDoubleQuotes = function(c2) {
        this.handleInAttributeValue(c2, CharCodes.DoubleQuote);
      };
      Tokenizer4.prototype.stateInAttributeValueSingleQuotes = function(c2) {
        this.handleInAttributeValue(c2, CharCodes.SingleQuote);
      };
      Tokenizer4.prototype.stateInAttributeValueNoQuotes = function(c2) {
        if (isWhitespace2(c2) || c2 === CharCodes.Gt) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(QuoteType.Unquoted, this.index);
          this.state = State2.BeforeAttributeName;
          this.stateBeforeAttributeName(c2);
        } else if (this.decodeEntities && c2 === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State2.BeforeEntity;
        }
      };
      Tokenizer4.prototype.stateBeforeDeclaration = function(c2) {
        if (c2 === CharCodes.OpeningSquareBracket) {
          this.state = State2.CDATASequence;
          this.sequenceIndex = 0;
        } else {
          this.state = c2 === CharCodes.Dash ? State2.BeforeComment : State2.InDeclaration;
        }
      };
      Tokenizer4.prototype.stateInDeclaration = function(c2) {
        if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.ondeclaration(this.sectionStart, this.index);
          this.state = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateInProcessingInstruction = function(c2) {
        if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateBeforeComment = function(c2) {
        if (c2 === CharCodes.Dash) {
          this.state = State2.InCommentLike;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = State2.InDeclaration;
        }
      };
      Tokenizer4.prototype.stateInSpecialComment = function(c2) {
        if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.oncomment(this.sectionStart, this.index, 0);
          this.state = State2.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer4.prototype.stateBeforeSpecialS = function(c2) {
        var lower = c2 | 32;
        if (lower === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = State2.InTagName;
          this.stateInTagName(c2);
        }
      };
      Tokenizer4.prototype.stateBeforeEntity = function(c2) {
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c2 === CharCodes.Number) {
          this.state = State2.BeforeNumericEntity;
        } else if (c2 === CharCodes.Amp)
          ;
        else {
          this.trieIndex = 0;
          this.trieCurrent = this.entityTrie[0];
          this.state = State2.InNamedEntity;
          this.stateInNamedEntity(c2);
        }
      };
      Tokenizer4.prototype.stateInNamedEntity = function(c2) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_12.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
        if (this.trieIndex < 0) {
          this.emitNamedEntity();
          this.index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_12.BinTrieFlags.VALUE_LENGTH;
        if (masked) {
          var valueLength = (masked >> 14) - 1;
          if (!this.allowLegacyEntity() && c2 !== CharCodes.Semi) {
            this.trieIndex += valueLength;
          } else {
            var entityStart = this.index - this.entityExcess + 1;
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.entityResult = this.trieIndex;
            this.trieIndex += valueLength;
            this.entityExcess = 0;
            this.sectionStart = this.index + 1;
            if (valueLength === 0) {
              this.emitNamedEntity();
            }
          }
        }
      };
      Tokenizer4.prototype.emitNamedEntity = function() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
          return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_12.BinTrieFlags.VALUE_LENGTH) >> 14;
        switch (valueLength) {
          case 1: {
            this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_12.BinTrieFlags.VALUE_LENGTH);
            break;
          }
          case 2: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            break;
          }
          case 3: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
          }
        }
      };
      Tokenizer4.prototype.stateBeforeNumericEntity = function(c2) {
        if ((c2 | 32) === CharCodes.LowerX) {
          this.entityExcess++;
          this.state = State2.InHexEntity;
        } else {
          this.state = State2.InNumericEntity;
          this.stateInNumericEntity(c2);
        }
      };
      Tokenizer4.prototype.emitNumericEntity = function(strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
        if (numberStart !== this.index) {
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.sectionStart = this.index + Number(strict);
          this.emitCodePoint((0, decode_js_12.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
      };
      Tokenizer4.prototype.stateInNumericEntity = function(c2) {
        if (c2 === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber(c2)) {
          this.entityResult = this.entityResult * 10 + (c2 - CharCodes.Zero);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer4.prototype.stateInHexEntity = function(c2) {
        if (c2 === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber(c2)) {
          this.entityResult = this.entityResult * 16 + (c2 - CharCodes.Zero);
          this.entityExcess++;
        } else if (isHexDigit(c2)) {
          this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes.LowerA + 10);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer4.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
      };
      Tokenizer4.prototype.cleanup = function() {
        if (this.running && this.sectionStart !== this.index) {
          if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      };
      Tokenizer4.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
      };
      Tokenizer4.prototype.parse = function() {
        while (this.shouldContinue()) {
          var c2 = this.buffer.charCodeAt(this.index - this.offset);
          switch (this.state) {
            case State2.Text: {
              this.stateText(c2);
              break;
            }
            case State2.SpecialStartSequence: {
              this.stateSpecialStartSequence(c2);
              break;
            }
            case State2.InSpecialTag: {
              this.stateInSpecialTag(c2);
              break;
            }
            case State2.CDATASequence: {
              this.stateCDATASequence(c2);
              break;
            }
            case State2.InAttributeValueDq: {
              this.stateInAttributeValueDoubleQuotes(c2);
              break;
            }
            case State2.InAttributeName: {
              this.stateInAttributeName(c2);
              break;
            }
            case State2.InCommentLike: {
              this.stateInCommentLike(c2);
              break;
            }
            case State2.InSpecialComment: {
              this.stateInSpecialComment(c2);
              break;
            }
            case State2.BeforeAttributeName: {
              this.stateBeforeAttributeName(c2);
              break;
            }
            case State2.InTagName: {
              this.stateInTagName(c2);
              break;
            }
            case State2.InClosingTagName: {
              this.stateInClosingTagName(c2);
              break;
            }
            case State2.BeforeTagName: {
              this.stateBeforeTagName(c2);
              break;
            }
            case State2.AfterAttributeName: {
              this.stateAfterAttributeName(c2);
              break;
            }
            case State2.InAttributeValueSq: {
              this.stateInAttributeValueSingleQuotes(c2);
              break;
            }
            case State2.BeforeAttributeValue: {
              this.stateBeforeAttributeValue(c2);
              break;
            }
            case State2.BeforeClosingTagName: {
              this.stateBeforeClosingTagName(c2);
              break;
            }
            case State2.AfterClosingTagName: {
              this.stateAfterClosingTagName(c2);
              break;
            }
            case State2.BeforeSpecialS: {
              this.stateBeforeSpecialS(c2);
              break;
            }
            case State2.InAttributeValueNq: {
              this.stateInAttributeValueNoQuotes(c2);
              break;
            }
            case State2.InSelfClosingTag: {
              this.stateInSelfClosingTag(c2);
              break;
            }
            case State2.InDeclaration: {
              this.stateInDeclaration(c2);
              break;
            }
            case State2.BeforeDeclaration: {
              this.stateBeforeDeclaration(c2);
              break;
            }
            case State2.BeforeComment: {
              this.stateBeforeComment(c2);
              break;
            }
            case State2.InProcessingInstruction: {
              this.stateInProcessingInstruction(c2);
              break;
            }
            case State2.InNamedEntity: {
              this.stateInNamedEntity(c2);
              break;
            }
            case State2.BeforeEntity: {
              this.stateBeforeEntity(c2);
              break;
            }
            case State2.InHexEntity: {
              this.stateInHexEntity(c2);
              break;
            }
            case State2.InNumericEntity: {
              this.stateInNumericEntity(c2);
              break;
            }
            default: {
              this.stateBeforeNumericEntity(c2);
            }
          }
          this.index++;
        }
        this.cleanup();
      };
      Tokenizer4.prototype.finish = function() {
        if (this.state === State2.InNamedEntity) {
          this.emitNamedEntity();
        }
        if (this.sectionStart < this.index) {
          this.handleTrailingData();
        }
        this.cbs.onend();
      };
      Tokenizer4.prototype.handleTrailingData = function() {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State2.InCommentLike) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex, 0);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex, 0);
          }
        } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName)
          ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      };
      Tokenizer4.prototype.emitPartial = function(start, endIndex) {
        if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
          this.cbs.onattribdata(start, endIndex);
        } else {
          this.cbs.ontext(start, endIndex);
        }
      };
      Tokenizer4.prototype.emitCodePoint = function(cp) {
        if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
          this.cbs.onattribentity(cp);
        } else {
          this.cbs.ontextentity(cp);
        }
      };
      return Tokenizer4;
    }()
  );
  exports2.default = Tokenizer3;
})(Tokenizer2);
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$1(result, mod, k2);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
Object.defineProperty(Parser$2, "__esModule", { value: true });
Parser$2.Parser = void 0;
var Tokenizer_js_1 = __importStar$1(Tokenizer2);
var decode_js_1 = decode;
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser$1 = (
  /** @class */
  function() {
    function Parser3(cbs, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _a, _b, _c, _d, _e;
      this.options = options2;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
      this.lowerCaseTagNames = (_a = options2.lowerCaseTags) !== null && _a !== void 0 ? _a : !options2.xmlMode;
      this.lowerCaseAttributeNames = (_b = options2.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options2.xmlMode;
      this.tokenizer = new ((_c = options2.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    Parser3.prototype.ontext = function(start, endIndex) {
      var _a, _b;
      var data2 = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data2);
      this.startIndex = endIndex;
    };
    Parser3.prototype.ontextentity = function(cp) {
      var _a, _b;
      var index2 = this.tokenizer.getSectionStart();
      this.endIndex = index2 - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
      this.startIndex = index2;
    };
    Parser3.prototype.isVoidElement = function(name2) {
      return !this.options.xmlMode && voidElements.has(name2);
    };
    Parser3.prototype.onopentagname = function(start, endIndex) {
      this.endIndex = endIndex;
      var name2 = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      this.emitOpenTag(name2);
    };
    Parser3.prototype.emitOpenTag = function(name2) {
      var _a, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name2;
      var impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          var element2 = this.stack.pop();
          (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element2, true);
        }
      }
      if (!this.isVoidElement(name2)) {
        this.stack.push(name2);
        if (foreignContextElements.has(name2)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name2)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
      if (this.cbs.onopentag)
        this.attribs = {};
    };
    Parser3.prototype.endOpenTag = function(isImplied) {
      var _a, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    };
    Parser3.prototype.onopentagend = function(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onclosetag = function(start, endIndex) {
      var _a, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      var name2 = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name2)) {
        var pos = this.stack.lastIndexOf(name2);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            var count2 = this.stack.length - pos;
            while (count2--) {
              this.cbs.onclosetag(this.stack.pop(), count2 !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name2 === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name2 === "br") {
        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onselfclosingtag = function(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    };
    Parser3.prototype.closeCurrentTag = function(isOpenImplied) {
      var _a, _b;
      var name2 = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name2) {
        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name2, !isOpenImplied);
        this.stack.pop();
      }
    };
    Parser3.prototype.onattribname = function(start, endIndex) {
      this.startIndex = start;
      var name2 = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
    };
    Parser3.prototype.onattribdata = function(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    };
    Parser3.prototype.onattribentity = function(cp) {
      this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    Parser3.prototype.onattribend = function(quote, endIndex) {
      var _a, _b;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    };
    Parser3.prototype.getInstructionName = function(value) {
      var index2 = value.search(reNameEnd);
      var name2 = index2 < 0 ? value : value.substr(0, index2);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      return name2;
    };
    Parser3.prototype.ondeclaration = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("!".concat(name2), "!".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onprocessinginstruction = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("?".concat(name2), "?".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.oncomment = function(start, endIndex, offset) {
      var _a, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.oncdata = function(start, endIndex, offset) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
        (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onend = function() {
      var _a, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
          ;
      }
      (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    Parser3.prototype.reset = function() {
      var _a, _b, _c, _d;
      (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    };
    Parser3.prototype.parseComplete = function(data2) {
      this.reset();
      this.end(data2);
    };
    Parser3.prototype.getSlice = function(start, end2) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      var slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
      while (end2 - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
      }
      return slice2;
    };
    Parser3.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    };
    Parser3.prototype.write = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    };
    Parser3.prototype.end = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    };
    Parser3.prototype.pause = function() {
      this.tokenizer.pause();
    };
    Parser3.prototype.resume = function() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    };
    Parser3.prototype.parseChunk = function(chunk) {
      this.write(chunk);
    };
    Parser3.prototype.done = function(chunk) {
      this.end(chunk);
    };
    return Parser3;
  }()
);
Parser$2.Parser = Parser$1;
var lib$3 = {};
var node = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
Object.defineProperty(node, "__esModule", { value: true });
node.cloneNode = node.hasChildren = node.isDocument = node.isDirective = node.isComment = node.isText = node.isCDATA = node.isTag = node.Element = node.Document = node.CDATA = node.NodeWithChildren = node.ProcessingInstruction = node.Comment = node.Text = node.DataNode = node.Node = void 0;
var domelementtype_1$1 = lib$i;
var Node = (
  /** @class */
  function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode(this, recursive);
    };
    return Node2;
  }()
);
node.Node = Node;
var DataNode = (
  /** @class */
  function(_super) {
    __extends(DataNode2, _super);
    function DataNode2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data2) {
        this.data = data2;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node)
);
node.DataNode = DataNode;
var Text = (
  /** @class */
  function(_super) {
    __extends(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode)
);
node.Text = Text;
var Comment = (
  /** @class */
  function(_super) {
    __extends(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode)
);
node.Comment = Comment;
var ProcessingInstruction = (
  /** @class */
  function(_super) {
    __extends(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data2) {
      var _this = _super.call(this, data2) || this;
      _this.name = name2;
      _this.type = domelementtype_1$1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode)
);
node.ProcessingInstruction = ProcessingInstruction;
var NodeWithChildren = (
  /** @class */
  function(_super) {
    __extends(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node)
);
node.NodeWithChildren = NodeWithChildren;
var CDATA = (
  /** @class */
  function(_super) {
    __extends(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren)
);
node.CDATA = CDATA;
var Document = (
  /** @class */
  function(_super) {
    __extends(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren)
);
node.Document = Document;
var Element = (
  /** @class */
  function(_super) {
    __extends(Element2, _super);
    function Element2(name2, attribs, children, type) {
      if (children === void 0) {
        children = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$1.ElementType.Script : name2 === "style" ? domelementtype_1$1.ElementType.Style : domelementtype_1$1.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren)
);
node.Element = Element;
function isTag(node2) {
  return (0, domelementtype_1$1.isTag)(node2);
}
node.isTag = isTag;
function isCDATA(node2) {
  return node2.type === domelementtype_1$1.ElementType.CDATA;
}
node.isCDATA = isCDATA;
function isText(node2) {
  return node2.type === domelementtype_1$1.ElementType.Text;
}
node.isText = isText;
function isComment(node2) {
  return node2.type === domelementtype_1$1.ElementType.Comment;
}
node.isComment = isComment;
function isDirective(node2) {
  return node2.type === domelementtype_1$1.ElementType.Directive;
}
node.isDirective = isDirective;
function isDocument(node2) {
  return node2.type === domelementtype_1$1.ElementType.Root;
}
node.isDocument = isDocument;
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node.hasChildren = hasChildren;
function cloneNode(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText(node2)) {
    result = new Text(node2.data);
  } else if (isComment(node2)) {
    result = new Comment(node2.data);
  } else if (isTag(node2)) {
    var children = recursive ? cloneChildren(node2.children) : [];
    var clone_1 = new Element(node2.name, __assign$1({}, node2.attribs), children);
    children.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$1({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$1({}, node2["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA(node2)) {
    var children = recursive ? cloneChildren(node2.children) : [];
    var clone_2 = new CDATA(children);
    children.forEach(function(child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument(node2)) {
    var children = recursive ? cloneChildren(node2.children) : [];
    var clone_3 = new Document(children);
    children.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result = clone_3;
  } else if (isDirective(node2)) {
    var instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
node.cloneNode = cloneNode;
function cloneChildren(childs) {
  var children = childs.map(function(child) {
    return cloneNode(child, true);
  });
  for (var i2 = 1; i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomHandler = void 0;
  var domelementtype_12 = lib$i;
  var node_js_1 = node;
  __exportStar(node, exports2);
  var defaultOpts2 = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options2, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options2 === "function") {
          elementCB = options2;
          options2 = defaultOpts2;
        }
        if (typeof callback === "object") {
          options2 = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts2;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element2 = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element2);
        this.tagStack.push(element2);
      };
      DomHandler2.prototype.ontext = function(data2) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data2;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data2);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data2) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data2;
          return;
        }
        var node2 = new node_js_1.Comment(data2);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data2);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports2.DomHandler = DomHandler;
  exports2.default = DomHandler;
})(lib$3);
var lib$2 = {};
var stringify$3 = {};
var lib$1 = {};
var lib = {};
var encode = {};
var encodeHtml = {};
Object.defineProperty(encodeHtml, "__esModule", { value: true });
function restoreDiff(arr) {
  for (var i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
encodeHtml.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
  exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index2) {
    return str.codePointAt(index2);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c2, index2) {
      return (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports2.xmlReplacer.exec(str)) !== null) {
      var i2 = match.index;
      var char = str.charCodeAt(i2);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i2) + next;
        lastIdx = i2 + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports2.getCodePoint)(str, i2).toString(16), ";");
        lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports2.encodeXML = encodeXML;
  exports2.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data2) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data2)) {
        if (lastIdx !== match.index) {
          result += data2.substring(lastIdx, match.index);
        }
        result += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.encodeNonAsciiHTML = encode.encodeHTML = void 0;
var encode_html_js_1 = __importDefault$1(encodeHtml);
var escape_js_1 = _escape;
var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML(data2) {
  return encodeHTMLTrieRe(htmlReplacer, data2);
}
encode.encodeHTML = encodeHTML;
function encodeNonAsciiHTML(data2) {
  return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data2);
}
encode.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i2 = match.index;
    ret += str.substring(lastIdx, i2);
    var char = str.charCodeAt(i2);
    var next = encode_html_js_1.default.get(char);
    if (typeof next === "object") {
      if (i2 + 1 < str.length) {
        var nextChar = str.charCodeAt(i2 + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i2 + 1;
    } else {
      var cp = (0, escape_js_1.getCodePoint)(str, i2);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
  var decode_js_12 = decode;
  var encode_js_1 = encode;
  var escape_js_12 = _escape;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
  function decode$12(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var level = typeof options2 === "number" ? options2 : options2.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options2 === "object" ? options2.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data2, mode);
    }
    return (0, decode_js_12.decodeXML)(data2);
  }
  exports2.decode = decode$12;
  function decodeStrict(data2, options2) {
    var _a;
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode$12(data2, opts);
  }
  exports2.decodeStrict = decodeStrict;
  function encode$12(data2, options2) {
    if (options2 === void 0) {
      options2 = EntityLevel.XML;
    }
    var opts = typeof options2 === "number" ? { level: options2 } : options2;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data2);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data2);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data2);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data2);
      }
      return (0, encode_js_1.encodeHTML)(data2);
    }
    return (0, escape_js_12.encodeXML)(data2);
  }
  exports2.encode = encode$12;
  var escape_js_2 = _escape;
  Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode;
  Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode;
  Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib);
var foreignNames = {};
Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
foreignNames.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val2) {
  return [val2.toLowerCase(), val2];
}));
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(lib$1, "__esModule", { value: true });
lib$1.render = void 0;
var ElementType = __importStar(lib$i);
var entities_1 = lib;
var foreignNames_js_1 = foreignNames;
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
  return Object.keys(attributes2).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes2[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode(nodes[i2], options2);
  }
  return output;
}
lib$1.render = render;
lib$1.default = render;
function renderNode(node2, options2) {
  switch (node2.type) {
    case ElementType.Root:
      return render(node2.children, options2);
    case ElementType.Doctype:
    case ElementType.Directive:
      return renderDirective(node2);
    case ElementType.Comment:
      return renderComment(node2);
    case ElementType.CDATA:
      return renderCdata(node2);
    case ElementType.Script:
    case ElementType.Style:
    case ElementType.Tag:
      return renderTag(node2, options2);
    case ElementType.Text:
      return renderText(node2, options2);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective(elem) {
  return "<".concat(elem.data, ">");
}
function renderText(elem, opts) {
  var _a;
  var data2 = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data2) : (0, entities_1.escapeText)(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$3, "__esModule", { value: true });
stringify$3.innerText = stringify$3.textContent = stringify$3.getText = stringify$3.getInnerHTML = stringify$3.getOuterHTML = void 0;
var domhandler_1$3 = lib$3;
var dom_serializer_1 = __importDefault(lib$1);
var domelementtype_1 = lib$i;
function getOuterHTML(node2, options2) {
  return (0, dom_serializer_1.default)(node2, options2);
}
stringify$3.getOuterHTML = getOuterHTML;
function getInnerHTML(node2, options2) {
  return (0, domhandler_1$3.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML(node3, options2);
  }).join("") : "";
}
stringify$3.getInnerHTML = getInnerHTML;
function getText(node2) {
  if (Array.isArray(node2))
    return node2.map(getText).join("");
  if ((0, domhandler_1$3.isTag)(node2))
    return node2.name === "br" ? "\n" : getText(node2.children);
  if ((0, domhandler_1$3.isCDATA)(node2))
    return getText(node2.children);
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$3.getText = getText;
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if ((0, domhandler_1$3.hasChildren)(node2) && !(0, domhandler_1$3.isComment)(node2)) {
    return textContent(node2.children);
  }
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$3.textContent = textContent;
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if ((0, domhandler_1$3.hasChildren)(node2) && (node2.type === domelementtype_1.ElementType.Tag || (0, domhandler_1$3.isCDATA)(node2))) {
    return innerText(node2.children);
  }
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$3.innerText = innerText;
var traversal = {};
Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$2 = lib$3;
function getChildren(elem) {
  return (0, domhandler_1$2.hasChildren)(elem) ? elem.children : [];
}
traversal.getChildren = getChildren;
function getParent(elem) {
  return elem.parent || null;
}
traversal.getParent = getParent;
function getSiblings(elem) {
  var _a, _b;
  var parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  var siblings2 = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings2.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings2.push(next);
    _b = next, next = _b.next;
  }
  return siblings2;
}
traversal.getSiblings = getSiblings;
function getAttributeValue(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal.getAttributeValue = getAttributeValue;
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal.hasAttrib = hasAttrib;
function getName(elem) {
  return elem.name;
}
traversal.getName = getName;
function nextElementSibling(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$2.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal.nextElementSibling = nextElementSibling;
function prevElementSibling(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$2.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal.prevElementSibling = prevElementSibling;
var manipulation = {};
Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation.removeElement = removeElement;
function replaceElement(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation.replaceElement = replaceElement;
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation.appendChild = appendChild;
function append(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation.append = append;
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation.prependChild = prependChild;
function prepend(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation.prepend = prepend;
var querying = {};
Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$1 = lib$3;
function filter(test2, node2, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$1(test2, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
querying.filter = filter;
function find$1(test2, nodes, recurse, limit) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && (0, domhandler_1$1.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.find = find$1;
function findOneChild(test2, nodes) {
  return nodes.find(test2);
}
querying.findOneChild = findOneChild;
function findOne(test2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
    var node2 = nodes[i2];
    if (!(0, domhandler_1$1.isTag)(node2)) {
      continue;
    } else if (test2(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne(test2, node2.children, true);
    }
  }
  return elem;
}
querying.findOne = findOne;
function existsOne(test2, nodes) {
  return nodes.some(function(checked2) {
    return (0, domhandler_1$1.isTag)(checked2) && (test2(checked2) || existsOne(test2, checked2.children));
  });
}
querying.existsOne = existsOne;
function findAll(test2, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$1.isTag)(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.findAll = findAll;
var legacy = {};
Object.defineProperty(legacy, "__esModule", { value: true });
legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
var domhandler_1 = lib$3;
var querying_js_1 = querying;
var Checks = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1.isTag;
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && data2(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isText)(elem) && elem.data === data2;
    };
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs(a2, b2) {
  return function(elem) {
    return a2(elem) || b2(elem);
  };
}
function compileTest(options2) {
  var funcs = Object.keys(options2).map(function(key2) {
    var value = options2[key2];
    return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options2, node2) {
  var test2 = compileTest(options2);
  return test2 ? test2(node2) : true;
}
legacy.testElement = testElement;
function getElements(options2, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test2 = compileTest(options2);
  return test2 ? (0, querying_js_1.filter)(test2, nodes, recurse, limit) : [];
}
legacy.getElements = getElements;
function getElementById(id2, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1.findOne)(getAttribCheck("id", id2), nodes, recurse);
}
legacy.getElementById = getElementById;
function getElementsByTagName(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
legacy.getElementsByTagName = getElementsByTagName;
function getElementsByTagType(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}
legacy.getElementsByTagType = getElementsByTagType;
var helpers = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
  var domhandler_12 = lib$3;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports2.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings2 = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports2.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i2, arr) {
      return !arr.includes(node2, i2 + 1);
    });
    nodes.sort(function(a2, b2) {
      var relative = compareDocumentPosition(a2, b2);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports2.uniqueSort = uniqueSort;
})(helpers);
var feeds = {};
Object.defineProperty(feeds, "__esModule", { value: true });
feeds.getFeed = void 0;
var stringify_js_1 = stringify$3;
var legacy_js_1 = legacy;
function getFeed(doc) {
  var feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
feeds.getFeed = getFeed;
function getAtomFeed(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children = item.children;
      var entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  var updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children = item.children;
      var entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  var updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node2) {
  return (0, legacy_js_1.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val2 = fetch(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
  __exportStar(stringify$3, exports2);
  __exportStar(traversal, exports2);
  __exportStar(manipulation, exports2);
  __exportStar(querying, exports2);
  __exportStar(legacy, exports2);
  __exportStar(helpers, exports2);
  __exportStar(feeds, exports2);
  var domhandler_12 = lib$3;
  Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$2);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DomUtils = exports2.parseFeed = exports2.getFeed = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DefaultHandler = exports2.DomHandler = exports2.Parser = void 0;
  var Parser_js_1 = Parser$2;
  var Parser_js_2 = Parser$2;
  Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
    return Parser_js_2.Parser;
  } });
  var domhandler_12 = lib$3;
  var domhandler_2 = lib$3;
  Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  function parseDocument(data2, options2) {
    var handler = new domhandler_12.DomHandler(void 0, options2);
    new Parser_js_1.Parser(handler, options2).end(data2);
    return handler.root;
  }
  exports2.parseDocument = parseDocument;
  function parseDOM(data2, options2) {
    return parseDocument(data2, options2).children;
  }
  exports2.parseDOM = parseDOM;
  function createDomStream(callback, options2, elementCallback) {
    var handler = new domhandler_12.DomHandler(callback, options2, elementCallback);
    return new Parser_js_1.Parser(handler, options2);
  }
  exports2.createDomStream = createDomStream;
  var Tokenizer_js_12 = Tokenizer2;
  Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
    return __importDefault2(Tokenizer_js_12).default;
  } });
  exports2.ElementType = __importStar2(lib$i);
  var domutils_12 = lib$2;
  var domutils_2 = lib$2;
  Object.defineProperty(exports2, "getFeed", { enumerable: true, get: function() {
    return domutils_2.getFeed;
  } });
  var parseFeedDefaultOptions = { xmlMode: true };
  function parseFeed(feed, options2) {
    if (options2 === void 0) {
      options2 = parseFeedDefaultOptions;
    }
    return (0, domutils_12.getFeed)(parseDOM(feed, options2));
  }
  exports2.parseFeed = parseFeed;
  exports2.DomUtils = __importStar2(lib$2);
})(lib$4);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.root = exports2.parseHTML = exports2.merge = exports2.contains = exports2.text = exports2.xml = exports2.html = exports2.load = void 0;
  __exportStar(types$2, exports2);
  var load_js_1 = load;
  var parse_js_12 = parse$5;
  var parse5_adapter_js_1 = parse5Adapter;
  var dom_serializer_12 = __importDefault2(lib$h);
  var htmlparser2_1 = lib$4;
  var parse2 = (0, parse_js_12.getParse)(function(content, options2, isDocument2, context) {
    return options2.xmlMode || options2._useHtmlParser2 ? (0, htmlparser2_1.parseDocument)(content, options2) : (0, parse5_adapter_js_1.parseWithParse5)(content, options2, isDocument2, context);
  });
  exports2.load = (0, load_js_1.getLoad)(parse2, function(dom, options2) {
    return options2.xmlMode || options2._useHtmlParser2 ? (0, dom_serializer_12.default)(dom, options2) : (0, parse5_adapter_js_1.renderWithParse5)(dom);
  });
  exports2.default = (0, exports2.load)([]);
  var static_js_12 = _static;
  Object.defineProperty(exports2, "html", { enumerable: true, get: function() {
    return static_js_12.html;
  } });
  Object.defineProperty(exports2, "xml", { enumerable: true, get: function() {
    return static_js_12.xml;
  } });
  Object.defineProperty(exports2, "text", { enumerable: true, get: function() {
    return static_js_12.text;
  } });
  var staticMethods2 = __importStar2(_static);
  exports2.contains = staticMethods2.contains;
  exports2.merge = staticMethods2.merge;
  exports2.parseHTML = staticMethods2.parseHTML;
  exports2.root = staticMethods2.root;
})(lib$l);
var utils$1 = {};
var lexer = { exports: {} };
var debug = { exports: {} };
(function(module2, exports2) {
  module2.exports = debug2;
  function debug2(label) {
    return _debug.bind(null, label);
  }
  function _debug(label) {
    var args = [].slice.call(arguments, 1);
    args.unshift("[" + label + "]");
    dist.process.stderr.write(args.join(" ") + "\n");
  }
})(debug);
var debugExports = debug.exports;
(function(module2, exports2) {
  debugExports("lex");
  module2.exports = lex;
  function lex(css2) {
    var buffer = "";
    var ch;
    var column = 0;
    var cursor = -1;
    var depth = 0;
    var line = 1;
    var state = "before-selector";
    var stack = [state];
    var token2 = {};
    var tokens = [];
    var atRules = [
      "media",
      "keyframes",
      { name: "-webkit-keyframes", type: "keyframes", prefix: "-webkit-" },
      { name: "-moz-keyframes", type: "keyframes", prefix: "-moz-" },
      { name: "-ms-keyframes", type: "keyframes", prefix: "-ms-" },
      { name: "-o-keyframes", type: "keyframes", prefix: "-o-" },
      "font-face",
      { name: "import", state: "before-at-value" },
      { name: "charset", state: "before-at-value" },
      "supports",
      "viewport",
      { name: "namespace", state: "before-at-value" },
      "document",
      { name: "-moz-document", type: "document", prefix: "-moz-" },
      "page"
    ];
    function getCh() {
      skip();
      return css2[cursor];
    }
    function getState(index2) {
      return index2 ? stack[stack.length - 1 - index2] : state;
    }
    function isNextString(str) {
      var start = cursor + 1;
      return str === css2.slice(start, start + str.length);
    }
    function find2(str) {
      var pos2 = css2.slice(cursor).indexOf(str);
      return pos2 > 0 ? pos2 : false;
    }
    function isNextChar(ch2) {
      return ch2 === peek(1);
    }
    function peek(offset) {
      return css2[cursor + (offset || 1)];
    }
    function popState() {
      var removed = stack.pop();
      state = stack[stack.length - 1];
      return removed;
    }
    function pushState(newState) {
      state = newState;
      stack.push(state);
      return stack.length;
    }
    function replaceState(newState) {
      var previousState = state;
      stack[stack.length - 1] = state = newState;
      return previousState;
    }
    function skip(n2) {
      if ((n2 || 1) == 1) {
        if (css2[cursor] == "\n") {
          line++;
          column = 1;
        } else {
          column++;
        }
        cursor++;
      } else {
        var skipStr = css2.slice(cursor, cursor + n2).split("\n");
        if (skipStr.length > 1) {
          line += skipStr.length - 1;
          column = 1;
        }
        column += skipStr[skipStr.length - 1].length;
        cursor = cursor + n2;
      }
    }
    function addToken() {
      token2.end = {
        line,
        col: column
      };
      tokens.push(token2);
      buffer = "";
      token2 = {};
    }
    function initializeToken(type) {
      token2 = {
        type,
        start: {
          line,
          col: column
        }
      };
    }
    while (ch = getCh()) {
      switch (ch) {
        case " ":
          switch (getState()) {
            case "selector":
            case "value":
            case "value-paren":
            case "at-group":
            case "at-value":
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
          }
          break;
        case "\n":
        case "	":
        case "\r":
        case "\f":
          switch (getState()) {
            case "value":
            case "value-paren":
            case "at-group":
            case "comment":
            case "single-string":
            case "double-string":
            case "selector":
              buffer += ch;
              break;
            case "at-value":
              if ("\n" === ch) {
                token2.value = buffer.trim();
                addToken();
                popState();
              }
              break;
          }
          break;
        case ":":
          switch (getState()) {
            case "name":
              token2.name = buffer.trim();
              buffer = "";
              replaceState("before-value");
              break;
            case "before-selector":
              buffer += ch;
              initializeToken("selector");
              pushState("selector");
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
            default:
              buffer += ch;
              break;
          }
          break;
        case ";":
          switch (getState()) {
            case "name":
            case "before-value":
            case "value":
              if (buffer.trim().length > 0) {
                token2.value = buffer.trim(), addToken();
              }
              replaceState("before-name");
              break;
            case "value-paren":
              buffer += ch;
              break;
            case "at-value":
              token2.value = buffer.trim();
              addToken();
              popState();
              break;
            case "before-name":
              break;
            default:
              buffer += ch;
              break;
          }
          break;
        case "{":
          switch (getState()) {
            case "selector":
              if (peek(-1) === "\\") {
                buffer += ch;
                break;
              }
              token2.text = buffer.trim();
              addToken();
              replaceState("before-name");
              depth = depth + 1;
              break;
            case "at-group":
              token2.name = buffer.trim();
              switch (token2.type) {
                case "font-face":
                case "viewport":
                case "page":
                  pushState("before-name");
                  break;
                default:
                  pushState("before-selector");
              }
              addToken();
              depth = depth + 1;
              break;
            case "name":
            case "at-rule":
              token2.name = buffer.trim();
              addToken();
              pushState("before-name");
              depth = depth + 1;
              break;
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
          }
          break;
        case "}":
          switch (getState()) {
            case "before-name":
            case "name":
            case "before-value":
            case "value":
              if (buffer) {
                token2.value = buffer.trim();
              }
              if (token2.name && token2.value) {
                addToken();
              }
              initializeToken("end");
              addToken();
              popState();
              if ("at-group" === getState()) {
                initializeToken("at-group-end");
                addToken();
                popState();
              }
              if (depth > 0) {
                depth = depth - 1;
              }
              break;
            case "at-group":
            case "before-selector":
            case "selector":
              if (peek(-1) === "\\") {
                buffer += ch;
                break;
              }
              if (depth > 0) {
                if ("at-group" === getState(1)) {
                  initializeToken("at-group-end");
                  addToken();
                }
              }
              if (depth > 1) {
                popState();
              }
              if (depth > 0) {
                depth = depth - 1;
              }
              break;
            case "double-string":
            case "single-string":
            case "comment":
              buffer += ch;
              break;
          }
          break;
        case '"':
        case "'":
          switch (getState()) {
            case "double-string":
              if ('"' === ch && "\\" !== peek(-1)) {
                popState();
              }
              break;
            case "single-string":
              if ("'" === ch && "\\" !== peek(-1)) {
                popState();
              }
              break;
            case "before-at-value":
              replaceState("at-value");
              pushState('"' === ch ? "double-string" : "single-string");
              break;
            case "before-value":
              replaceState("value");
              pushState('"' === ch ? "double-string" : "single-string");
              break;
            case "comment":
              break;
            default:
              if ("\\" !== peek(-1)) {
                pushState('"' === ch ? "double-string" : "single-string");
              }
          }
          buffer += ch;
          break;
        case "/":
          switch (getState()) {
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
            case "before-value":
            case "selector":
            case "name":
            case "value":
              if (isNextChar("*")) {
                var pos = find2("*/");
                if (pos) {
                  skip(pos + 1);
                }
              } else {
                if (getState() == "before-value")
                  replaceState("value");
                buffer += ch;
              }
              break;
            default:
              if (isNextChar("*")) {
                initializeToken("comment");
                pushState("comment");
                skip();
              } else {
                buffer += ch;
              }
              break;
          }
          break;
        case "*":
          switch (getState()) {
            case "comment":
              if (isNextChar("/")) {
                token2.text = buffer;
                skip();
                addToken();
                popState();
              } else {
                buffer += ch;
              }
              break;
            case "before-selector":
              buffer += ch;
              initializeToken("selector");
              pushState("selector");
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
            default:
              buffer += ch;
          }
          break;
        case "@":
          switch (getState()) {
            case "comment":
            case "double-string":
            case "single-string":
              buffer += ch;
              break;
            case "before-value":
              replaceState("value");
              buffer += ch;
              break;
            default:
              var tokenized = false;
              var name2;
              var rule;
              for (var j2 = 0, len = atRules.length; !tokenized && j2 < len; ++j2) {
                rule = atRules[j2];
                name2 = rule.name || rule;
                if (!isNextString(name2)) {
                  continue;
                }
                tokenized = true;
                initializeToken(name2);
                pushState(rule.state || "at-group");
                skip(name2.length);
                if (rule.prefix) {
                  token2.prefix = rule.prefix;
                }
                if (rule.type) {
                  token2.type = rule.type;
                }
              }
              if (!tokenized) {
                buffer += ch;
              }
              break;
          }
          break;
        case "(":
          switch (getState()) {
            case "value":
              pushState("value-paren");
              break;
            case "before-value":
              replaceState("value");
              break;
          }
          buffer += ch;
          break;
        case ")":
          switch (getState()) {
            case "value-paren":
              popState();
              break;
            case "before-value":
              replaceState("value");
              break;
          }
          buffer += ch;
          break;
        default:
          switch (getState()) {
            case "before-selector":
              initializeToken("selector");
              pushState("selector");
              break;
            case "before-name":
              initializeToken("property");
              replaceState("name");
              break;
            case "before-value":
              replaceState("value");
              break;
            case "before-at-value":
              replaceState("at-value");
              break;
          }
          buffer += ch;
          break;
      }
    }
    return tokens;
  }
})(lexer);
var lexerExports = lexer.exports;
var parser$1 = { exports: {} };
(function(module2, exports2) {
  debugExports("parse");
  var lex = lexerExports;
  module2.exports = parse2;
  var _comments;
  var _depth;
  var _position;
  var _tokens;
  function parse2(css2, options2) {
    options2 || (options2 = {});
    _comments = !!options2.comments;
    _position = !!options2.position;
    _depth = 0;
    _tokens = Array.isArray(css2) ? css2.slice() : lex(css2);
    var rule;
    var rules = [];
    var token2;
    while (token2 = next()) {
      rule = parseToken(token2);
      rule && rules.push(rule);
    }
    return {
      type: "stylesheet",
      stylesheet: {
        rules
      }
    };
  }
  function astNode(token2, override) {
    override || (override = {});
    var key2;
    var keys2 = ["type", "name", "value"];
    var node2 = {};
    for (var i2 = 0; i2 < keys2.length; ++i2) {
      key2 = keys2[i2];
      if (token2[key2]) {
        node2[key2] = override[key2] || token2[key2];
      }
    }
    keys2 = Object.keys(override);
    for (i2 = 0; i2 < keys2.length; ++i2) {
      key2 = keys2[i2];
      if (!node2[key2]) {
        node2[key2] = override[key2];
      }
    }
    if (_position) {
      node2.position = {
        start: token2.start,
        end: token2.end
      };
    }
    return node2;
  }
  function next() {
    var token2 = _tokens.shift();
    return token2;
  }
  function parseAtGroup(token2) {
    _depth = _depth + 1;
    var overrides = {};
    switch (token2.type) {
      case "font-face":
      case "viewport":
        overrides.declarations = parseDeclarations();
        break;
      case "page":
        overrides.prefix = token2.prefix;
        overrides.declarations = parseDeclarations();
        break;
      default:
        overrides.prefix = token2.prefix;
        overrides.rules = parseRules();
    }
    return astNode(token2, overrides);
  }
  function parseAtImport(token2) {
    return astNode(token2);
  }
  function parseCharset(token2) {
    return astNode(token2);
  }
  function parseComment(token2) {
    return astNode(token2, { text: token2.text });
  }
  function parseNamespace(token2) {
    return astNode(token2);
  }
  function parseProperty(token2) {
    return astNode(token2);
  }
  function parseSelector2(token2) {
    function trim(str) {
      return str.trim();
    }
    return astNode(token2, {
      type: "rule",
      selectors: token2.text.split(",").map(trim),
      declarations: parseDeclarations()
    });
  }
  function parseToken(token2) {
    switch (token2.type) {
      case "property":
        return parseProperty(token2);
      case "selector":
        return parseSelector2(token2);
      case "at-group-end":
        _depth = _depth - 1;
        return;
      case "media":
      case "keyframes":
        return parseAtGroup(token2);
      case "comment":
        if (_comments) {
          return parseComment(token2);
        }
        break;
      case "charset":
        return parseCharset(token2);
      case "import":
        return parseAtImport(token2);
      case "namespace":
        return parseNamespace(token2);
      case "font-face":
      case "supports":
      case "viewport":
      case "document":
      case "page":
        return parseAtGroup(token2);
    }
  }
  function parseTokensWhile(conditionFn) {
    var node2;
    var nodes = [];
    var token2;
    while ((token2 = next()) && (conditionFn && conditionFn(token2))) {
      node2 = parseToken(token2);
      node2 && nodes.push(node2);
    }
    if (token2 && token2.type !== "end") {
      _tokens.unshift(token2);
    }
    return nodes;
  }
  function parseDeclarations() {
    return parseTokensWhile(function(token2) {
      return token2.type === "property" || token2.type === "comment";
    });
  }
  function parseRules() {
    return parseTokensWhile(function() {
      return _depth;
    });
  }
})(parser$1);
var parserExports = parser$1.exports;
var stringify$2 = { exports: {} };
(function(module2, exports2) {
  debugExports("stringify");
  var _comments;
  var _compress;
  var _indentation;
  var _level;
  var _n;
  var _s;
  module2.exports = stringify2;
  function stringify2(ast, options2) {
    options2 || (options2 = {});
    _indentation = options2.indentation || "";
    _compress = !!options2.compress;
    _comments = !!options2.comments;
    _level = 1;
    if (_compress) {
      _n = _s = "";
    } else {
      _n = "\n";
      _s = " ";
    }
    var css2 = reduce(ast.stylesheet.rules, stringifyNode).join("\n").trim();
    return css2;
  }
  function indent(level) {
    if (level) {
      _level += level;
      return;
    }
    if (_compress) {
      return "";
    }
    return Array(_level).join(_indentation || "");
  }
  function stringifyAtRule(node2) {
    return "@" + node2.type + " " + node2.value + ";" + _n;
  }
  function stringifyAtGroup(node2) {
    var label = "";
    var prefix = node2.prefix || "";
    if (node2.name) {
      label = " " + node2.name;
    }
    var chomp = node2.type !== "page";
    return "@" + prefix + node2.type + label + _s + stringifyBlock(node2, chomp) + _n;
  }
  function stringifyComment(node2) {
    if (!_comments) {
      return "";
    }
    return "/*" + (node2.text || "") + "*/" + _n;
  }
  function stringifyRule(node2) {
    var label;
    if (node2.selectors) {
      label = node2.selectors.join("," + _n);
    } else {
      label = "@" + node2.type;
      label += node2.name ? " " + node2.name : "";
    }
    return indent() + label + _s + stringifyBlock(node2) + _n;
  }
  function reduce(items, fn) {
    return items.reduce(function(results, item) {
      var result = item.type === "comment" ? stringifyComment(item) : fn(item);
      result && results.push(result);
      return results;
    }, []);
  }
  function stringifyBlock(node2, chomp) {
    var children = node2.declarations;
    var fn = stringifyDeclaration;
    if (node2.rules) {
      children = node2.rules;
      fn = stringifyRule;
    }
    children = stringifyChildren(children, fn);
    children && (children = _n + children + (chomp ? "" : _n));
    return "{" + children + indent() + "}";
  }
  function stringifyChildren(children, fn) {
    if (!children) {
      return "";
    }
    indent(1);
    var results = reduce(children, fn);
    indent(-1);
    if (!results.length) {
      return "";
    }
    return results.join(_n);
  }
  function stringifyDeclaration(node2) {
    if (node2.type === "property") {
      return stringifyProperty(node2);
    }
  }
  function stringifyNode(node2) {
    switch (node2.type) {
      case "rule":
        return stringifyRule(node2);
      case "media":
      case "keyframes":
        return stringifyAtGroup(node2);
      case "comment":
        return stringifyComment(node2);
      case "import":
      case "charset":
      case "namespace":
        return stringifyAtRule(node2);
      case "font-face":
      case "supports":
      case "viewport":
      case "document":
      case "page":
        return stringifyAtGroup(node2);
    }
  }
  function stringifyProperty(node2) {
    var name2 = node2.name ? node2.name + ":" + _s : "";
    return indent() + name2 + node2.value + ";";
  }
})(stringify$2);
var stringifyExports = stringify$2.exports;
var mensch = {
  lex: lexerExports,
  parse: parserExports,
  stringify: stringifyExports
};
var selector = { exports: {} };
var escapeRe = /([-.*+?^${}()|[\]\/\\])/g, unescapeRe = /\\/g;
var escape = function(string) {
  return (string + "").replace(escapeRe, "\\$1");
};
var unescape = function(string) {
  return (string + "").replace(unescapeRe, "");
};
var slickRe = RegExp(
  /*
  #!/usr/bin/env ruby
  puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
  __END__
      "(?x)^(?:\
        \\s* ( , ) \\s*               # Separator          \n\
      | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
      |      ( \\s+ )                 # CombinatorChildren \n\
      |      ( <unicode>+ | \\* )     # Tag                \n\
      | \\#  ( <unicode>+       )     # ID                 \n\
      | \\.  ( <unicode>+       )     # ClassName          \n\
      |                               # Attribute          \n\
      \\[  \
          \\s* (<unicode1>+)  (?:  \
              \\s* ([*^$!~|]?=)  (?:  \
                  \\s* (?:\
                      ([\"']?)(.*?)\\9 \
                  )\
              )  \
          )?  \\s*  \
      \\](?!\\]) \n\
      |   :+ ( <unicode>+ )(?:\
      \\( (?:\
          (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
      ) \\)\
      )?\
      )"
  */
  `^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:(["']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:(["'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)`.replace(/<combinator>/, "[" + escape(">+~`!@$%^&={}\\;</") + "]").replace(/<unicode>/g, "(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])").replace(/<unicode1>/g, "(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])")
);
var Part = function Part2(combinator) {
  this.combinator = combinator || " ";
  this.tag = "*";
};
Part.prototype.toString = function() {
  if (!this.raw) {
    var xpr = "", k2, part;
    xpr += this.tag || "*";
    if (this.id)
      xpr += "#" + this.id;
    if (this.classes)
      xpr += "." + this.classList.join(".");
    if (this.attributes)
      for (k2 = 0; part = this.attributes[k2++]; ) {
        xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : "") + "]";
      }
    if (this.pseudos)
      for (k2 = 0; part = this.pseudos[k2++]; ) {
        xpr += ":" + part.name;
        if (part.value)
          xpr += "(" + part.value + ")";
      }
    this.raw = xpr;
  }
  return this.raw;
};
var Expression = function Expression2() {
  this.length = 0;
};
Expression.prototype.toString = function() {
  if (!this.raw) {
    var xpr = "";
    for (var j2 = 0, bit; bit = this[j2++]; ) {
      if (j2 !== 1)
        xpr += " ";
      if (bit.combinator !== " ")
        xpr += bit.combinator + " ";
      xpr += bit;
    }
    this.raw = xpr;
  }
  return this.raw;
};
var replacer = function(rawMatch, separator, combinator, combinatorChildren, tagName, id2, className2, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {
  var expression, current;
  if (separator || !this.length) {
    expression = this[this.length++] = new Expression();
    if (separator)
      return "";
  }
  if (!expression)
    expression = this[this.length - 1];
  if (combinator || combinatorChildren || !expression.length) {
    current = expression[expression.length++] = new Part(combinator);
  }
  if (!current)
    current = expression[expression.length - 1];
  if (tagName) {
    current.tag = unescape(tagName);
  } else if (id2) {
    current.id = unescape(id2);
  } else if (className2) {
    var unescaped = unescape(className2);
    var classes = current.classes || (current.classes = {});
    if (!classes[unescaped]) {
      classes[unescaped] = escape(className2);
      var classList = current.classList || (current.classList = []);
      classList.push(unescaped);
      classList.sort();
    }
  } else if (pseudoClass) {
    pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
    (current.pseudos || (current.pseudos = [])).push({
      type: pseudoMarker.length == 1 ? "class" : "element",
      name: unescape(pseudoClass),
      escapedName: escape(pseudoClass),
      value: pseudoClassValue ? unescape(pseudoClassValue) : null,
      escapedValue: pseudoClassValue ? escape(pseudoClassValue) : null
    });
  } else if (attributeKey) {
    attributeValue = attributeValue ? escape(attributeValue) : null;
    (current.attributes || (current.attributes = [])).push({
      operator: attributeOperator,
      name: unescape(attributeKey),
      escapedName: escape(attributeKey),
      value: attributeValue ? unescape(attributeValue) : null,
      escapedValue: attributeValue ? escape(attributeValue) : null
    });
  }
  return "";
};
var Expressions = function Expressions2(expression) {
  this.length = 0;
  var self2 = this;
  var original = expression, replaced;
  while (expression) {
    replaced = expression.replace(slickRe, function() {
      return replacer.apply(self2, arguments);
    });
    if (replaced === expression)
      throw new Error(original + " is an invalid expression");
    expression = replaced;
  }
};
Expressions.prototype.toString = function() {
  if (!this.raw) {
    var expressions = [];
    for (var i2 = 0, expression; expression = this[i2++]; )
      expressions.push(expression);
    this.raw = expressions.join(", ");
  }
  return this.raw;
};
var cache$1 = {};
var parse$3 = function(expression) {
  if (expression == null)
    return null;
  expression = ("" + expression).replace(/^\s+|\s+$/g, "");
  return cache$1[expression] || (cache$1[expression] = new Expressions(expression));
};
var parser = parse$3;
(function(module2, exports2) {
  var parser$12 = parser;
  module2.exports = Selector;
  function Selector(text2, styleAttribute) {
    this.text = text2;
    this.spec = void 0;
    this.styleAttribute = styleAttribute || false;
  }
  Selector.prototype.parsed = function() {
    if (!this.tokens) {
      this.tokens = parse2(this.text);
    }
    return this.tokens;
  };
  Selector.prototype.specificity = function() {
    var styleAttribute = this.styleAttribute;
    if (!this.spec) {
      this.spec = specificity(this.text, this.parsed());
    }
    return this.spec;
    function specificity(text2, parsed) {
      var expressions = parsed || parse2(text2);
      var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
      var nots = [];
      for (var i2 = 0; i2 < expressions.length; i2++) {
        var expression = expressions[i2];
        var pseudos2 = expression.pseudos;
        if (expression.id) {
          spec[1]++;
        }
        if (expression.attributes) {
          spec[2] += expression.attributes.length;
        }
        if (expression.classList) {
          spec[2] += expression.classList.length;
        }
        if (expression.tag && expression.tag !== "*") {
          spec[3]++;
        }
        if (pseudos2) {
          spec[3] += pseudos2.length;
          for (var p2 = 0; p2 < pseudos2.length; p2++) {
            if (pseudos2[p2].name === "not") {
              nots.push(pseudos2[p2].value);
              spec[3]--;
            }
          }
        }
      }
      for (var ii = nots.length; ii--; ) {
        var not2 = specificity(nots[ii]);
        for (var jj = 4; jj--; ) {
          spec[jj] += not2[jj];
        }
      }
      return spec;
    }
  };
  function parse2(text2) {
    try {
      return parser$12(text2)[0];
    } catch (e2) {
      return [];
    }
  }
})(selector);
var selectorExports = selector.exports;
var property = { exports: {} };
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty)
    return property.exports;
  hasRequiredProperty = 1;
  (function(module2, exports2) {
    module2.exports = Property;
    var utils2 = requireUtils();
    function Property(prop2, value, selector2, priority, additionalPriority) {
      this.prop = prop2;
      this.value = value;
      this.selector = selector2;
      this.priority = priority || 0;
      this.additionalPriority = additionalPriority || [];
    }
    Property.prototype.compareFunc = function(property2) {
      var a2 = [];
      a2.push.apply(a2, this.selector.specificity());
      a2.push.apply(a2, this.additionalPriority);
      a2[0] += this.priority;
      var b2 = [];
      b2.push.apply(b2, property2.selector.specificity());
      b2.push.apply(b2, property2.additionalPriority);
      b2[0] += property2.priority;
      return utils2.compareFunc(a2, b2);
    };
    Property.prototype.compare = function(property2) {
      var winner = this.compareFunc(property2);
      if (winner === 1) {
        return this;
      }
      return property2;
    };
    Property.prototype.toString = function() {
      return this.prop + ": " + this.value.replace(/['"]+/g, "") + ";";
    };
  })(property);
  return property.exports;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$1;
  hasRequiredUtils = 1;
  (function(exports2) {
    var mensch$1 = mensch;
    var Selector = selectorExports;
    var Property = requireProperty();
    exports2.Selector = Selector;
    exports2.Property = Property;
    /**
     * Returns an array of the selectors.
     *
     * @license Sizzle CSS Selector Engine - MIT
     * @param {String} selectorText from mensch
     * @api public
     */
    exports2.extract = function extract(selectorText) {
      var attr2 = 0;
      var sels = [];
      var sel = "";
      for (var i2 = 0, l2 = selectorText.length; i2 < l2; i2++) {
        var c2 = selectorText.charAt(i2);
        if (attr2) {
          if ("]" === c2 || ")" === c2) {
            attr2--;
          }
          sel += c2;
        } else {
          if ("," === c2) {
            sels.push(sel);
            sel = "";
          } else {
            if ("[" === c2 || "(" === c2) {
              attr2++;
            }
            if (sel.length || c2 !== "," && c2 !== "\n" && c2 !== " ") {
              sel += c2;
            }
          }
        }
      }
      if (sel.length) {
        sels.push(sel);
      }
      return sels;
    };
    exports2.parseCSS = function(css2) {
      var parsed = mensch$1.parse(css2, { position: true, comments: true });
      var rules = typeof parsed.stylesheet != "undefined" && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
      var ret = [];
      for (var i2 = 0, l2 = rules.length; i2 < l2; i2++) {
        if (rules[i2].type == "rule") {
          var rule = rules[i2];
          var selectors = rule.selectors;
          for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
            ret.push([selectors[ii], rule.declarations]);
          }
        }
      }
      return ret;
    };
    exports2.getPreservedText = function(css2, options2, ignoredPseudos) {
      var parsed = mensch$1.parse(css2, { position: true, comments: true });
      var rules = typeof parsed.stylesheet != "undefined" && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
      var preserved = [];
      for (var i2 = rules.length - 1; i2 >= 0; i2--) {
        if (options2.fontFaces && rules[i2].type === "font-face" || options2.mediaQueries && rules[i2].type === "media" || options2.keyFrames && rules[i2].type === "keyframes" || options2.pseudos && rules[i2].selectors && this.matchesPseudo(rules[i2].selectors[0], ignoredPseudos)) {
          preserved.unshift(
            mensch$1.stringify(
              { stylesheet: { rules: [rules[i2]] } },
              { comments: false, indentation: "  " }
            )
          );
        }
        rules[i2].position.start;
      }
      if (preserved.length === 0) {
        return false;
      }
      return "\n" + preserved.join("\n") + "\n";
    };
    exports2.normalizeLineEndings = function(text2) {
      return text2.replace(/\r\n/g, "\n").replace(/\n/g, "\r\n");
    };
    exports2.matchesPseudo = function(needle, haystack) {
      return haystack.find(function(element2) {
        return needle.indexOf(element2) > -1;
      });
    };
    exports2.compareFunc = function(a2, b2) {
      var min = Math.min(a2.length, b2.length);
      for (var i2 = 0; i2 < min; i2++) {
        if (a2[i2] === b2[i2]) {
          continue;
        }
        if (a2[i2] > b2[i2]) {
          return 1;
        }
        return -1;
      }
      return a2.length - b2.length;
    };
    exports2.compare = function(a2, b2) {
      return exports2.compareFunc(a2, b2) == 1 ? a2 : b2;
    };
    exports2.getDefaultOptions = function(options2) {
      var result = Object.assign({
        extraCss: "",
        insertPreservedExtraCss: true,
        applyStyleTags: true,
        removeStyleTags: true,
        preserveMediaQueries: true,
        preserveFontFaces: true,
        preserveKeyFrames: true,
        preservePseudos: true,
        applyWidthAttributes: true,
        applyHeightAttributes: true,
        applyAttributesTableElements: true,
        url: ""
      }, options2);
      result.webResources = result.webResources || {};
      return result;
    };
  })(utils$1);
  return utils$1;
}
(function(module2) {
  var cheerio2 = lib$l;
  requireUtils();
  var cheerioLoad = function(html2, options2, encodeEntities) {
    options2 = Object.assign({ decodeEntities: false, _useHtmlParser2: true }, options2);
    html2 = encodeEntities(html2);
    return cheerio2.load(html2, options2);
  };
  var createEntityConverters = function() {
    var codeBlockLookup = [];
    var encodeCodeBlocks = function(html2) {
      var blocks = module2.exports.codeBlocks;
      Object.keys(blocks).forEach(function(key2) {
        var re2 = new RegExp(blocks[key2].start + "([\\S\\s]*?)" + blocks[key2].end, "g");
        html2 = html2.replace(re2, function(match, subMatch) {
          codeBlockLookup.push(match);
          return "JUICE_CODE_BLOCK_" + (codeBlockLookup.length - 1) + "_";
        });
      });
      return html2;
    };
    var decodeCodeBlocks = function(html2) {
      for (var index2 = 0; index2 < codeBlockLookup.length; index2++) {
        var re2 = new RegExp("JUICE_CODE_BLOCK_" + index2 + '_(="")?', "gi");
        html2 = html2.replace(re2, function() {
          return codeBlockLookup[index2];
        });
      }
      return html2;
    };
    return {
      encodeEntities: encodeCodeBlocks,
      decodeEntities: decodeCodeBlocks
    };
  };
  module2.exports = function(html2, options2, callback, callbackExtraArguments) {
    var entityConverters = createEntityConverters();
    var $2 = cheerioLoad(html2, options2, entityConverters.encodeEntities);
    var args = [$2];
    args.push.apply(args, callbackExtraArguments);
    var doc = callback.apply(void 0, args) || $2;
    if (options2 && options2.xmlMode) {
      return entityConverters.decodeEntities(doc.xml());
    }
    return entityConverters.decodeEntities(doc.html());
  };
  module2.exports.codeBlocks = {
    EJS: { start: "<%", end: "%>" },
    HBS: { start: "{{", end: "}}" }
  };
})(cheerio$2);
var cheerioExports = cheerio$2.exports;
var numbers$1 = {};
numbers$1.romanize = function(num) {
  if (isNaN(num))
    return NaN;
  var digits = String(+num).split(""), key2 = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
  ], roman = "", i2 = 3;
  while (i2--)
    roman = (key2[+digits.pop() + i2 * 10] || "") + roman;
  return Array(+digits.join("") + 1).join("M") + roman;
};
numbers$1.alphanumeric = function(num) {
  var s2 = "", t2;
  while (num > 0) {
    t2 = (num - 1) % 26;
    s2 = String.fromCharCode(65 + t2) + s2;
    num = (num - t2) / 26 | 0;
  }
  return s2 || void 0;
};
var utils = requireUtils();
var numbers = numbers$1;
var inline = function makeJuiceClient(juiceClient2) {
  juiceClient2.ignoredPseudos = ["hover", "active", "focus", "visited", "link"];
  juiceClient2.widthElements = ["TABLE", "TD", "TH", "IMG"];
  juiceClient2.heightElements = ["TABLE", "TD", "TH", "IMG"];
  juiceClient2.tableElements = ["TABLE", "TH", "TR", "TD", "CAPTION", "COLGROUP", "COL", "THEAD", "TBODY", "TFOOT"];
  juiceClient2.nonVisualElements = ["HEAD", "TITLE", "BASE", "LINK", "STYLE", "META", "SCRIPT", "NOSCRIPT"];
  juiceClient2.styleToAttribute = {
    "background-color": "bgcolor",
    "background-image": "background",
    "text-align": "align",
    "vertical-align": "valign"
  };
  juiceClient2.excludedProperties = [];
  juiceClient2.juiceDocument = juiceDocument2;
  juiceClient2.inlineDocument = inlineDocument;
  function inlineDocument($2, css2, options2) {
    options2 = options2 || {};
    var rules = utils.parseCSS(css2);
    var editedElements = [];
    var styleAttributeName = "style";
    var counters = {};
    if (options2.styleAttributeName) {
      styleAttributeName = options2.styleAttributeName;
    }
    rules.forEach(handleRule);
    editedElements.forEach(setStyleAttrs);
    if (options2.inlinePseudoElements) {
      editedElements.forEach(inlinePseudoElements);
    }
    if (options2.applyWidthAttributes) {
      editedElements.forEach(function(el) {
        setDimensionAttrs(el, "width");
      });
    }
    if (options2.applyHeightAttributes) {
      editedElements.forEach(function(el) {
        setDimensionAttrs(el, "height");
      });
    }
    if (options2.applyAttributesTableElements) {
      editedElements.forEach(setAttributesOnTableElements);
    }
    if (options2.insertPreservedExtraCss && options2.extraCss) {
      var preservedText = utils.getPreservedText(options2.extraCss, {
        mediaQueries: options2.preserveMediaQueries,
        fontFaces: options2.preserveFontFaces,
        keyFrames: options2.preserveKeyFrames
      });
      if (preservedText) {
        var $appendTo = null;
        if (options2.insertPreservedExtraCss !== true) {
          $appendTo = $2(options2.insertPreservedExtraCss);
        } else {
          $appendTo = $2("head");
          if (!$appendTo.length) {
            $appendTo = $2("body");
          }
          if (!$appendTo.length) {
            $appendTo = $2.root();
          }
        }
        $appendTo.first().append("<style>" + preservedText + "</style>");
      }
    }
    function handleRule(rule) {
      var sel = rule[0];
      var style2 = rule[1];
      var selector2 = new utils.Selector(sel);
      var parsedSelector = selector2.parsed();
      if (!parsedSelector) {
        return;
      }
      var pseudoElementType = getPseudoElementType(parsedSelector);
      for (var i2 = 0; i2 < parsedSelector.length; ++i2) {
        var subSel = parsedSelector[i2];
        if (subSel.pseudos) {
          for (var j2 = 0; j2 < subSel.pseudos.length; ++j2) {
            var subSelPseudo = subSel.pseudos[j2];
            if (juiceClient2.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
              return;
            }
          }
        }
      }
      if (pseudoElementType) {
        var last2 = parsedSelector[parsedSelector.length - 1];
        var pseudos2 = last2.pseudos;
        last2.pseudos = filterElementPseudos(last2.pseudos);
        sel = parsedSelector.toString();
        last2.pseudos = pseudos2;
      }
      var els;
      try {
        els = $2(sel);
      } catch (err) {
        return;
      }
      els.each(function() {
        var el = this;
        if (el.name && juiceClient2.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
          return;
        }
        if (!el.counterProps) {
          el.counterProps = el.parent && el.parent.counterProps ? Object.create(el.parent.counterProps) : {};
        }
        if (pseudoElementType) {
          var pseudoElPropName = "pseudo" + pseudoElementType;
          var pseudoEl = el[pseudoElPropName];
          if (!pseudoEl) {
            pseudoEl = el[pseudoElPropName] = $2("<span />").get(0);
            pseudoEl.pseudoElementType = pseudoElementType;
            pseudoEl.pseudoElementParent = el;
            pseudoEl.counterProps = el.counterProps;
            el[pseudoElPropName] = pseudoEl;
          }
          el = pseudoEl;
        }
        if (!el.styleProps) {
          el.styleProps = {};
          if ($2(el).attr(styleAttributeName)) {
            var cssText = "* { " + $2(el).attr(styleAttributeName) + " } ";
            addProps(utils.parseCSS(cssText)[0][1], new utils.Selector("<style>", true));
          }
          editedElements.push(el);
        }
        function resetCounter(el2, value) {
          var tokens = value.split(/\s+/);
          for (var j3 = 0; j3 < tokens.length; j3++) {
            var counter = tokens[j3];
            var resetval = parseInt(tokens[j3 + 1], 10);
            isNaN(resetval) ? el2.counterProps[counter] = counters[counter] = 0 : el2.counterProps[counter] = counters[tokens[j3++]] = resetval;
          }
        }
        function incrementCounter(el2, value) {
          var tokens = value.split(/\s+/);
          for (var j3 = 0; j3 < tokens.length; j3++) {
            var counter = tokens[j3];
            if (el2.counterProps[counter] === void 0) {
              continue;
            }
            var incrval = parseInt(tokens[j3 + 1], 10);
            isNaN(incrval) ? el2.counterProps[counter] = counters[counter] += 1 : el2.counterProps[counter] = counters[tokens[j3++]] += incrval;
          }
        }
        function addProps(style3, selector3) {
          for (var i3 = 0, l2 = style3.length; i3 < l2; i3++) {
            if (style3[i3].type == "property") {
              var name2 = style3[i3].name;
              var value = style3[i3].value;
              if (name2 === "counter-reset") {
                resetCounter(el, value);
              }
              if (name2 === "counter-increment") {
                incrementCounter(el, value);
              }
              var important = value.match(/!important$/) !== null;
              if (important && !options2.preserveImportant)
                value = removeImportant(value);
              var additionalPriority = [style3[i3].position.start.line, style3[i3].position.start.col];
              var prop2 = new utils.Property(name2, value, selector3, important ? 2 : 0, additionalPriority);
              var existing = el.styleProps[name2];
              if (juiceClient2.excludedProperties.indexOf(name2) < 0) {
                if (existing && existing.compare(prop2) === prop2 || !existing) {
                  if (existing && existing.selector !== selector3) {
                    delete el.styleProps[name2];
                  } else if (existing) {
                    prop2.nextProp = existing;
                  }
                  el.styleProps[name2] = prop2;
                }
              }
            }
          }
        }
        addProps(style2, selector2);
      });
    }
    function setStyleAttrs(el) {
      Object.keys(el.styleProps).length;
      var props = [];
      Object.keys(el.styleProps).forEach(function(key2) {
        var np = el.styleProps[key2];
        while (typeof np !== "undefined") {
          props.push(np);
          np = np.nextProp;
        }
      });
      props.sort(function(a2, b2) {
        return a2.compareFunc(b2);
      });
      var string = props.filter(function(prop2) {
        return prop2.prop !== "content";
      }).map(function(prop2) {
        return prop2.prop + ": " + prop2.value.replace(/["]/g, "'") + ";";
      }).join(" ");
      if (string) {
        $2(el).attr(styleAttributeName, string);
      }
    }
    function inlinePseudoElements(el) {
      if (el.pseudoElementType && el.styleProps.content) {
        var parsed = parseContent(el);
        if (parsed.img) {
          el.name = "img";
          $2(el).attr("src", parsed.img);
        } else {
          $2(el).text(parsed);
        }
        var parent = el.pseudoElementParent;
        if (el.pseudoElementType === "before") {
          $2(parent).prepend(el);
        } else {
          $2(parent).append(el);
        }
      }
    }
    function setDimensionAttrs(el, dimension) {
      if (!el.name) {
        return;
      }
      var elName = el.name.toUpperCase();
      if (juiceClient2[dimension + "Elements"].indexOf(elName) > -1) {
        for (var i2 in el.styleProps) {
          if (el.styleProps[i2].prop === dimension) {
            var value = el.styleProps[i2].value;
            if (options2.preserveImportant) {
              value = removeImportant(value);
            }
            if (value.match(/(px|auto)/)) {
              var size = value.replace("px", "");
              $2(el).attr(dimension, size);
              return;
            }
            if (juiceClient2.tableElements.indexOf(elName) > -1 && value.match(/\%/)) {
              $2(el).attr(dimension, value);
              return;
            }
          }
        }
      }
    }
    function extractBackgroundUrl(value) {
      return value.indexOf("url(") !== 0 ? value : value.replace(/^url\((["'])?([^"']+)\1\)$/, "$2");
    }
    function setAttributesOnTableElements(el) {
      if (!el.name) {
        return;
      }
      var elName = el.name.toUpperCase();
      var styleProps = Object.keys(juiceClient2.styleToAttribute);
      if (juiceClient2.tableElements.indexOf(elName) > -1) {
        for (var i2 in el.styleProps) {
          if (styleProps.indexOf(el.styleProps[i2].prop) > -1) {
            var prop2 = juiceClient2.styleToAttribute[el.styleProps[i2].prop];
            var value = el.styleProps[i2].value;
            if (options2.preserveImportant) {
              value = removeImportant(value);
            }
            if (prop2 === "background") {
              value = extractBackgroundUrl(value);
            }
            if (/(linear|radial)-gradient\(/i.test(value)) {
              continue;
            }
            $2(el).attr(prop2, value);
          }
        }
      }
    }
  }
  function removeImportant(value) {
    return value.replace(/\s*!important$/, "");
  }
  function findVariableValue(el, variable) {
    while (el) {
      if (variable in el.styleProps) {
        return el.styleProps[variable].value;
      }
      var el = el.pseudoElementParent || el.parent;
    }
  }
  function applyCounterStyle(counter, style2) {
    switch (style2) {
      case "lower-roman":
        return numbers.romanize(counter).toLowerCase();
      case "upper-roman":
        return numbers.romanize(counter);
      case "lower-latin":
      case "lower-alpha":
        return numbers.alphanumeric(counter).toLowerCase();
      case "upper-latin":
      case "upper-alpha":
        return numbers.alphanumeric(counter);
      default:
        return counter.toString();
    }
  }
  function parseContent(el) {
    var content = el.styleProps.content.value;
    if (content === "none" || content === "normal") {
      return "";
    }
    var imageUrlMatch = content.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);
    if (imageUrlMatch) {
      var url = imageUrlMatch[1].replace(/^['"]|['"]$/g, "");
      return { img: url };
    }
    var parsed = [];
    var tokens = content.split(/['"]/);
    for (var i2 = 0; i2 < tokens.length; i2++) {
      if (tokens[i2] === "")
        continue;
      var varMatch = tokens[i2].match(/var\s*\(\s*(.*?)\s*(,\s*(.*?)\s*)?\s*\)/i);
      if (varMatch) {
        var variable = findVariableValue(el, varMatch[1]) || varMatch[2];
        parsed.push(variable.replace(/^['"]|['"]$/g, ""));
        continue;
      }
      var counterMatch = tokens[i2].match(/counter\s*\(\s*(.*?)\s*(,\s*(.*?)\s*)?\s*\)/i);
      if (counterMatch && counterMatch[1] in el.counterProps) {
        var counter = el.counterProps[counterMatch[1]];
        parsed.push(applyCounterStyle(counter, counterMatch[3]));
        continue;
      }
      var attrMatch = tokens[i2].match(/attr\s*\(\s*(.*?)\s*\)/i);
      if (attrMatch) {
        var attr2 = attrMatch[1];
        parsed.push(
          el.pseudoElementParent ? el.pseudoElementParent.attribs[attr2] : el.attribs[attr2]
        );
        continue;
      }
      parsed.push(tokens[i2]);
    }
    content = parsed.join("");
    content = content.replace(/\\/g, "");
    return content;
  }
  function getPseudoElementType(selector2) {
    if (selector2.length === 0) {
      return;
    }
    var pseudos2 = selector2[selector2.length - 1].pseudos;
    if (!pseudos2) {
      return;
    }
    for (var i2 = 0; i2 < pseudos2.length; i2++) {
      if (isPseudoElementName(pseudos2[i2])) {
        return pseudos2[i2].name;
      }
    }
  }
  function isPseudoElementName(pseudo2) {
    return pseudo2.name === "before" || pseudo2.name === "after";
  }
  function filterElementPseudos(pseudos2) {
    return pseudos2.filter(function(pseudo2) {
      return !isPseudoElementName(pseudo2);
    });
  }
  function juiceDocument2($2, options2) {
    options2 = utils.getDefaultOptions(options2);
    var css2 = extractCssFromDocument($2, options2);
    css2 += "\n" + options2.extraCss;
    inlineDocument($2, css2, options2);
    return $2;
  }
  function getStylesData($2, options2) {
    var results = [];
    var stylesList = $2("style");
    var styleDataList, styleData, styleElement;
    stylesList.each(function() {
      styleElement = this;
      var usingParse5 = !!styleElement.childNodes;
      styleDataList = usingParse5 ? styleElement.childNodes : styleElement.children;
      if (styleDataList.length !== 1) {
        if (options2.removeStyleTags) {
          $2(styleElement).remove();
        }
        return;
      }
      styleData = styleDataList[0].data;
      if (options2.applyStyleTags && $2(styleElement).attr("data-embed") === void 0) {
        results.push(styleData);
      }
      if (options2.removeStyleTags && $2(styleElement).attr("data-embed") === void 0) {
        var text2 = usingParse5 ? styleElement.childNodes[0].nodeValue : styleElement.children[0].data;
        var preservedText = utils.getPreservedText(text2, {
          mediaQueries: options2.preserveMediaQueries,
          fontFaces: options2.preserveFontFaces,
          keyFrames: options2.preserveKeyFrames,
          pseudos: options2.preservePseudos
        }, juiceClient2.ignoredPseudos);
        if (preservedText) {
          if (usingParse5) {
            styleElement.childNodes[0].nodeValue = preservedText;
          } else {
            styleElement.children[0].data = preservedText;
          }
        } else {
          $2(styleElement).remove();
        }
      }
      $2(styleElement).removeAttr("data-embed");
    });
    return results;
  }
  function extractCssFromDocument($2, options2) {
    var results = getStylesData($2, options2);
    var css2 = results.join("\n");
    return css2;
  }
  return juiceClient2;
};
var cheerio = cheerioExports;
var makeJuiceClient2 = inline;
var juiceClient = makeJuiceClient2(function(html2, options2) {
  return cheerio(html2, { xmlMode: options2 && options2.xmlMode }, juiceDocument, [options2]);
});
var juiceDocument = function(html2, options2) {
  return juiceClient.juiceDocument(html2, options2);
};
juiceClient.inlineContent = function(html2, css2, options2) {
  return cheerio(html2, { xmlMode: options2 && options2.xmlMode }, juiceClient.inlineDocument, [css2, options2]);
};
juiceClient.codeBlocks = cheerio.codeBlocks;
var client = juiceClient;
const juice = /* @__PURE__ */ getDefaultExportFromCjs(client);
var browser = {};
browser.endianness = function() {
  return "LE";
};
browser.hostname = function() {
  if (typeof location !== "undefined") {
    return location.hostname;
  } else
    return "";
};
browser.loadavg = function() {
  return [];
};
browser.uptime = function() {
  return 0;
};
browser.freemem = function() {
  return Number.MAX_VALUE;
};
browser.totalmem = function() {
  return Number.MAX_VALUE;
};
browser.cpus = function() {
  return [];
};
browser.type = function() {
  return "Browser";
};
browser.release = function() {
  if (typeof navigator !== "undefined") {
    return navigator.appVersion;
  }
  return "";
};
browser.networkInterfaces = browser.getNetworkInterfaces = function() {
  return {};
};
browser.arch = function() {
  return "javascript";
};
browser.platform = function() {
  return "browser";
};
browser.tmpdir = browser.tmpDir = function() {
  return "/tmp";
};
browser.EOL = "\n";
browser.homedir = function() {
  return "/";
};
var pathBrowserify;
var hasRequiredPathBrowserify;
function requirePathBrowserify() {
  if (hasRequiredPathBrowserify)
    return pathBrowserify;
  hasRequiredPathBrowserify = 1;
  function assertPath2(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code2;
    for (var i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length)
        code2 = path2.charCodeAt(i2);
      else if (code2 === 47)
        break;
      else
        code2 = 47;
      if (code2 === 47) {
        if (lastSlash === i2 - 1 || dots === 1)
          ;
        else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i2);
          else
            res = path2.slice(lastSlash + 1, i2);
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code2 === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir2 = pathObject.dir || pathObject.root;
    var base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir2) {
      return base2;
    }
    if (dir2 === pathObject.root) {
      return dir2 + base2;
    }
    return dir2 + sep + base2;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        var path2;
        if (i2 >= 0)
          path2 = arguments[i2];
        else {
          if (cwd2 === void 0)
            cwd2 = dist.process.cwd();
          path2 = cwd2;
        }
        assertPath2(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath2(path2);
      if (path2.length === 0)
        return ".";
      var isAbsolute = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute);
      if (path2.length === 0 && !isAbsolute)
        path2 = ".";
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute(path2) {
      assertPath2(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i2 = 0; i2 < arguments.length; ++i2) {
        var arg = arguments[i2];
        assertPath2(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath2(from);
      assertPath2(to);
      if (from === to)
        return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i2 = 0;
      for (; i2 <= length; ++i2) {
        if (i2 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i2) === 47) {
              return to.slice(toStart + i2 + 1);
            } else if (i2 === 0) {
              return to.slice(toStart + i2);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i2) === 47) {
              lastCommonSep = i2;
            } else if (i2 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i2);
        var toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i2;
      }
      var out = "";
      for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
        if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath2(path2);
      if (path2.length === 0)
        return ".";
      var code2 = path2.charCodeAt(0);
      var hasRoot = code2 === 47;
      var end2 = -1;
      var matchedSlash = true;
      for (var i2 = path2.length - 1; i2 >= 1; --i2) {
        code2 = path2.charCodeAt(i2);
        if (code2 === 47) {
          if (!matchedSlash) {
            end2 = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end2 === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end2 === 1)
        return "//";
      return path2.slice(0, end2);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath2(path2);
      var start = 0;
      var end2 = -1;
      var matchedSlash = true;
      var i2;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          var code2 = path2.charCodeAt(i2);
          if (code2 === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end2 = i2;
                }
              } else {
                extIdx = -1;
                end2 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end2)
          end2 = firstNonSlashEnd;
        else if (end2 === -1)
          end2 = path2.length;
        return path2.slice(start, end2);
      } else {
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else if (end2 === -1) {
            matchedSlash = false;
            end2 = i2 + 1;
          }
        }
        if (end2 === -1)
          return "";
        return path2.slice(start, end2);
      }
    },
    extname: function extname2(path2) {
      assertPath2(path2);
      var startDot = -1;
      var startPart = 0;
      var end2 = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i2 = path2.length - 1; i2 >= 0; --i2) {
        var code2 = path2.charCodeAt(i2);
        if (code2 === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i2 + 1;
        }
        if (code2 === 46) {
          if (startDot === -1)
            startDot = i2;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end2 === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end2);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse2(path2) {
      assertPath2(path2);
      var ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0)
        return ret;
      var code2 = path2.charCodeAt(0);
      var isAbsolute = code2 === 47;
      var start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end2 = -1;
      var matchedSlash = true;
      var i2 = path2.length - 1;
      var preDotState = 0;
      for (; i2 >= start; --i2) {
        code2 = path2.charCodeAt(i2);
        if (code2 === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i2 + 1;
        }
        if (code2 === 46) {
          if (startDot === -1)
            startDot = i2;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end2 === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
        if (end2 !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end2);
          else
            ret.base = ret.name = path2.slice(startPart, end2);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end2);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end2);
        }
        ret.ext = path2.slice(startDot, end2);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  pathBrowserify = posix;
  return pathBrowserify;
}
var pathBrowserifyExports = requirePathBrowserify();
const path$1 = /* @__PURE__ */ getDefaultExportFromCjs(pathBrowserifyExports);
function ok$1() {
}
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property2, normal, space) {
    this.property = property2;
    this.normal = normal;
    if (space) {
      this.space = space;
    }
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions, space) {
  const property2 = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property2, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema(property2, normal, space);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property2, attribute2) {
    this.property = property2;
    this.attribute = attribute2;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types$1);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property2, attribute2, mask, space) {
    let index2 = -1;
    super(property2, attribute2);
    mark(this, "space", space);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types$1[check]) === types$1[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
const own$7 = {}.hasOwnProperty;
function create(definition) {
  const property2 = {};
  const normal = {};
  let prop2;
  for (prop2 in definition.properties) {
    if (own$7.call(definition.properties, prop2)) {
      const value = definition.properties[prop2];
      const info = new DefinedInfo(
        prop2,
        definition.transform(definition.attributes || {}, prop2),
        value,
        definition.space
      );
      if (definition.mustUseProperty && definition.mustUseProperty.includes(prop2)) {
        info.mustUseProperty = true;
      }
      property2[prop2] = info;
      normal[normalize$1(prop2)] = prop2;
      normal[normalize$1(info.attribute)] = prop2;
    }
  }
  return new Schema(property2, normal, definition.space);
}
const xlink = create({
  space: "xlink",
  transform(_2, prop2) {
    return "xlink:" + prop2.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_2, prop2) {
    return "xml:" + prop2.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes2, attribute2) {
  return attribute2 in attributes2 ? attributes2[attribute2] : attribute2;
}
function caseInsensitiveTransform(attributes2, property2) {
  return caseSensitiveTransform(attributes2, property2.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_2, prop2) {
    return prop2 === "role" ? prop2 : "aria-" + prop2.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
const html$3 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop2 = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase$1);
      prop2 = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop2, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase$1($0) {
  return $0.charAt(1).toUpperCase();
}
const html$2 = merge([xml, xlink, xmlns, aria, html$3], "html");
const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function parse$2(value) {
  const tokens = [];
  const input = String(value || "");
  let index2 = input.indexOf(",");
  let start = 0;
  let end2 = false;
  while (!end2) {
    if (index2 === -1) {
      index2 = input.length;
      end2 = true;
    }
    const token2 = input.slice(start, index2).trim();
    if (token2 || !end2) {
      tokens.push(token2);
    }
    start = index2 + 1;
    index2 = input.indexOf(",", start);
  }
  return tokens;
}
function stringify$1(values, options2) {
  const settings = options2 || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const search$1 = /[#.]/g;
function parseSelector(selector2, defaultTagName) {
  const value = selector2 || "";
  const props = {};
  let start = 0;
  let previous;
  let tagName;
  while (start < value.length) {
    search$1.lastIndex = start;
    const match = search$1.exec(value);
    const subvalue = value.slice(start, match ? match.index : value.length);
    if (subvalue) {
      if (!previous) {
        tagName = subvalue;
      } else if (previous === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start += subvalue.length;
    }
    if (match) {
      previous = match[0];
      start++;
    }
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}
function parse$1(value) {
  const input = String(value || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify(values) {
  return values.join(" ").trim();
}
const buttonTypes = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]);
const own$6 = {}.hasOwnProperty;
function createH(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive && createAdjustMap(caseSensitive);
  function h2(selector2, properties, ...children) {
    let index2 = -1;
    let node2;
    if (selector2 === void 0 || selector2 === null) {
      node2 = { type: "root", children: [] };
      const child = (
        /** @type {Child} */
        properties
      );
      children.unshift(child);
    } else {
      node2 = parseSelector(selector2, defaultTagName);
      node2.tagName = node2.tagName.toLowerCase();
      if (adjust && own$6.call(adjust, node2.tagName)) {
        node2.tagName = adjust[node2.tagName];
      }
      if (isProperties(properties, node2.tagName)) {
        let key2;
        for (key2 in properties) {
          if (own$6.call(properties, key2)) {
            addProperty(schema, node2.properties, key2, properties[key2]);
          }
        }
      } else {
        children.unshift(properties);
      }
    }
    while (++index2 < children.length) {
      addChild(node2.children, children[index2]);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  }
  return h2;
}
function isProperties(value, name2) {
  if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }
  if (name2 === "input" || !value.type || typeof value.type !== "string") {
    return true;
  }
  if ("children" in value && Array.isArray(value.children)) {
    return false;
  }
  if (name2 === "button") {
    return buttonTypes.has(value.type.toLowerCase());
  }
  return !("value" in value);
}
function addProperty(schema, properties, key2, value) {
  const info = find(schema, key2);
  let index2 = -1;
  let result;
  if (value === void 0 || value === null)
    return;
  if (typeof value === "number") {
    if (Number.isNaN(value))
      return;
    result = value;
  } else if (typeof value === "boolean") {
    result = value;
  } else if (typeof value === "string") {
    if (info.spaceSeparated) {
      result = parse$1(value);
    } else if (info.commaSeparated) {
      result = parse$2(value);
    } else if (info.commaOrSpaceSeparated) {
      result = parse$1(parse$2(value).join(" "));
    } else {
      result = parsePrimitive(info, info.property, value);
    }
  } else if (Array.isArray(value)) {
    result = value.concat();
  } else {
    result = info.property === "style" ? style(value) : String(value);
  }
  if (Array.isArray(result)) {
    const finalResult = [];
    while (++index2 < result.length) {
      const value2 = (
        /** @type {number | string} */
        parsePrimitive(info, info.property, result[index2])
      );
      finalResult[index2] = value2;
    }
    result = finalResult;
  }
  if (info.property === "className" && Array.isArray(properties.className)) {
    const value2 = (
      /** @type {number | string} */
      result
    );
    result = properties.className.concat(value2);
  }
  properties[info.property] = result;
}
function addChild(nodes, value) {
  let index2 = -1;
  if (value === void 0 || value === null)
    ;
  else if (typeof value === "string" || typeof value === "number") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    while (++index2 < value.length) {
      addChild(nodes, value[index2]);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info, name2, value) {
  if (typeof value === "string") {
    if (info.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$1(value) === normalize$1(name2))) {
      return true;
    }
  }
  return value;
}
function style(value) {
  const result = [];
  let key2;
  for (key2 in value) {
    if (own$6.call(value, key2)) {
      result.push([key2, value[key2]].join(": "));
    }
  }
  return result.join("; ");
}
function createAdjustMap(values) {
  const result = {};
  let index2 = -1;
  while (++index2 < values.length) {
    result[values[index2].toLowerCase()] = values[index2];
  }
  return result;
}
const svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];
const h$1 = createH(html$2, "div");
const s$1 = createH(svg, "g", svgCaseSensitiveTagNames);
const search = /\r?\n|\r/g;
function location$1(file) {
  const value = String(file);
  const indices = [];
  search.lastIndex = 0;
  while (search.test(value)) {
    indices.push(search.lastIndex);
  }
  indices.push(value.length + 1);
  return { toPoint, toOffset };
  function toPoint(offset) {
    let index2 = -1;
    if (typeof offset === "number" && offset > -1 && offset < indices[indices.length - 1]) {
      while (++index2 < indices.length) {
        if (indices[index2] > offset) {
          return {
            line: index2 + 1,
            column: offset - (index2 > 0 ? indices[index2 - 1] : 0) + 1,
            offset
          };
        }
      }
    }
  }
  function toOffset(point2) {
    const line = point2 && point2.line;
    const column = point2 && point2.column;
    if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {
      const offset = (indices[line - 2] || 0) + column - 1 || 0;
      if (offset > -1 && offset < indices[indices.length - 1]) {
        return offset;
      }
    }
  }
}
const webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
const own$5 = {}.hasOwnProperty;
const proto = Object.prototype;
function fromParse5(tree, options2) {
  const settings = options2 || {};
  return one$3(
    {
      file: settings.file || void 0,
      location: false,
      schema: settings.space === "svg" ? svg : html$2,
      verbose: settings.verbose || false
    },
    tree
  );
}
function one$3(state, node2) {
  let result;
  switch (node2.nodeName) {
    case "#comment": {
      const reference = (
        /** @type {P5Comment} */
        node2
      );
      result = { type: "comment", value: reference.data };
      patch(state, reference, result);
      return result;
    }
    case "#document":
    case "#document-fragment": {
      const reference = (
        /** @type {P5Document | P5DocumentFragment} */
        node2
      );
      const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
      result = {
        type: "root",
        children: all$4(state, node2.childNodes),
        data: { quirksMode }
      };
      if (state.file && state.location) {
        const doc = String(state.file);
        const loc = location$1(doc);
        const start = loc.toPoint(0);
        const end2 = loc.toPoint(doc.length);
        result.position = { start, end: end2 };
      }
      return result;
    }
    case "#documentType": {
      const reference = (
        /** @type {P5DocumentType} */
        node2
      );
      result = { type: "doctype" };
      patch(state, reference, result);
      return result;
    }
    case "#text": {
      const reference = (
        /** @type {P5Text} */
        node2
      );
      result = { type: "text", value: reference.value };
      patch(state, reference, result);
      return result;
    }
    default: {
      const reference = (
        /** @type {P5Element} */
        node2
      );
      result = element$1(state, reference);
      return result;
    }
  }
}
function all$4(state, nodes) {
  let index2 = -1;
  const results = [];
  while (++index2 < nodes.length) {
    const result = (
      /** @type {RootContent} */
      one$3(state, nodes[index2])
    );
    results.push(result);
  }
  return results;
}
function element$1(state, node2) {
  const schema = state.schema;
  state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$2;
  let index2 = -1;
  const props = {};
  while (++index2 < node2.attrs.length) {
    const attribute2 = node2.attrs[index2];
    const name2 = (attribute2.prefix ? attribute2.prefix + ":" : "") + attribute2.name;
    if (!own$5.call(proto, name2)) {
      props[name2] = attribute2.value;
    }
  }
  const fn = state.schema.space === "svg" ? s$1 : h$1;
  const result = fn(node2.tagName, props, all$4(state, node2.childNodes));
  patch(state, node2, result);
  if (result.tagName === "template") {
    const reference = (
      /** @type {P5Template} */
      node2
    );
    const pos = reference.sourceCodeLocation;
    const startTag = pos && pos.startTag && position$1(pos.startTag);
    const endTag = pos && pos.endTag && position$1(pos.endTag);
    const content = (
      /** @type {Root} */
      one$3(state, reference.content)
    );
    if (startTag && endTag && state.file) {
      content.position = { start: startTag.end, end: endTag.start };
    }
    result.content = content;
  }
  state.schema = schema;
  return result;
}
function patch(state, from, to) {
  if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
    const position2 = createLocation(state, to, from.sourceCodeLocation);
    if (position2) {
      state.location = true;
      to.position = position2;
    }
  }
}
function createLocation(state, node2, location2) {
  const result = position$1(location2);
  if (node2.type === "element") {
    const tail = node2.children[node2.children.length - 1];
    if (result && !location2.endTag && tail && tail.position && tail.position.end) {
      result.end = Object.assign({}, tail.position.end);
    }
    if (state.verbose) {
      const props = {};
      let key2;
      if (location2.attrs) {
        for (key2 in location2.attrs) {
          if (own$5.call(location2.attrs, key2)) {
            props[find(state.schema, key2).property] = position$1(
              location2.attrs[key2]
            );
          }
        }
      }
      ok$1(location2.startTag);
      const opening2 = position$1(location2.startTag);
      const closing2 = location2.endTag ? position$1(location2.endTag) : void 0;
      const data2 = { opening: opening2 };
      if (closing2)
        data2.closing = closing2;
      data2.properties = props;
      node2.data = { position: data2 };
    }
  }
  return result;
}
function position$1(loc) {
  const start = point$1({
    line: loc.startLine,
    column: loc.startCol,
    offset: loc.startOffset
  });
  const end2 = point$1({
    line: loc.endLine,
    column: loc.endCol,
    offset: loc.endOffset
  });
  return start || end2 ? { start, end: end2 } : void 0;
}
function point$1(point2) {
  return point2.line && point2.column ? point2 : void 0;
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options2 = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options2 = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options2 = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options2 = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options2 = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options2.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options2.cause = causeOrReason;
    }
    if (!options2.ruleId && !options2.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options2.ruleId = origin;
      } else {
        options2.source = origin.slice(0, index2);
        options2.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options2.place && options2.ancestors && options2.ancestors) {
      const parent = options2.ancestors[options2.ancestors.length - 1];
      if (parent) {
        options2.place = parent.position;
      }
    }
    const start = options2.place && "start" in options2.place ? options2.place.start : options2.place;
    this.ancestors = options2.ancestors || void 0;
    this.cause = options2.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options2.place) || "1:1";
    this.place = options2.place || void 0;
    this.reason = this.message;
    this.ruleId = options2.ruleId || void 0;
    this.source = options2.source || void 0;
    this.stack = legacyCause && options2.cause && typeof options2.cause.stack === "string" ? options2.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end2 = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end2 < 0) {
        seenNonSlash = true;
        end2 = index2 + 1;
      }
    }
    return end2 < 0 ? "" : path2.slice(start, end2);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
          if (extIndex < 0) {
            end2 = index2;
          }
        } else {
          extIndex = -1;
          end2 = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end2) {
    end2 = firstNonSlashEnd;
  } else if (end2 < 0) {
    end2 = path2.length;
  }
  return path2.slice(start, end2);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end2 = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end2 = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end2 = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end2 < 0) {
      unmatchedSlash = true;
      end2 = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end2);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath$1(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options2;
    if (!value) {
      options2 = {};
    } else if (isUrl(value)) {
      options2 = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options2 = { value };
    } else {
      options2 = value;
    }
    this.cwd = proc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop3 = order[index2];
      if (prop3 in options2 && options2[prop3] !== void 0 && options2[prop3] !== null) {
        this[prop3] = prop3 === "history" ? [...options2[prop3]] : options2[prop3];
      }
    }
    let prop2;
    for (prop2 in options2) {
      if (!order.includes(prop2)) {
        this[prop2] = options2[prop2];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const errors$1 = {
  /** @type {ErrorInfo} */
  abandonedHeadElementChild: {
    reason: "Unexpected metadata element after head",
    description: "Unexpected element after head. Expected the element before `</head>`",
    url: false
  },
  /** @type {ErrorInfo} */
  abruptClosingOfEmptyComment: {
    reason: "Unexpected abruptly closed empty comment",
    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
  },
  /** @type {ErrorInfo} */
  abruptDoctypePublicIdentifier: {
    reason: "Unexpected abruptly closed public identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
  },
  /** @type {ErrorInfo} */
  abruptDoctypeSystemIdentifier: {
    reason: "Unexpected abruptly closed system identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
  },
  /** @type {ErrorInfo} */
  absenceOfDigitsInNumericCharacterReference: {
    reason: "Unexpected non-digit at start of numeric character reference",
    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
  },
  /** @type {ErrorInfo} */
  cdataInHtmlContent: {
    reason: "Unexpected CDATA section in HTML",
    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
  },
  /** @type {ErrorInfo} */
  characterReferenceOutsideUnicodeRange: {
    reason: "Unexpected too big numeric character reference",
    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
  },
  /** @type {ErrorInfo} */
  closingOfElementWithOpenChildElements: {
    reason: "Unexpected closing tag with open child elements",
    description: "Unexpectedly closing tag. Expected other tags to be closed first",
    url: false
  },
  /** @type {ErrorInfo} */
  controlCharacterInInputStream: {
    reason: "Unexpected control character",
    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  controlCharacterReference: {
    reason: "Unexpected control character reference",
    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  disallowedContentInNoscriptInHead: {
    reason: "Disallowed content inside `<noscript>` in `<head>`",
    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
    url: false
  },
  /** @type {ErrorInfo} */
  duplicateAttribute: {
    reason: "Unexpected duplicate attribute",
    description: "Unexpectedly double attribute. Expected attributes to occur only once"
  },
  /** @type {ErrorInfo} */
  endTagWithAttributes: {
    reason: "Unexpected attribute on closing tag",
    description: "Unexpected attribute. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithTrailingSolidus: {
    reason: "Unexpected slash at end of closing tag",
    description: "Unexpected `%c-1`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithoutMatchingOpenElement: {
    reason: "Unexpected unopened end tag",
    description: "Unexpected end tag. Expected no end tag or another end tag",
    url: false
  },
  /** @type {ErrorInfo} */
  eofBeforeTagName: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected tag name instead"
  },
  /** @type {ErrorInfo} */
  eofInCdata: {
    reason: "Unexpected end of file in CDATA",
    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
  },
  /** @type {ErrorInfo} */
  eofInComment: {
    reason: "Unexpected end of file in comment",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInDoctype: {
    reason: "Unexpected end of file in doctype",
    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
  },
  /** @type {ErrorInfo} */
  eofInElementThatCanContainOnlyText: {
    reason: "Unexpected end of file in element that can only contain text",
    description: "Unexpected end of file. Expected text or a closing tag",
    url: false
  },
  /** @type {ErrorInfo} */
  eofInScriptHtmlCommentLikeText: {
    reason: "Unexpected end of file in comment inside script",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInTag: {
    reason: "Unexpected end of file in tag",
    description: "Unexpected end of file. Expected `>` to close the tag"
  },
  /** @type {ErrorInfo} */
  incorrectlyClosedComment: {
    reason: "Incorrectly closed comment",
    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  incorrectlyOpenedComment: {
    reason: "Incorrectly opened comment",
    description: "Unexpected `%c`. Expected `<!--` to open the comment"
  },
  /** @type {ErrorInfo} */
  invalidCharacterSequenceAfterDoctypeName: {
    reason: "Invalid sequence after doctype name",
    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
  },
  /** @type {ErrorInfo} */
  invalidFirstCharacterOfTagName: {
    reason: "Invalid first character in tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  misplacedDoctype: {
    reason: "Misplaced doctype",
    description: "Unexpected doctype. Expected doctype before head",
    url: false
  },
  /** @type {ErrorInfo} */
  misplacedStartTagForHeadElement: {
    reason: "Misplaced `<head>` start tag",
    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
    url: false
  },
  /** @type {ErrorInfo} */
  missingAttributeValue: {
    reason: "Missing attribute value",
    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctype: {
    reason: "Missing doctype before other content",
    description: "Expected a `<!doctype html>` before anything else",
    url: false
  },
  /** @type {ErrorInfo} */
  missingDoctypeName: {
    reason: "Missing doctype name",
    description: "Unexpected doctype end at `%c`. Expected `html` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypePublicIdentifier: {
    reason: "Missing public identifier in doctype",
    description: "Unexpected `%c`. Expected identifier for `public` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypeSystemIdentifier: {
    reason: "Missing system identifier in doctype",
    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
  },
  /** @type {ErrorInfo} */
  missingEndTagName: {
    reason: "Missing name in end tag",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: "Missing quote before public identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: "Missing quote before system identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingSemicolonAfterCharacterReference: {
    reason: "Missing semicolon after character reference",
    description: "Unexpected `%c`. Expected `;` instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: "Missing whitespace after public identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: "Missing whitespace after system identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBeforeDoctypeName: {
    reason: "Missing whitespace before doctype name",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenAttributes: {
    reason: "Missing whitespace between attributes",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: "Missing whitespace between public and system identifiers in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  nestedComment: {
    reason: "Unexpected nested comment",
    description: "Unexpected `<!--`. Expected `-->`"
  },
  /** @type {ErrorInfo} */
  nestedNoscriptInHead: {
    reason: "Unexpected nested `<noscript>` in `<head>`",
    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
    url: false
  },
  /** @type {ErrorInfo} */
  nonConformingDoctype: {
    reason: "Unexpected non-conforming doctype declaration",
    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
    url: false
  },
  /** @type {ErrorInfo} */
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: "Unexpected trailing slash on start tag of non-void element",
    description: "Unexpected `/`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  noncharacterCharacterReference: {
    reason: "Unexpected noncharacter code point referenced by character reference",
    description: "Unexpected code point. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  noncharacterInInputStream: {
    reason: "Unexpected noncharacter character",
    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  nullCharacterReference: {
    reason: "Unexpected NULL character referenced by character reference",
    description: "Unexpected code point. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  openElementsLeftAfterEof: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected closing tag instead",
    url: false
  },
  /** @type {ErrorInfo} */
  surrogateCharacterReference: {
    reason: "Unexpected surrogate character referenced by character reference",
    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  surrogateInInputStream: {
    reason: "Unexpected surrogate character",
    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: "Invalid character after system identifier in doctype",
    description: "Unexpected character at `%c`. Expected `>`"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInAttributeName: {
    reason: "Unexpected character in attribute name",
    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: "Unexpected character in unquoted attribute value",
    description: "Unexpected `%c`. Quote the attribute value to include it"
  },
  /** @type {ErrorInfo} */
  unexpectedEqualsSignBeforeAttributeName: {
    reason: "Unexpected equals sign before attribute name",
    description: "Unexpected `%c`. Add an attribute name before it"
  },
  /** @type {ErrorInfo} */
  unexpectedNullCharacter: {
    reason: "Unexpected NULL character",
    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: "Unexpected question mark instead of tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  unexpectedSolidusInTag: {
    reason: "Unexpected slash in tag",
    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
  },
  /** @type {ErrorInfo} */
  unknownNamedCharacterReference: {
    reason: "Unexpected unknown named character reference",
    description: "Unexpected character reference. Expected known named character references"
  }
};
const base = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-";
const dashToCamelRe = /-[a-z]/g;
const formatCRe = /%c(?:([-+])(\d+))?/g;
const formatXRe = /%x/g;
const fatalities = { 2: true, 1: false, 0: null };
const emptyOptions$1 = {};
function fromHtml(value, options2) {
  const settings = options2 || emptyOptions$1;
  const onerror = settings.onerror;
  const file = value instanceof VFile ? value : new VFile(value);
  const fn = settings.fragment ? cjs$1.parseFragment : cjs$1.parse;
  const doc = String(file);
  const p5doc = fn(doc, {
    sourceCodeLocationInfo: true,
    // Note `parse5` types currently do not allow `undefined`.
    onParseError: settings.onerror ? internalOnerror : null,
    scriptingEnabled: false
  });
  return (
    /** @type {Root} */
    fromParse5(p5doc, {
      file,
      space: settings.space,
      verbose: settings.verbose
    })
  );
  function internalOnerror(error) {
    const code2 = error.code;
    const name2 = camelcase(code2);
    const setting = settings[name2];
    const config = setting === null || setting === void 0 ? true : setting;
    const level = typeof config === "number" ? config : config ? 1 : 0;
    if (level) {
      const info = errors$1[name2];
      const message = new VFileMessage(format(info.reason), {
        place: {
          start: {
            line: error.startLine,
            column: error.startCol,
            offset: error.startOffset
          },
          end: {
            line: error.endLine,
            column: error.endCol,
            offset: error.endOffset
          }
        },
        ruleId: code2,
        source: "hast-util-from-html"
      });
      if (file.path) {
        message.file = file.path;
        message.name = file.path + ":" + message.name;
      }
      message.fatal = fatalities[level];
      message.note = format(info.description);
      message.url = info.url === false ? void 0 : base + code2;
      onerror(message);
    }
    function format(value2) {
      return value2.replace(formatCRe, formatC).replace(formatXRe, formatX);
      function formatC(_2, $1, $2) {
        const offset = ($2 ? Number.parseInt($2, 10) : 0) * ($1 === "-" ? -1 : 1);
        const char = doc.charAt(error.startOffset + offset);
        return visualizeCharacter(char);
      }
      function formatX() {
        return visualizeCharacterCode(doc.charCodeAt(error.startOffset));
      }
    }
  }
}
function camelcase(value) {
  return (
    /** @type {ErrorCode} */
    value.replace(dashToCamelRe, dashToCamel)
  );
}
function dashToCamel($0) {
  return $0.charAt(1).toUpperCase();
}
function visualizeCharacter(char) {
  return char === "`" ? "` ` `" : char;
}
function visualizeCharacterCode(charCode) {
  return "0x" + charCode.toString(16).toUpperCase();
}
function rehypeParse(options2) {
  const self2 = this;
  const { emitParseErrors, ...settings } = { ...self2.data("settings"), ...options2 };
  self2.parser = parser2;
  function parser2(doc, file) {
    return fromHtml(doc, {
      ...settings,
      onerror: emitParseErrors ? function(message) {
        if (file.path) {
          message.name = file.path + ":" + message.name;
          message.file = file.path;
        }
        file.messages.push(message);
      } : void 0
    });
  }
}
const htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
const own$4 = {}.hasOwnProperty;
function zwitch(key2, options2) {
  const settings = options2 || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own$4.call(value, key2)) {
      const id2 = String(value[key2]);
      fn = own$4.call(handlers, id2) ? handlers[id2] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function core(value, options2) {
  value = value.replace(
    options2.subset ? charactersToExpression(options2.subset) : /["&'<>`]/g,
    basic
  );
  if (options2.subset || options2.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index2, all) {
    return options2.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all.charCodeAt(index2 + 2),
      options2
    );
  }
  function basic(character, index2, all) {
    return options2.format(
      character.charCodeAt(0),
      all.charCodeAt(index2 + 1),
      options2
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function toHexadecimal(code2, next, omit) {
  const value = "&#x" + code2.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
}
function toDecimal(code2, next, omit) {
  const value = "&#" + String(code2);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
}
const characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
const characterEntitiesHtml4 = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
};
const dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
const own$3 = {}.hasOwnProperty;
const characters = {};
let key;
for (key in characterEntitiesHtml4) {
  if (own$3.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
function toNamed(code2, next, omit, attribute2) {
  const character = String.fromCharCode(code2);
  if (own$3.call(characters, character)) {
    const name2 = characters[character];
    const value = "&" + name2;
    if (omit && characterEntitiesLegacy.includes(name2) && !dangerous.includes(name2) && (!attribute2 || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}
function formatSmart(code2, next, options2) {
  let numeric = toHexadecimal(code2, next, options2.omitOptionalSemicolons);
  let named;
  if (options2.useNamedReferences || options2.useShortestReferences) {
    named = toNamed(
      code2,
      next,
      options2.omitOptionalSemicolons,
      options2.attribute
    );
  }
  if ((options2.useShortestReferences || !named) && options2.useShortestReferences) {
    const decimal = toDecimal(code2, next, options2.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options2.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
function stringifyEntities(value, options2) {
  return core(value, Object.assign({ format: formatSmart }, options2));
}
function comment(node2, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + node2.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode2) + "-->";
  function encode2($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count2++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count2;
}
const re$1 = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty$3(thing.value) : false : empty$3(thing);
}
function empty$3(value) {
  return value.replace(re$1, "") === "";
}
const siblingAfter = siblings(1);
const siblingBefore = siblings(-1);
const emptyChildren$1 = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren$1;
    let offset = (index2 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}
const own$2 = {}.hasOwnProperty;
function omission(handlers) {
  return omit;
  function omit(node2, index2, parent) {
    return own$2.call(handlers, node2.tagName) && handlers[node2.tagName](node2, index2, parent);
  }
}
const closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt: dt$1,
  head: headOrColgroupOrCaption,
  html: html$1,
  li,
  optgroup,
  option,
  p: p$1,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_2, index2, parent) {
  const next = siblingAfter(parent, index2, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html$1(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function body$1(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function p$1(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt$1(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody$1(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_2, index2, parent) {
  return !siblingAfter(parent, index2);
}
function tr(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_2, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}
const opening = omission({
  body,
  colgroup,
  head,
  html,
  tbody
});
function html(node2) {
  const head2 = siblingAfter(node2, -1);
  return !head2 || head2.type !== "comment";
}
function head(node2) {
  const children = node2.children;
  const seen = [];
  let index2 = -1;
  while (++index2 < children.length) {
    const child = children[index2];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName))
        return false;
      seen.push(child.tagName);
    }
  }
  return children.length > 0;
}
function body(node2) {
  const head2 = siblingAfter(node2, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node2, index2, parent) {
  const previous = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1, true);
  if (parent && previous && previous.type === "element" && previous.tagName === "colgroup" && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody(node2, index2, parent) {
  const previous = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1);
  if (parent && previous && previous.type === "element" && (previous.tagName === "thead" || previous.tagName === "tbody") && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}
const constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node2, index2, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last2;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg;
  }
  const attrs = serializeAttributes(state, node2.properties);
  const content = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content)
    selfClosing = false;
  if (attrs || !omit || !opening(node2, index2, parent)) {
    parts.push("<", node2.tagName, attrs ? " " + attrs : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last2 = attrs.charAt(attrs.length - 1);
      if (!state.settings.tightSelfClosing || last2 === "/" || last2 && last2 !== '"' && last2 !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content);
  if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, props) {
  const values = [];
  let index2 = -1;
  let key2;
  if (props) {
    for (key2 in props) {
      if (props[key2] !== null && props[key2] !== void 0) {
        const value = serializeAttribute(state, key2, props[key2]);
        if (value)
          values.push(value);
      }
    }
  }
  while (++index2 < values.length) {
    const last2 = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : void 0;
    if (index2 !== values.length - 1 && last2 !== '"' && last2 !== "'") {
      values[index2] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute(state, key2, value) {
  const info = find(state.schema, key2);
  const x2 = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y2 = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if (info.boolean || info.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name2 = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x2][y2]
    })
  );
  if (value === true)
    return name2;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify$1 : stringify)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value)
    return name2;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x2][y2]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x2][y2],
        attribute: true
      })
    ) + quote;
  }
  return name2 + (result ? "=" + result : result);
}
function text(node2, _2, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function raw(node2, index2, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text(node2, index2, parent, state);
}
function root$1(node2, _1, _2, state) {
  return state.all(node2);
}
const handle$1 = zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element, raw, root: root$1, text }
});
function invalid(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}
const emptyOptions = {};
const emptyCharacterReferences = {};
const emptyChildren = [];
function toHtml(tree, options2) {
  const options_ = options2 || emptyOptions;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one: one$2,
    all: all$3,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg : html$2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one$2(node2, index2, parent) {
  return handle$1(node2, index2, parent, this);
}
function all$3(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren;
  let index2 = -1;
  while (++index2 < children.length) {
    results[index2] = this.one(children[index2], index2, parent);
  }
  return results.join("");
}
function rehypeStringify(options2) {
  const self2 = this;
  const settings = { ...self2.data("settings"), ...options2 };
  self2.compiler = compiler;
  function compiler(tree) {
    return toHtml(tree, settings);
  }
}
function bail(error) {
  if (error) {
    throw error;
  }
}
var hasOwn$1 = Object.prototype.hasOwnProperty;
var toStr$5 = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD$2 = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr$5.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr$5.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn$1.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$1.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn$1.call(obj, key2);
};
var setProperty = function setProperty2(target, options2) {
  if (defineProperty && options2.name === "__proto__") {
    defineProperty(target, options2.name, {
      enumerable: true,
      configurable: true,
      value: options2.newValue,
      writable: true
    });
  } else {
    target[options2.name] = options2.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn$1.call(obj, name2)) {
      return void 0;
    } else if (gOPD$2) {
      return gOPD$2(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend = function extend2() {
  var options2, name2, src, copy, copyIsArray, clone2;
  var target = arguments[0];
  var i2 = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i2 = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i2 < length; ++i2) {
    options2 = arguments[i2];
    if (options2 != null) {
      for (name2 in options2) {
        src = getProperty(target, name2);
        copy = getProperty(options2, name2);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && isArray(src) ? src : [];
            } else {
              clone2 = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend2(deep, clone2, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty(target, { name: name2, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property2) {
    const self2 = this;
    const constr = self2.constructor;
    const proto2 = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const func = proto2[property2];
    const apply = function() {
      return func.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto2);
    const names = Object.getOwnPropertyNames(func);
    for (const p2 of names) {
      const descriptor = Object.getOwnPropertyDescriptor(func, p2);
      if (descriptor)
        Object.defineProperty(apply, p2, descriptor);
    }
    return apply;
  }
);
const own$1 = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$1(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own$1.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options2] = this.attachers[this.freezeIndex];
      if (options2[0] === false) {
        continue;
      }
      if (options2[0] === true) {
        options2[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options2);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser2 = this.parser || this.Parser;
    assertParser("parse", parser2);
    return parser2(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler);
    assertNode(tree);
    return compiler(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add2(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$1(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add2(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = extend$1(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const rehype = unified().use(rehypeParse).use(rehypeStringify).freeze();
const convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test2) {
    if (test2 === null || test2 === void 0) {
      return ok;
    }
    if (typeof test2 === "function") {
      return castFactory(test2);
    }
    if (typeof test2 === "object") {
      return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
    }
    if (typeof test2 === "string") {
      return typeFactory(test2);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all);
  function all(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color(d2) {
  return d2;
}
const empty$2 = [];
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
function visitParents(tree, test2, visitor, reverse) {
  let check;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
  } else {
    check = test2;
  }
  const is3 = convert(check);
  const step = reverse ? -1 : 1;
  factory2(tree, void 0, [])();
  function factory2(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty$2;
      let subresult;
      let offset;
      let grandparents;
      if (!test2 || is3(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory2(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty$2 : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test2;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test2 = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test2 = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test2, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const emptyMulticharIndex = {};
const emptyRegularIndex = {};
function extendIndex(item, index2) {
  let currentIndex = index2;
  for (let pos = 0; pos < item.length; pos++) {
    const isLast = pos === item.length - 1;
    const char = item.charAt(pos);
    const charIndex = currentIndex[char] || (currentIndex[char] = { chars: {} });
    if (isLast) {
      charIndex.self = item;
    }
    currentIndex = charIndex.chars;
  }
}
function createMulticharIndex(items) {
  if (items.length === 0) {
    return emptyMulticharIndex;
  }
  const index2 = {};
  for (const item of items) {
    extendIndex(item, index2);
  }
  return index2;
}
function createRegularIndex(items) {
  if (items.length === 0) {
    return emptyRegularIndex;
  }
  const result = {};
  for (const item of items) {
    result[item] = true;
  }
  return result;
}
const emptyPseudoClassSignatures = {};
const defaultPseudoClassSignature = {
  type: "String",
  optional: true
};
function calculatePseudoClassSignature(types2) {
  const result = {
    optional: false
  };
  function setResultType(type) {
    if (result.type && result.type !== type) {
      throw new Error(`Conflicting pseudo-class argument type: "${result.type}" vs "${type}".`);
    }
    result.type = type;
  }
  for (const type of types2) {
    if (type === "NoArgument") {
      result.optional = true;
    }
    if (type === "Formula") {
      setResultType("Formula");
    }
    if (type === "FormulaOfSelector") {
      setResultType("Formula");
      result.ofSelector = true;
    }
    if (type === "String") {
      setResultType("String");
    }
    if (type === "Selector") {
      setResultType("Selector");
    }
  }
  return result;
}
function inverseCategories(obj) {
  const result = {};
  for (const category of Object.keys(obj)) {
    const items = obj[category];
    if (items) {
      for (const item of items) {
        (result[item] || (result[item] = [])).push(category);
      }
    }
  }
  return result;
}
function calculatePseudoClassSignatures(definitions) {
  const pseudoClassesToArgumentTypes = inverseCategories(definitions);
  const result = {};
  for (const pseudoClass of Object.keys(pseudoClassesToArgumentTypes)) {
    const argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];
    if (argumentTypes) {
      result[pseudoClass] = calculatePseudoClassSignature(argumentTypes);
    }
  }
  return result;
}
const emptyXmlOptions = {};
const defaultXmlOptions = { wildcard: true };
function getXmlOptions(param) {
  if (param) {
    if (typeof param === "boolean") {
      return defaultXmlOptions;
    } else {
      return param;
    }
  } else {
    return emptyXmlOptions;
  }
}
function extendSyntaxDefinition(base2, extension) {
  const result = { ...base2 };
  if ("tag" in extension) {
    if (extension.tag) {
      result.tag = { ...getXmlOptions(base2.tag) };
      const extensionOptions = getXmlOptions(extension.tag);
      if ("wildcard" in extensionOptions) {
        result.tag.wildcard = extensionOptions.wildcard;
      }
    } else {
      result.tag = void 0;
    }
  }
  if ("ids" in extension) {
    result.ids = extension.ids;
  }
  if ("classNames" in extension) {
    result.classNames = extension.classNames;
  }
  if ("namespace" in extension) {
    if (extension.namespace) {
      result.namespace = { ...getXmlOptions(base2.namespace) };
      const extensionOptions = getXmlOptions(extension.namespace);
      if ("wildcard" in extensionOptions) {
        result.namespace.wildcard = extensionOptions.wildcard;
      }
    } else {
      result.namespace = void 0;
    }
  }
  if ("combinators" in extension) {
    if (extension.combinators) {
      result.combinators = result.combinators ? result.combinators.concat(extension.combinators) : extension.combinators;
    } else {
      result.combinators = void 0;
    }
  }
  if ("attributes" in extension) {
    if (extension.attributes) {
      result.attributes = { ...base2.attributes };
      if ("unknownCaseSensitivityModifiers" in extension.attributes) {
        result.attributes.unknownCaseSensitivityModifiers = extension.attributes.unknownCaseSensitivityModifiers;
      }
      if ("operators" in extension.attributes) {
        result.attributes.operators = extension.attributes.operators ? result.attributes.operators ? result.attributes.operators.concat(extension.attributes.operators) : extension.attributes.operators : void 0;
      }
      if ("caseSensitivityModifiers" in extension.attributes) {
        result.attributes.caseSensitivityModifiers = extension.attributes.caseSensitivityModifiers ? result.attributes.caseSensitivityModifiers ? result.attributes.caseSensitivityModifiers.concat(extension.attributes.caseSensitivityModifiers) : extension.attributes.caseSensitivityModifiers : void 0;
      }
    } else {
      result.attributes = void 0;
    }
  }
  if ("pseudoElements" in extension) {
    if (extension.pseudoElements) {
      result.pseudoElements = { ...base2.pseudoElements };
      if ("unknown" in extension.pseudoElements) {
        result.pseudoElements.unknown = extension.pseudoElements.unknown;
      }
      if ("notation" in extension.pseudoElements) {
        result.pseudoElements.notation = extension.pseudoElements.notation;
      }
      if ("definitions" in extension.pseudoElements) {
        result.pseudoElements.definitions = extension.pseudoElements.definitions ? result.pseudoElements.definitions ? result.pseudoElements.definitions.concat(extension.pseudoElements.definitions) : extension.pseudoElements.definitions : void 0;
      }
    } else {
      result.pseudoElements = void 0;
    }
  }
  if ("pseudoClasses" in extension) {
    if (extension.pseudoClasses) {
      result.pseudoClasses = { ...base2.pseudoClasses };
      if ("unknown" in extension.pseudoClasses) {
        result.pseudoClasses.unknown = extension.pseudoClasses.unknown;
      }
      if ("definitions" in extension.pseudoClasses) {
        const newDefinitions = extension.pseudoClasses.definitions;
        if (newDefinitions) {
          result.pseudoClasses.definitions = {
            ...result.pseudoClasses.definitions
          };
          const existingDefinitions = result.pseudoClasses.definitions;
          for (const key2 of Object.keys(newDefinitions)) {
            const newDefinitionForNotation = newDefinitions[key2];
            const existingDefinitionForNotation = existingDefinitions[key2];
            if (newDefinitionForNotation) {
              existingDefinitions[key2] = existingDefinitionForNotation ? existingDefinitionForNotation.concat(newDefinitionForNotation) : newDefinitionForNotation;
            } else {
              existingDefinitions[key2] = void 0;
            }
          }
        } else {
          result.pseudoClasses.definitions = void 0;
        }
      }
    } else {
      result.pseudoClasses = void 0;
    }
  }
  return result;
}
const css1SyntaxDefinition = {
  tag: {},
  ids: true,
  classNames: true,
  combinators: [],
  pseudoElements: {
    unknown: "reject",
    notation: "singleColon",
    definitions: ["first-letter", "first-line"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["link", "visited", "active"]
    }
  }
};
const css2SyntaxDefinition = extendSyntaxDefinition(css1SyntaxDefinition, {
  tag: { wildcard: true },
  combinators: [">", "+"],
  attributes: {
    unknownCaseSensitivityModifiers: "reject",
    operators: ["=", "~=", "|="]
  },
  pseudoElements: {
    definitions: ["before", "after"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["hover", "focus", "first-child"],
      String: ["lang"]
    }
  }
});
const selectors3SyntaxDefinition = extendSyntaxDefinition(css2SyntaxDefinition, {
  namespace: {
    wildcard: true
  },
  combinators: ["~"],
  attributes: {
    operators: ["^=", "$=", "*="]
  },
  pseudoElements: {
    notation: "both"
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "root",
        "last-child",
        "first-of-type",
        "last-of-type",
        "only-child",
        "only-of-type",
        "empty",
        "target",
        "enabled",
        "disabled",
        "checked",
        "indeterminate"
      ],
      Formula: ["nth-child", "nth-last-child", "nth-of-type", "nth-last-of-type"],
      Selector: ["not"]
    }
  }
});
const selectors4SyntaxDefinition = extendSyntaxDefinition(selectors3SyntaxDefinition, {
  combinators: ["||"],
  attributes: {
    caseSensitivityModifiers: ["i", "I", "s", "S"]
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "any-link",
        "local-link",
        "target-within",
        "scope",
        "current",
        "past",
        "future",
        "focus-within",
        "focus-visible",
        "read-write",
        "read-only",
        "placeholder-shown",
        "default",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "required",
        "optional",
        "blank",
        "user-invalid"
      ],
      Formula: ["nth-col", "nth-last-col"],
      String: ["dir"],
      FormulaOfSelector: ["nth-child", "nth-last-child"],
      Selector: ["current", "is", "where", "has"]
    }
  }
});
const progressiveSyntaxDefinition = extendSyntaxDefinition(selectors4SyntaxDefinition, {
  pseudoElements: {
    unknown: "accept"
  },
  pseudoClasses: {
    unknown: "accept"
  },
  attributes: {
    unknownCaseSensitivityModifiers: "accept"
  }
});
const cssSyntaxDefinitions = {
  css1: css1SyntaxDefinition,
  css2: css2SyntaxDefinition,
  css3: selectors3SyntaxDefinition,
  "selectors-3": selectors3SyntaxDefinition,
  "selectors-4": selectors4SyntaxDefinition,
  latest: selectors4SyntaxDefinition,
  progressive: progressiveSyntaxDefinition
};
function isIdentStart(c2) {
  return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "-" || c2 === "_";
}
function isIdent(c2) {
  return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "-" || c2 === "_";
}
function isHex(c2) {
  return c2 >= "a" && c2 <= "f" || c2 >= "A" && c2 <= "F" || c2 >= "0" && c2 <= "9";
}
const stringEscapeChars = {
  n: "\n",
  r: "\r",
  t: "	",
  f: "\f",
  "\\": "\\"
};
const whitespaceChars = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true,
  "\f": true
};
const quoteChars = {
  '"': true,
  "'": true
};
const digitsChars = {
  0: true,
  1: true,
  2: true,
  3: true,
  4: true,
  5: true,
  6: true,
  7: true,
  8: true,
  9: true
};
const errorPrefix = `css-selector-parser parse error: `;
function createParser(options2 = {}) {
  const { syntax = "latest", substitutes, strict = true } = options2;
  let syntaxDefinition = typeof syntax === "string" ? cssSyntaxDefinitions[syntax] : syntax;
  if (syntaxDefinition.baseSyntax) {
    syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);
  }
  const [tagNameEnabled, tagNameWildcardEnabled] = syntaxDefinition.tag ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)] : [false, false];
  const idEnabled = Boolean(syntaxDefinition.ids);
  const classNamesEnabled = Boolean(syntaxDefinition.classNames);
  const namespaceEnabled = Boolean(syntaxDefinition.namespace);
  const namespaceWildcardEnabled = syntaxDefinition.namespace && (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);
  if (namespaceEnabled && !tagNameEnabled) {
    throw new Error(`${errorPrefix}Namespaces cannot be enabled while tags are disabled.`);
  }
  const substitutesEnabled = Boolean(substitutes);
  const combinatorsIndex = syntaxDefinition.combinators ? createMulticharIndex(syntaxDefinition.combinators) : emptyMulticharIndex;
  const [attributesEnabled, attributesOperatorsIndex, attributesCaseSensitivityModifiers, attributesAcceptUnknownCaseSensitivityModifiers] = syntaxDefinition.attributes ? [
    true,
    syntaxDefinition.attributes.operators ? createMulticharIndex(syntaxDefinition.attributes.operators) : emptyMulticharIndex,
    syntaxDefinition.attributes.caseSensitivityModifiers ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers) : emptyRegularIndex,
    syntaxDefinition.attributes.unknownCaseSensitivityModifiers === "accept"
  ] : [false, emptyMulticharIndex, emptyRegularIndex, false];
  const attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;
  const [pseudoClassesEnabled, paeudoClassesDefinitions, pseudoClassesAcceptUnknown] = syntaxDefinition.pseudoClasses ? [
    true,
    syntaxDefinition.pseudoClasses.definitions ? calculatePseudoClassSignatures(syntaxDefinition.pseudoClasses.definitions) : emptyPseudoClassSignatures,
    syntaxDefinition.pseudoClasses.unknown === "accept"
  ] : [false, emptyPseudoClassSignatures, false];
  const [pseudoElementsEnabled, pseudoElementsSingleColonNotationEnabled, pseudoElementsDoubleColonNotationEnabled, pseudoElementsIndex, pseudoElementsAcceptUnknown] = syntaxDefinition.pseudoElements ? [
    true,
    syntaxDefinition.pseudoElements.notation === "singleColon" || syntaxDefinition.pseudoElements.notation === "both",
    !syntaxDefinition.pseudoElements.notation || syntaxDefinition.pseudoElements.notation === "doubleColon" || syntaxDefinition.pseudoElements.notation === "both",
    syntaxDefinition.pseudoElements.definitions ? createRegularIndex(syntaxDefinition.pseudoElements.definitions) : emptyRegularIndex,
    syntaxDefinition.pseudoElements.unknown === "accept"
  ] : [false, false, false, emptyRegularIndex, false];
  let str = "";
  let l2 = str.length;
  let pos = 0;
  let chr = "";
  const is3 = (comparison) => chr === comparison;
  const isTagStart = () => is3("*") || isIdentStart(chr) || is3("\\");
  const rewind = (newPos) => {
    pos = newPos;
    chr = str.charAt(pos);
  };
  const next = () => {
    pos++;
    chr = str.charAt(pos);
  };
  const readAndNext = () => {
    const current = chr;
    pos++;
    chr = str.charAt(pos);
    return current;
  };
  function fail(errorMessage) {
    const position2 = Math.min(l2 - 1, pos);
    const error = new Error(`${errorPrefix}${errorMessage} Pos: ${position2}.`);
    error.position = position2;
    error.name = "ParserError";
    throw error;
  }
  function assert2(condition, errorMessage) {
    if (!condition) {
      return fail(errorMessage);
    }
  }
  const assertNonEof = () => {
    assert2(pos < l2, "Unexpected end of input.");
  };
  const isEof = () => pos >= l2;
  const pass = (character) => {
    assert2(pos < l2, `Expected "${character}" but end of input reached.`);
    assert2(chr === character, `Expected "${character}" but "${chr}" found.`);
    pos++;
    chr = str.charAt(pos);
  };
  function matchMulticharIndex(index2) {
    const match = matchMulticharIndexPos(index2, pos);
    if (match) {
      pos += match.length;
      chr = str.charAt(pos);
      return match;
    }
  }
  function matchMulticharIndexPos(index2, subPos) {
    const char = str.charAt(subPos);
    const charIndex = index2[char];
    if (charIndex) {
      const subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);
      if (subMatch) {
        return subMatch;
      }
      if (charIndex.self) {
        return charIndex.self;
      }
    }
  }
  function parseHex() {
    let hex = readAndNext();
    while (isHex(chr)) {
      hex += readAndNext();
    }
    if (is3(" ")) {
      next();
    }
    return String.fromCharCode(parseInt(hex, 16));
  }
  function parseString(quote) {
    let result = "";
    pass(quote);
    while (pos < l2) {
      if (is3(quote)) {
        next();
        return result;
      } else if (is3("\\")) {
        next();
        let esc;
        if (is3(quote)) {
          result += quote;
        } else if ((esc = stringEscapeChars[chr]) !== void 0) {
          result += esc;
        } else if (isHex(chr)) {
          result += parseHex();
          continue;
        } else {
          result += chr;
        }
      } else {
        result += chr;
      }
      next();
    }
    return result;
  }
  function parseIdentifier() {
    let result = "";
    while (pos < l2) {
      if (isIdent(chr)) {
        result += readAndNext();
      } else if (is3("\\")) {
        next();
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        return result;
      }
    }
    return result;
  }
  function parsePseudoClassString() {
    let result = "";
    while (pos < l2) {
      if (is3(")")) {
        break;
      } else if (is3("\\")) {
        next();
        if (isEof() && !strict) {
          return (result + "\\").trim();
        }
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        result += readAndNext();
      }
    }
    return result.trim();
  }
  function skipWhitespace() {
    while (whitespaceChars[chr]) {
      next();
    }
  }
  function parseSelector2(relative = false) {
    skipWhitespace();
    const rules = [parseRule(relative)];
    while (is3(",")) {
      next();
      skipWhitespace();
      rules.push(parseRule(relative));
    }
    return {
      type: "Selector",
      rules
    };
  }
  function parseAttribute() {
    pass("[");
    skipWhitespace();
    let attr2;
    if (is3("|")) {
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      next();
      attr2 = {
        type: "Attribute",
        name: parseIdentifier(),
        namespace: { type: "NoNamespace" }
      };
    } else if (is3("*")) {
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      assert2(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      next();
      pass("|");
      attr2 = {
        type: "Attribute",
        name: parseIdentifier(),
        namespace: { type: "WildcardNamespace" }
      };
    } else {
      const identifier = parseIdentifier();
      attr2 = {
        type: "Attribute",
        name: identifier
      };
      if (is3("|")) {
        const savedPos = pos;
        next();
        if (isIdentStart(chr) || is3("\\")) {
          assert2(namespaceEnabled, "Namespaces are not enabled.");
          attr2 = {
            type: "Attribute",
            name: parseIdentifier(),
            namespace: { type: "NamespaceName", name: identifier }
          };
        } else {
          rewind(savedPos);
        }
      }
    }
    assert2(attr2.name, "Expected attribute name.");
    skipWhitespace();
    if (isEof() && !strict) {
      return attr2;
    }
    if (is3("]")) {
      next();
    } else {
      attr2.operator = matchMulticharIndex(attributesOperatorsIndex);
      assert2(attr2.operator, "Expected a valid attribute selector operator.");
      skipWhitespace();
      assertNonEof();
      if (quoteChars[chr]) {
        attr2.value = {
          type: "String",
          value: parseString(chr)
        };
      } else if (substitutesEnabled && is3("$")) {
        next();
        attr2.value = {
          type: "Substitution",
          name: parseIdentifier()
        };
        assert2(attr2.value.name, "Expected substitute name.");
      } else {
        attr2.value = {
          type: "String",
          value: parseIdentifier()
        };
        assert2(attr2.value.value, "Expected attribute value.");
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return attr2;
      }
      if (!is3("]")) {
        attr2.caseSensitivityModifier = parseIdentifier();
        assert2(attr2.caseSensitivityModifier, "Expected end of attribute selector.");
        assert2(attributesCaseSensitivityModifiersEnabled, "Attribute case sensitivity modifiers are not enabled.");
        assert2(attributesAcceptUnknownCaseSensitivityModifiers || attributesCaseSensitivityModifiers[attr2.caseSensitivityModifier], "Unknown attribute case sensitivity modifier.");
        skipWhitespace();
        if (isEof() && !strict) {
          return attr2;
        }
      }
      pass("]");
    }
    return attr2;
  }
  function parseNumber() {
    let result = "";
    while (digitsChars[chr]) {
      result += readAndNext();
    }
    assert2(result !== "", "Formula parse error.");
    return parseInt(result);
  }
  const isNumberStart = () => is3("-") || is3("+") || digitsChars[chr];
  function parseFormula() {
    if (is3("e") || is3("o")) {
      const ident = parseIdentifier();
      if (ident === "even") {
        skipWhitespace();
        return [2, 0];
      }
      if (ident === "odd") {
        skipWhitespace();
        return [2, 1];
      }
    }
    let firstNumber = null;
    let firstNumberMultiplier = 1;
    if (is3("-")) {
      next();
      firstNumberMultiplier = -1;
    }
    if (isNumberStart()) {
      if (is3("+")) {
        next();
      }
      firstNumber = parseNumber();
      if (!is3("\\") && !is3("n")) {
        return [0, firstNumber * firstNumberMultiplier];
      }
    }
    if (firstNumber === null) {
      firstNumber = 1;
    }
    firstNumber *= firstNumberMultiplier;
    let identifier;
    if (is3("\\")) {
      next();
      if (isHex(chr)) {
        identifier = parseHex();
      } else {
        identifier = readAndNext();
      }
    } else {
      identifier = readAndNext();
    }
    assert2(identifier === "n", 'Formula parse error: expected "n".');
    skipWhitespace();
    if (is3("+") || is3("-")) {
      const sign = is3("+") ? 1 : -1;
      next();
      skipWhitespace();
      return [firstNumber, sign * parseNumber()];
    } else {
      return [firstNumber, 0];
    }
  }
  function parsePseudoClass(pseudoName) {
    const pseudo2 = {
      type: "PseudoClass",
      name: pseudoName
    };
    let pseudoDefinition = paeudoClassesDefinitions[pseudoName];
    if (!pseudoDefinition && pseudoClassesAcceptUnknown) {
      pseudoDefinition = defaultPseudoClassSignature;
    }
    assert2(pseudoDefinition, `Unknown pseudo-class: "${pseudoName}".`);
    pseudoDefinition = pseudoDefinition;
    if (is3("(")) {
      next();
      skipWhitespace();
      if (substitutesEnabled && is3("$")) {
        next();
        pseudo2.argument = {
          type: "Substitution",
          name: parseIdentifier()
        };
        assert2(pseudo2.argument.name, "Expected substitute name.");
      } else if (pseudoDefinition.type === "String") {
        pseudo2.argument = {
          type: "String",
          value: parsePseudoClassString()
        };
        assert2(pseudo2.argument.value, "Expected pseudo-class argument value.");
      } else if (pseudoDefinition.type === "Selector") {
        pseudo2.argument = parseSelector2(true);
      } else if (pseudoDefinition.type === "Formula") {
        const [a2, b2] = parseFormula();
        pseudo2.argument = {
          type: "Formula",
          a: a2,
          b: b2
        };
        if (pseudoDefinition.ofSelector) {
          skipWhitespace();
          if (is3("o") || is3("\\")) {
            const ident = parseIdentifier();
            assert2(ident === "of", "Formula of selector parse error.");
            skipWhitespace();
            pseudo2.argument = {
              type: "FormulaOfSelector",
              a: a2,
              b: b2,
              selector: parseRule()
            };
          }
        }
      } else {
        return fail("Invalid pseudo-class signature.");
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return pseudo2;
      }
      pass(")");
    } else {
      assert2(pseudoDefinition.optional, `Argument is required for pseudo-class "${pseudoName}".`);
    }
    return pseudo2;
  }
  function parseTagName() {
    if (is3("*")) {
      assert2(tagNameWildcardEnabled, "Wildcard tag name is not enabled.");
      next();
      return { type: "WildcardTag" };
    } else if (isIdentStart(chr) || is3("\\")) {
      assert2(tagNameEnabled, "Tag names are not enabled.");
      return {
        type: "TagName",
        name: parseIdentifier()
      };
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseTagNameWithNamespace() {
    if (is3("*")) {
      const savedPos = pos;
      next();
      if (!is3("|")) {
        rewind(savedPos);
        return parseTagName();
      }
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return parseTagName();
      }
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      assert2(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      const tagName = parseTagName();
      tagName.namespace = { type: "WildcardNamespace" };
      return tagName;
    } else if (is3("|")) {
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      next();
      const tagName = parseTagName();
      tagName.namespace = { type: "NoNamespace" };
      return tagName;
    } else if (isIdentStart(chr) || is3("\\")) {
      const identifier = parseIdentifier();
      if (!is3("|")) {
        assert2(tagNameEnabled, "Tag names are not enabled.");
        return {
          type: "TagName",
          name: identifier
        };
      }
      const savedPos = pos;
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return {
          type: "TagName",
          name: identifier
        };
      }
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      const tagName = parseTagName();
      tagName.namespace = { type: "NamespaceName", name: identifier };
      return tagName;
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseRule(relative = false) {
    const rule = {};
    let isRuleStart = true;
    if (relative) {
      const combinator = matchMulticharIndex(combinatorsIndex);
      if (combinator) {
        rule.combinator = combinator;
        skipWhitespace();
      }
    }
    while (pos < l2) {
      if (isTagStart()) {
        assert2(isRuleStart, "Unexpected tag/namespace start.");
        rule.tag = parseTagNameWithNamespace();
      } else if (is3("|")) {
        const savedPos = pos;
        next();
        if (isTagStart()) {
          assert2(isRuleStart, "Unexpected tag/namespace start.");
          rewind(savedPos);
          rule.tag = parseTagNameWithNamespace();
        } else {
          rewind(savedPos);
          break;
        }
      } else if (is3(".")) {
        assert2(classNamesEnabled, "Class names are not enabled.");
        next();
        const className2 = parseIdentifier();
        assert2(className2, "Expected class name.");
        (rule.classNames = rule.classNames || []).push(className2);
      } else if (is3("#")) {
        assert2(idEnabled, "IDs are not enabled.");
        next();
        const idName = parseIdentifier();
        assert2(idName, "Expected ID name.");
        (rule.ids = rule.ids || []).push(idName);
      } else if (is3("[")) {
        assert2(attributesEnabled, "Attributes are not enabled.");
        (rule.attributes = rule.attributes || []).push(parseAttribute());
      } else if (is3(":")) {
        let isDoubleColon = false;
        let isPseudoElement = false;
        next();
        if (is3(":")) {
          assert2(pseudoElementsEnabled, "Pseudo elements are not enabled.");
          assert2(pseudoElementsDoubleColonNotationEnabled, "Pseudo elements double colon notation is not enabled.");
          isDoubleColon = true;
          next();
        }
        const pseudoName = parseIdentifier();
        assert2(isDoubleColon || pseudoName, "Expected pseudo-class name.");
        assert2(!isDoubleColon || pseudoName, "Expected pseudo-element name.");
        assert2(!isDoubleColon || pseudoElementsAcceptUnknown || pseudoElementsIndex[pseudoName], `Unknown pseudo-element "${pseudoName}".`);
        isPseudoElement = pseudoElementsEnabled && (isDoubleColon || !isDoubleColon && pseudoElementsSingleColonNotationEnabled && pseudoElementsIndex[pseudoName]);
        if (isPseudoElement) {
          rule.pseudoElement = pseudoName;
          if (!whitespaceChars[chr] && !is3(",") && !is3(")") && !isEof()) {
            return fail("Pseudo-element should be the last component of a CSS selector rule.");
          }
        } else {
          assert2(pseudoClassesEnabled, "Pseudo classes are not enabled.");
          (rule.pseudoClasses = rule.pseudoClasses || []).push(parsePseudoClass(pseudoName));
        }
      } else {
        break;
      }
      isRuleStart = false;
    }
    if (isRuleStart) {
      if (isEof()) {
        return fail("Expected rule but end of input reached.");
      } else {
        return fail(`Expected rule but "${chr}" found.`);
      }
    }
    rule.type = "Rule";
    skipWhitespace();
    if (!isEof() && !is3(",") && !is3(")")) {
      const combinator = matchMulticharIndex(combinatorsIndex);
      skipWhitespace();
      rule.nestedRule = parseRule();
      rule.nestedRule.combinator = combinator;
    }
    return rule;
  }
  return (input) => {
    if (typeof input !== "string") {
      throw new Error(`${errorPrefix}Expected string input.`);
    }
    str = input;
    l2 = str.length;
    pos = 0;
    chr = str.charAt(0);
    return parseSelector2();
  };
}
const cssSelectorParse = createParser({ syntax: "selectors-4" });
function parse(selector2) {
  if (typeof selector2 !== "string") {
    throw new TypeError("Expected `string` as selector, not `" + selector2 + "`");
  }
  return cssSelectorParse(selector2);
}
const rtlRange = "---";
const ltrRange = "A-Za-z--------";
const rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
const ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  const source = String(value || "");
  return rtl.test(source) ? "rtl" : ltr.test(source) ? "ltr" : "neutral";
}
function toString(node2) {
  if ("children" in node2) {
    return all$2(node2);
  }
  return "value" in node2 ? node2.value : "";
}
function one$1(node2) {
  if (node2.type === "text") {
    return node2.value;
  }
  return "children" in node2 ? all$2(node2) : "";
}
function all$2(node2) {
  let index2 = -1;
  const result = [];
  while (++index2 < node2.children.length) {
    result[index2] = one$1(node2.children[index2]);
  }
  return result.join("");
}
function enterState(state, node2) {
  const schema = state.schema;
  const language = state.language;
  const currentDirection = state.direction;
  const editableOrEditingHost = state.editableOrEditingHost;
  let dirInferred;
  if (node2.type === "element") {
    const lang2 = node2.properties.xmlLang || node2.properties.lang;
    const type = node2.properties.type || "text";
    const dir2 = dirProperty(node2);
    if (lang2 !== null && lang2 !== void 0) {
      state.language = String(lang2);
    }
    if (schema && schema.space === "html") {
      if (node2.properties.contentEditable === "true") {
        state.editableOrEditingHost = true;
      }
      if (node2.tagName === "svg") {
        state.schema = svg;
      }
      if (dir2 === "rtl") {
        dirInferred = dir2;
      } else if (
        // Explicit `[dir=ltr]`.
        dir2 === "ltr" || // HTML with an invalid or no `[dir]`.
        dir2 !== "auto" && node2.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
        dir2 !== "auto" && node2.tagName === "input" && type === "tel"
      ) {
        dirInferred = "ltr";
      } else if (dir2 === "auto" || node2.tagName === "bdi") {
        if (node2.tagName === "textarea") {
          dirInferred = dirBidi(toString(node2));
        } else if (node2.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) {
          dirInferred = node2.properties.value ? dirBidi(String(node2.properties.value)) : "ltr";
        } else {
          visit(node2, inferDirectionality);
        }
      }
      if (dirInferred) {
        state.direction = dirInferred;
      }
    } else if (state.editableOrEditingHost) {
      state.editableOrEditingHost = false;
    }
  }
  return reset;
  function reset() {
    state.schema = schema;
    state.language = language;
    state.direction = currentDirection;
    state.editableOrEditingHost = editableOrEditingHost;
  }
  function inferDirectionality(child) {
    if (child.type === "text") {
      dirInferred = dirBidi(child.value);
      return dirInferred ? EXIT : void 0;
    }
    if (child !== node2 && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || dirProperty(child))) {
      return SKIP;
    }
  }
}
function dirBidi(value) {
  const result = direction(value);
  return result === "neutral" ? void 0 : result;
}
function dirProperty(node2) {
  const value = node2.type === "element" && typeof node2.properties.dir === "string" ? node2.properties.dir.toLowerCase() : void 0;
  return value === "auto" || value === "ltr" || value === "rtl" ? value : void 0;
}
function attributes(query, element2, schema) {
  let index2 = -1;
  if (query.attributes) {
    while (++index2 < query.attributes.length) {
      if (!attribute(query.attributes[index2], element2, schema)) {
        return false;
      }
    }
  }
  return true;
}
function attribute(query, element2, schema) {
  const info = find(schema, query.name);
  const propertyValue = element2.properties[info.property];
  let value = normalizeValue(propertyValue, info);
  if (!query.value) {
    return value !== void 0;
  }
  ok$1(query.value.type === "String");
  let key2 = query.value.value;
  if (query.caseSensitivityModifier === "i") {
    key2 = key2.toLowerCase();
    if (value) {
      value = value.toLowerCase();
    }
  }
  if (value !== void 0) {
    switch (query.operator) {
      case "=": {
        return key2 === value;
      }
      case "$=": {
        return key2 === value.slice(-key2.length);
      }
      case "*=": {
        return value.includes(key2);
      }
      case "^=": {
        return key2 === value.slice(0, key2.length);
      }
      case "|=": {
        return key2 === value || key2 === value.slice(0, key2.length) && value.charAt(key2.length) === "-";
      }
      case "~=": {
        return (
          // For all other values (including comma-separated lists), return whether this
          // is an exact match.
          key2 === value || // If this is a space-separated list, and the query is contained in it, return
          // true.
          parse$1(value).includes(key2)
        );
      }
    }
  }
  return false;
}
function normalizeValue(value, info) {
  if (value === null || value === void 0)
    ;
  else if (typeof value === "boolean") {
    if (value) {
      return info.attribute;
    }
  } else if (Array.isArray(value)) {
    if (value.length > 0) {
      return (info.commaSeparated ? stringify$1 : stringify)(value);
    }
  } else {
    return String(value);
  }
}
const emptyClassNames = [];
function className(query, element2) {
  const value = (
    /** @type {Readonly<Array<string>>} */
    element2.properties.className || emptyClassNames
  );
  let index2 = -1;
  if (query.classNames) {
    while (++index2 < query.classNames.length) {
      if (!value.includes(query.classNames[index2]))
        return false;
    }
  }
  return true;
}
function id(query, element2) {
  const ids = query.ids;
  return ids.length === 1 && element2.properties.id === ids[0];
}
function name(query, element2) {
  ok$1(query.tag);
  return query.tag.type === "WildcardTag" || query.tag.name === element2.tagName;
}
function factory(check, filter2) {
  return function(tags, ranges) {
    let left = cast(tags, "tag");
    const right = cast(
      ranges === null || ranges === void 0 ? "*" : ranges,
      "range"
    );
    const matches = [];
    let rightIndex = -1;
    while (++rightIndex < right.length) {
      const range = right[rightIndex].toLowerCase();
      if (!filter2 && range === "*")
        continue;
      let leftIndex = -1;
      const next = [];
      while (++leftIndex < left.length) {
        if (check(left[leftIndex].toLowerCase(), range)) {
          if (!filter2) {
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              left[leftIndex]
            );
          }
          matches.push(left[leftIndex]);
        } else {
          next.push(left[leftIndex]);
        }
      }
      left = next;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      filter2 ? matches : void 0
    );
  };
}
const extendedFilter = factory(function(tag, range) {
  const left = tag.split("-");
  const right = range.split("-");
  let leftIndex = 0;
  let rightIndex = 0;
  if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) {
    return false;
  }
  leftIndex++;
  rightIndex++;
  while (rightIndex < right.length) {
    if (right[rightIndex] === "*") {
      rightIndex++;
      continue;
    }
    if (!left[leftIndex])
      return false;
    if (left[leftIndex] === right[rightIndex]) {
      leftIndex++;
      rightIndex++;
      continue;
    }
    if (left[leftIndex].length === 1)
      return false;
    leftIndex++;
  }
  return true;
}, true);
function cast(values, name2) {
  const value = values && typeof values === "string" ? [values] : values;
  if (!value || typeof value !== "object" || !("length" in value)) {
    throw new Error(
      "Invalid " + name2 + " `" + value + "`, expected non-empty string"
    );
  }
  return value;
}
const own = {}.hasOwnProperty;
function hasProperty(node2, name2) {
  const value = node2.type === "element" && own.call(node2.properties, name2) && node2.properties[name2];
  return value !== null && value !== void 0 && value !== false;
}
const nthCheck = nthCheck$1.default || nthCheck$1;
const handle = zwitch("name", {
  handlers: {
    "any-link": anyLink,
    blank,
    checked,
    dir,
    disabled,
    empty: empty$1,
    enabled,
    "first-child": firstChild,
    "first-of-type": firstOfType,
    has,
    is,
    lang,
    "last-child": lastChild,
    "last-of-type": lastOfType,
    not,
    "nth-child": nthChild,
    "nth-last-child": nthLastChild,
    "nth-last-of-type": nthLastOfType,
    "nth-of-type": nthOfType,
    "only-child": onlyChild,
    "only-of-type": onlyOfType,
    optional,
    "read-only": readOnly,
    "read-write": readWrite,
    required,
    root,
    scope
  },
  invalid: invalidPseudo,
  unknown: unknownPseudo
});
function pseudo(query, element2, index2, parent, state) {
  const pseudos2 = query.pseudoClasses;
  let offset = -1;
  while (++offset < pseudos2.length) {
    if (!handle(pseudos2[offset], element2, index2, parent, state))
      return false;
  }
  return true;
}
function anyLink(_2, element2) {
  return (element2.tagName === "a" || element2.tagName === "area" || element2.tagName === "link") && hasProperty(element2, "href");
}
function assertDeep(state, query) {
  if (state.shallow) {
    throw new Error("Cannot use `:" + query.name + "` without parent");
  }
}
function blank(_2, element2) {
  return !someChildren(element2, check);
  function check(child) {
    return child.type === "element" || child.type === "text" && !whitespace(child);
  }
}
function checked(_2, element2) {
  if (element2.tagName === "input" || element2.tagName === "menuitem") {
    return Boolean(
      (element2.properties.type === "checkbox" || element2.properties.type === "radio") && hasProperty(element2, "checked")
    );
  }
  if (element2.tagName === "option") {
    return hasProperty(element2, "selected");
  }
  return false;
}
function dir(query, _1, _2, _3, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "String");
  return state.direction === query.argument.value;
}
function disabled(_2, element2) {
  return (element2.tagName === "button" || element2.tagName === "input" || element2.tagName === "select" || element2.tagName === "textarea" || element2.tagName === "optgroup" || element2.tagName === "option" || element2.tagName === "menuitem" || element2.tagName === "fieldset") && hasProperty(element2, "disabled");
}
function empty$1(_2, element2) {
  return !someChildren(element2, check);
  function check(child) {
    return child.type === "element" || child.type === "text";
  }
}
function enabled(query, element2) {
  return !disabled(query, element2);
}
function firstChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementIndex === 0;
}
function firstOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeIndex === 0;
}
function getCachedNthCheck(query) {
  let fn = query._cachedFn;
  if (!fn) {
    const value = query.argument;
    if (value.type !== "Formula") {
      throw new Error(
        "Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)"
      );
    }
    fn = nthCheck(value.a + "n+" + value.b);
    query._cachedFn = fn;
  }
  return fn;
}
function has(query, element2, _1, _2, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "Selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element2],
    // Do walk deep.
    shallow: false
  };
  walk(childState, { type: "root", children: element2.children });
  return childState.results.length > 0;
}
function invalidPseudo() {
}
function is(query, element2, _1, _2, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "Selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element2],
    // Do walk deep.
    shallow: false
  };
  walk(childState, element2);
  return childState.results[0] === element2;
}
function lang(query, _1, _2, _3, state) {
  ok$1(query.argument);
  ok$1(query.argument.type === "String");
  return state.language !== "" && state.language !== void 0 && extendedFilter(state.language, parse$2(query.argument.value)).length > 0;
}
function lastChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return Boolean(
    state.elementCount && state.elementIndex === state.elementCount - 1
  );
}
function lastOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
function not(query, element2, index2, parent, state) {
  return !is(query, element2, index2, parent, state);
}
function nthChild(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.elementIndex === "number" && fn(state.elementIndex);
}
function nthLastChild(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return Boolean(
    typeof state.elementCount === "number" && typeof state.elementIndex === "number" && fn(state.elementCount - state.elementIndex - 1)
  );
}
function nthLastOfType(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && fn(state.typeCount - 1 - state.typeIndex);
}
function nthOfType(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && fn(state.typeIndex);
}
function onlyChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementCount === 1;
}
function onlyOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeCount === 1;
}
function optional(query, element2) {
  return !required(query, element2);
}
function readOnly(query, element2, index2, parent, state) {
  return !readWrite(query, element2, index2, parent, state);
}
function readWrite(_2, element2, _1, _22, state) {
  return element2.tagName === "input" || element2.tagName === "textarea" ? !hasProperty(element2, "readOnly") && !hasProperty(element2, "disabled") : Boolean(state.editableOrEditingHost);
}
function required(_2, element2) {
  return (element2.tagName === "input" || element2.tagName === "textarea" || element2.tagName === "select") && hasProperty(element2, "required");
}
function root(_1, element2, _2, parent, state) {
  return Boolean(
    (!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element2.tagName === "html" || element2.tagName === "svg")
  );
}
function scope(_1, element2, _2, _3, state) {
  return state.scopeElements.includes(element2);
}
function someChildren(element2, check) {
  const children = element2.children;
  let index2 = -1;
  while (++index2 < children.length) {
    if (check(children[index2]))
      return true;
  }
  return false;
}
function unknownPseudo(query_) {
  const query = (
    /** @type {AstPseudoClass} */
    query_
  );
  throw new Error("Unknown pseudo-selector `" + query.name + "`");
}
function test$1(query, element2, index2, parent, state) {
  if (query.pseudoElement) {
    throw new Error("Invalid selector: `::" + query.pseudoElement + "`");
  }
  return Boolean(
    (!query.tag || name(query, element2)) && (!query.classNames || className(query, element2)) && (!query.ids || id(query, element2)) && (!query.attributes || attributes(query, element2, state.schema)) && (!query.pseudoClasses || pseudo(query, element2, index2, parent, state))
  );
}
const empty = [];
function walk(state, tree) {
  if (tree) {
    one(state, [], tree, void 0, void 0, tree);
  }
}
function add(nest, field, rule) {
  const list = nest[field];
  if (list) {
    list.push(rule);
  } else {
    nest[field] = [rule];
  }
}
function all$1(state, nest, node2, tree) {
  const fromParent = combine(nest.descendant, nest.directChild);
  let fromSibling;
  let index2 = -1;
  const total = { count: 0, types: /* @__PURE__ */ new Map() };
  const before2 = { count: 0, types: /* @__PURE__ */ new Map() };
  while (++index2 < node2.children.length) {
    count(total, node2.children[index2]);
  }
  index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    const name2 = child.type === "element" ? child.tagName.toUpperCase() : void 0;
    state.elementIndex = before2.count;
    state.typeIndex = name2 ? before2.types.get(name2) || 0 : 0;
    state.elementCount = total.count;
    state.typeCount = name2 ? total.types.get(name2) : 0;
    if ("children" in child) {
      const forSibling = combine(fromParent, fromSibling);
      const nest2 = one(
        state,
        forSibling,
        node2.children[index2],
        index2,
        node2,
        tree
      );
      fromSibling = combine(nest2.generalSibling, nest2.adjacentSibling);
    }
    if (state.one && state.found) {
      break;
    }
    count(before2, node2.children[index2]);
  }
}
function applySelectors(state, rules, node2, index2, parent) {
  const nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  let selectorIndex = -1;
  while (++selectorIndex < rules.length) {
    const rule = rules[selectorIndex];
    if (state.one && state.found) {
      break;
    }
    if (state.shallow && rule.nestedRule) {
      throw new Error("Expected selector without nesting");
    }
    if (test$1(rule, node2, index2, parent, state)) {
      const nest = rule.nestedRule;
      if (nest) {
        const label = nest.combinator === "+" ? "adjacentSibling" : nest.combinator === "~" ? "generalSibling" : nest.combinator === ">" ? "directChild" : "descendant";
        add(nestResult, label, nest);
      } else {
        state.found = true;
        if (!state.results.includes(node2)) {
          state.results.push(node2);
        }
      }
    }
    if (rule.combinator === void 0) {
      add(nestResult, "descendant", rule);
    } else if (rule.combinator === "~") {
      add(nestResult, "generalSibling", rule);
    }
  }
  return nestResult;
}
function combine(left, right) {
  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;
}
function count(counts, node2) {
  if (node2.type === "element") {
    const name2 = node2.tagName.toUpperCase();
    const count2 = (counts.types.get(name2) || 0) + 1;
    counts.count++;
    counts.types.set(name2, count2);
  }
}
function one(state, currentRules, node2, index2, parent, tree) {
  let nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  const exit = enterState(state, node2);
  if (node2.type === "element") {
    let rootRules = state.rootQuery.rules;
    if (parent && parent !== tree) {
      rootRules = state.rootQuery.rules.filter(
        (d2) => d2.combinator === void 0 || d2.combinator === ">" && parent === tree
      );
    }
    nestResult = applySelectors(
      state,
      // Try the root rules for this element too.
      combine(currentRules, rootRules),
      node2,
      index2,
      parent
    );
  }
  if ("children" in node2 && !state.shallow && !(state.one && state.found)) {
    all$1(state, nestResult, node2, tree);
  }
  exit();
  return nestResult;
}
function selectAll(selector2, tree, space) {
  const state = createState(selector2, tree, space);
  walk(state, tree || void 0);
  return state.results;
}
function createState(selector2, tree, space) {
  return {
    direction: "ltr",
    editableOrEditingHost: false,
    elementCount: void 0,
    elementIndex: void 0,
    found: false,
    language: void 0,
    one: false,
    // State of the query.
    results: [],
    rootQuery: parse(selector2),
    schema: space === "svg" ? svg : html$2,
    scopeElements: tree ? tree.type === "root" ? tree.children : [tree] : [],
    shallow: false,
    typeIndex: void 0,
    typeCount: void 0
  };
}
const remarkRewrite = (options2) => {
  const { selector: selector2, rewrite } = options2 || {};
  return (tree) => {
    if (!rewrite || typeof rewrite !== "function")
      return;
    if (selector2 && typeof selector2 === "string") {
      const selected = selectAll(selector2, tree);
      if (selected && selected.length > 0) {
        visit(tree, selected, (node2, index2, parent) => {
          rewrite(node2, index2, parent);
        });
      }
      return;
    }
    visit(tree, (node2, index2, parent) => {
      rewrite(node2, index2, parent);
    });
  };
};
const rehypeRewrite = remarkRewrite;
const resetStyles = "/**\n * Inline reset styles\n * These set common defaults for a consistent UI. Their comments will be automatically stripped by juice\n */\n/* default margin/padding, box sizing*/\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n/* height 100% all the way down */\ntable,\ntr,\ntd {\n  height: 100%;\n}\n\n/* img behavior - bicubic ms resizing, no border, fix space gap on gmail/hotmail */\nimg {\n  outline: none;\n  text-decoration: none;\n  -ms-interpolation-mode: bicubic;\n  display: block;\n}\n\na img {\n  border: none;\n}\n\n/* mso 07, 10 table spacing fix http://www.campaignmonitor.com/blog/post/3694/removing-spacing-from-around-tables-in-outlook-2007-and-2010 */\ntable {\n  border-collapse: collapse;\n  mso-table-lspace: 0pt;\n  mso-table-rspace: 0pt;\n}\n\n/* tel/sms links are unstyled by default */\na[href^=tel],\na[href^=sms] {\n  text-decoration: none;\n  pointer-events: none;\n  cursor: default;\n}";
const universalStyles = '/**\n * Originally based on The MailChimp Reset from Fabio Carneiro, MailChimp User Experience Design\n * More info and templates on Github: https://github.com/mailchimp/Email-Blueprints\n * http://www.mailchimp.com &amp; http://www.fabio-carneiro.com\n * These styles are non-inline; they impact UI added by email clients\n * By line:\n * (1) Force Outlook to provide a "view in browser" message\n * (2) Force Hotmail to display emails at full width\n * (3) Force Hotmail to display normal line spacing\n * (4) Prevent WebKit and Windows mobile changing default text sizes\n * (5) Remove spacing between tables in Outlook 2007 and up\n * (6) Remove table borders on MSO 07+ http://www.campaignmonitor.com/blog/post/3392/1px-borders-padding-on-table-cells-in-outlook-07/\n * (7) Specify bicubic resampling for MSO on img objects\n * (8) Media Query block - Pretty phone numbers in email: http://www.campaignmonitor.com/blog/post/3571/using-phone-numbers-in-html-email\n * (9) Media Query block - same as above, but for tablet sized devices\n */\n#outlook a {\n  padding: 0;\n}\n\n.ReadMsgBody {\n  width: 100%;\n}\n\n.ExternalClass {\n  width: 100%;\n}\n\n.ExternalClass,\n.ExternalClass p,\n.ExternalClass span,\n.ExternalClass font,\n.ExternalClass td,\n.ExternalClass div {\n  line-height: 100%;\n}\n\nbody,\ntable,\ntd,\np,\na,\nli,\nblockquote {\n  -webkit-text-size-adjust: 100%;\n  -ms-text-size-adjust: 100%;\n}\n\ntable,\ntd {\n  mso-table-lspace: 0pt;\n  mso-table-rspace: 0pt;\n}\n\ntable td {\n  border-collapse: collapse;\n}\n\nimg {\n  -ms-interpolation-mode: bicubic;\n}\n\n@media only screen and (max-device-width: 480px) {\n  a[href^=tel],\n  a[href^=sms] {\n    -webkit-text-decoration: default !important;\n            text-decoration: default !important;\n    pointer-events: auto !important;\n    cursor: default !important;\n  }\n}\n@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {\n  a[href^=tel],\n  a[href^=sms] {\n    -webkit-text-decoration: default !important;\n            text-decoration: default !important;\n    pointer-events: auto !important;\n    cursor: default !important;\n  }\n}';
const TAILWIND_CONFIG_PATH = "./tailwind.config.cjs";
const exec = async (name2, args) => {
  return new Promise((resolve, reject) => {
    const child = empty$5.spawn(name2, args);
    let stdout = dist.Buffer.alloc(0);
    let stderr = dist.Buffer.alloc(0);
    child.stdout.on("data", (data2) => {
      stdout = dist.Buffer.concat([stdout, data2]);
    });
    child.stderr.on("data", (data2) => {
      stderr = dist.Buffer.concat([stderr, data2]);
    });
    child.on("error", (error) => {
      reject({
        error,
        stdout: stdout.toString(),
        stderr: stderr.toString()
      });
    });
    child.on("close", (code2) => {
      if (code2 == null) {
        reject({
          error: new Error("Process exited with null exit code."),
          stdout: stdout.toString(),
          stderr: stderr.toString()
        });
        return;
      }
      resolve({
        exit_code: code2,
        stdout: stdout.toString(),
        stderr: stderr.toString()
      });
    });
  });
};
const createStyleNode = (css2) => {
  return {
    type: "element",
    tagName: "style",
    children: [{ type: "text", value: css2 }]
  };
};
const resolveCssVariables = (s2) => {
  const VARIABLE_DEF_REGEX = /(--[a-zA-Z0-9-_]+)\s*:\s(.+?);/g;
  const VARIABLE_USAGE_REGEX = /var\((\s*--[a-zA-Z0-9-_]+\s*)(?:\)|,\s*(.*)\))/;
  const defs = /* @__PURE__ */ new Map();
  let withoutDefs = s2.replace(VARIABLE_DEF_REGEX, (_2, def, value) => {
    defs.set(def.trim(), value.trim());
    return "";
  });
  const MAX_CYCLES = 1e3;
  let maxCycles = MAX_CYCLES;
  while (withoutDefs.match(VARIABLE_USAGE_REGEX)) {
    maxCycles--;
    if (maxCycles <= 0) {
      throw new Error("Max Cycles for replacement exceeded");
    }
    withoutDefs = withoutDefs.replace(
      VARIABLE_USAGE_REGEX,
      (_2, def, fallback) => {
        const d2 = def.trim();
        if (defs.has(d2)) {
          return defs.get(d2) ?? "";
        }
        return (fallback ?? "").trim();
      }
    );
  }
  return withoutDefs;
};
const hypeHtml = (html2, css2) => {
  const hyped = rehype().use(rehypeRewrite, {
    rewrite: (node2) => {
      var _a;
      if (node2.type !== "element") {
        return node2;
      }
      if (node2.tagName === "head") {
        if (css2 != null) {
          const tmp = [
            ...node2.children,
            ...css2.map((c2) => createStyleNode(c2))
          ];
          node2.children = tmp;
        }
      }
      node2.properties = {
        ...node2.properties,
        style: resolveCssVariables(`${((_a = node2.properties) == null ? void 0 : _a.style) ?? ""}`)
      };
    }
  }).use(rehypeStringify).processSync(html2).toString();
  return hyped;
};
const updateIgnoredPseudos = (css2) => {
  const PSEUDO_CLASSES_REGEX = new RegExp("(?<=\\:)[a-z0-9-]+(?=\\:)", "g");
  const foundPseudos = css2.match(PSEUDO_CLASSES_REGEX) || [];
  foundPseudos.forEach((pseudo2) => {
    if (!juice.ignoredPseudos.includes(pseudo2)) {
      juice.ignoredPseudos.push(pseudo2);
    }
  });
};
const inlineStyles = (html2, tailwindCss, extraCss) => {
  const juiceOptions = {
    inlinePseudoElements: true,
    preserveImportant: true,
    applyStyleTags: true,
    removeStyleTags: true,
    insertPreservedExtraCss: true,
    preservePseudos: true,
    preserveFontFaces: true,
    preserveMediaQueries: true,
    preserveKeyFrames: true
    // !BUG - this is not working
    // resolveCSSVariables: true,
  };
  updateIgnoredPseudos(tailwindCss);
  if (extraCss != null) {
    extraCss.forEach((css2) => {
      updateIgnoredPseudos(css2);
    });
  } else {
    extraCss = [];
  }
  const htmlWithCss = hypeHtml(html2, [tailwindCss]);
  const juiced = juice(htmlWithCss, juiceOptions);
  const hyped = hypeHtml(juiced, extraCss);
  return hyped;
};
const mailwindCss = async (inputHtml, options2) => {
  const tailwindCssPath = require.resolve("tailwindcss/lib/cli.js");
  const tailwindConfigPath = options2.tailwindConfigPath ?? TAILWIND_CONFIG_PATH;
  const tmpInputHtmlPath = path$1.join(browser.tmpdir(), "mailwind-input.html");
  empty$5.writeFileSync(tmpInputHtmlPath, inputHtml);
  const tmpInputCssPath = path$1.join(browser.tmpdir(), "mailwind-input.css");
  empty$5.writeFileSync(tmpInputCssPath, options2.css ?? "");
  const tmpTailwindCssPath = path$1.join(browser.tmpdir(), "mailwind-output.css");
  empty$5.writeFileSync(tmpTailwindCssPath, "");
  const args = [
    tailwindCssPath,
    "--config",
    tailwindConfigPath,
    "--output",
    tmpTailwindCssPath,
    "--content",
    tmpInputHtmlPath
  ];
  if (options2.css) {
    args.push("--input");
    args.push(tmpInputCssPath);
  }
  const result = await exec(dist.process.argv0, args);
  if (result.exit_code !== 0) {
    console.error("Failed to run Tailwind.");
    console.error(result.stderr);
    return;
  }
  const tailwindCss = empty$5.readFileSync(tmpTailwindCssPath, "utf-8") ?? "";
  return {
    html: inlineStyles(inputHtml, tailwindCss, [resetStyles, universalStyles]),
    css: tailwindCss
  };
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var assert = { exports: {} };
var errors = {};
var util = {};
var types = {};
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var hasSymbols$3 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$3() && !!Symbol.toStringTag;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$2 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$4 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a2, b2) {
  var arr = [];
  for (var i2 = 0; i2 < a2.length; i2 += 1) {
    arr[i2] = a2[i2];
  }
  for (var j2 = 0; j2 < b2.length; j2 += 1) {
    arr[j2 + a2.length] = b2[j2];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i2 = offset || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
    arr[j2] = arrLike[i2];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i2 = 0; i2 < arr.length; i2 += 1) {
    str += arr[i2];
    if (i2 + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$7 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$4.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs[i2] = "$" + i2;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation$6 = implementation$7;
var functionBind = Function.prototype.bind || implementation$6;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call, $hasOwn);
var undefined$1;
var $SyntaxError$1 = SyntaxError;
var $Function = Function;
var $TypeError$2 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$2();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols$2();
var hasProto2 = hasProto$1();
var getProto$1 = Object.getPrototypeOf || (hasProto2 ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto$1) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto$1(getProto$1(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto$1) {
      value = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn = hasown;
var $concat = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first2 = $strSlice(string, 0, 1);
  var last2 = $strSlice(string, -1);
  if (first2 === "%" && last2 !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first2 !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number2, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$2("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first2 = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$2("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i2 + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$2 = { exports: {} };
var GetIntrinsic$4 = getIntrinsic;
var $defineProperty$1 = GetIntrinsic$4("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors() {
  if ($defineProperty$1) {
    try {
      $defineProperty$1({}, "a", { value: 1 });
      return true;
    } catch (e2) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty$1([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var GetIntrinsic$3 = getIntrinsic;
var $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e2) {
    $gOPD = null;
  }
}
var gopd$1 = $gOPD;
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var GetIntrinsic$2 = getIntrinsic;
var $defineProperty = hasPropertyDescriptors2 && GetIntrinsic$2("%Object.defineProperty%", true);
if ($defineProperty) {
  try {
    $defineProperty({}, "a", { value: 1 });
  } catch (e2) {
    $defineProperty = false;
  }
}
var $SyntaxError = GetIntrinsic$2("%SyntaxError%");
var $TypeError$1 = GetIntrinsic$2("%TypeError%");
var gopd = gopd$1;
var defineDataProperty = function defineDataProperty2(obj, property2, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$1("`obj` must be an object or a function`");
  }
  if (typeof property2 !== "string" && typeof property2 !== "symbol") {
    throw new $TypeError$1("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property2);
  if ($defineProperty) {
    $defineProperty(obj, property2, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property2] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var GetIntrinsic$1 = getIntrinsic;
var define = defineDataProperty;
var hasDescriptors = hasPropertyDescriptors_1();
var gOPD$1 = gopd$1;
var $TypeError = GetIntrinsic$1("%TypeError%");
var $floor = GetIntrinsic$1("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length) {
  if (typeof fn !== "function") {
    throw new $TypeError("`fn` is not a function");
  }
  if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
    throw new $TypeError("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD$1) {
    var desc = gOPD$1(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(fn, "length", length, true, true);
    } else {
      define(fn, "length", length);
    }
  }
  return fn;
};
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = GetIntrinsic3("%TypeError%");
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty2 = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind3, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$2);
var callBindExports = callBind$2.exports;
var GetIntrinsic2 = getIntrinsic;
var callBind$1 = callBindExports;
var $indexOf$1 = callBind$1(GetIntrinsic2("String.prototype.indexOf"));
var callBound$3 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic2(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$1(name2, ".prototype.") > -1) {
    return callBind$1(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$3 = shams();
var callBound$2 = callBound$3;
var $toString$1 = callBound$2("Object.prototype.toString");
var isStandardArguments = function isArguments(value) {
  if (hasToStringTag$3 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments2(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var toStr$3 = Object.prototype.toString;
var fnToStr$1 = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag$2 = shams();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
  if (!hasToStringTag$2) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e2) {
  }
};
var GeneratorFunction;
var isGeneratorFunction = function isGeneratorFunction2(fn) {
  if (typeof fn !== "function") {
    return false;
  }
  if (isFnRegex.test(fnToStr$1.call(fn))) {
    return true;
  }
  if (!hasToStringTag$2) {
    var str = toStr$3.call(fn);
    return str === "[object GeneratorFunction]";
  }
  if (!getProto) {
    return false;
  }
  if (typeof GeneratorFunction === "undefined") {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
  }
  return getProto(fn) === GeneratorFunction;
};
var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (_2) {
    if (_2 !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e2) {
    return false;
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$2 = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]";
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]";
var hasToStringTag$1 = typeof Symbol === "function" && !!Symbol.toStringTag;
var isIE68 = !(0 in [,]);
var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === "object") {
  var all = document.all;
  if (toStr$2.call(all) === toStr$2.call(document.all)) {
    isDDA = function isDocumentDotAll2(value) {
      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
        try {
          var str = toStr$2.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
        } catch (e2) {
        }
      }
      return false;
    };
  }
}
var isCallable$1 = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e2) {
    if (e2 !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable2(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (hasToStringTag$1) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass = toStr$2.call(value);
  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
    return false;
  }
  return tryFunctionObject(value);
};
var isCallable3 = isCallable$1;
var toStr$1 = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray2(array, iterator, receiver) {
  for (var i2 = 0, len = array.length; i2 < len; i2++) {
    if (hasOwnProperty.call(array, i2)) {
      if (receiver == null) {
        iterator(array[i2], i2, array);
      } else {
        iterator.call(receiver, array[i2], i2, array);
      }
    }
  }
};
var forEachString = function forEachString2(string, iterator, receiver) {
  for (var i2 = 0, len = string.length; i2 < len; i2++) {
    if (receiver == null) {
      iterator(string.charAt(i2), i2, string);
    } else {
      iterator.call(receiver, string.charAt(i2), i2, string);
    }
  }
};
var forEachObject = function forEachObject2(object, iterator, receiver) {
  for (var k2 in object) {
    if (hasOwnProperty.call(object, k2)) {
      if (receiver == null) {
        iterator(object[k2], k2, object);
      } else {
        iterator.call(receiver, object[k2], k2, object);
      }
    }
  }
};
var forEach$1 = function forEach(list, iterator, thisArg) {
  if (!isCallable3(iterator)) {
    throw new TypeError("iterator must be a function");
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr$1.call(list) === "[object Array]") {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === "string") {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};
var forEach_1 = forEach$1;
var possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$1 = function availableTypedArrays() {
  var out = [];
  for (var i2 = 0; i2 < possibleNames.length; i2++) {
    if (typeof g$2[possibleNames[i2]] === "function") {
      out[out.length] = possibleNames[i2];
    }
  }
  return out;
};
var forEach2 = forEach_1;
var availableTypedArrays2 = availableTypedArrays$1;
var callBind = callBindExports;
var callBound$1 = callBound$3;
var gOPD = gopd$1;
var $toString = callBound$1("Object.prototype.toString");
var hasToStringTag = shams();
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays2();
var $slice = callBound$1("String.prototype.slice");
var getPrototypeOf = Object.getPrototypeOf;
var $indexOf = callBound$1("Array.prototype.indexOf", true) || function indexOf(array, value) {
  for (var i2 = 0; i2 < array.length; i2 += 1) {
    if (array[i2] === value) {
      return i2;
    }
  }
  return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach2(typedArrays, function(typedArray) {
    var arr = new g$1[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto2 = getPrototypeOf(arr);
      var descriptor = gOPD(proto2, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf(proto2);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      cache["$" + typedArray] = callBind(descriptor.get);
    }
  });
} else {
  forEach2(typedArrays, function(typedArray) {
    var arr = new g$1[typedArray]();
    var fn = arr.slice || arr.set;
    if (fn) {
      cache["$" + typedArray] = callBind(fn);
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var found = false;
  forEach2(cache, function(getter, typedArray) {
    if (!found) {
      try {
        if ("$" + getter(value) === typedArray) {
          found = $slice(typedArray, 1);
        }
      } catch (e2) {
      }
    }
  });
  return found;
};
var trySlices = function tryAllSlices(value) {
  var found = false;
  forEach2(cache, function(getter, name2) {
    if (!found) {
      try {
        getter(value);
        found = $slice(name2, 1);
      } catch (e2) {
      }
    }
  });
  return found;
};
var whichTypedArray$1 = function whichTypedArray(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (!hasToStringTag) {
    var tag = $slice($toString(value), 8, -1);
    if ($indexOf(typedArrays, tag) > -1) {
      return tag;
    }
    if (tag !== "Object") {
      return false;
    }
    return trySlices(value);
  }
  if (!gOPD) {
    return null;
  }
  return tryTypedArrays(value);
};
var whichTypedArray2 = whichTypedArray$1;
var isTypedArray = function isTypedArray2(value) {
  return !!whichTypedArray2(value);
};
(function(exports2) {
  var isArgumentsObject = isArguments$1;
  var isGeneratorFunction$1 = isGeneratorFunction;
  var whichTypedArray3 = whichTypedArray$1;
  var isTypedArray$1 = isTypedArray;
  function uncurryThis(f2) {
    return f2.call.bind(f2);
  }
  var BigIntSupported = typeof BigInt !== "undefined";
  var SymbolSupported = typeof Symbol !== "undefined";
  var ObjectToString = uncurryThis(Object.prototype.toString);
  var numberValue = uncurryThis(Number.prototype.valueOf);
  var stringValue = uncurryThis(String.prototype.valueOf);
  var booleanValue = uncurryThis(Boolean.prototype.valueOf);
  if (BigIntSupported) {
    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
  }
  if (SymbolSupported) {
    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
  }
  function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") {
      return false;
    }
    try {
      prototypeValueOf(value);
      return true;
    } catch (e2) {
      return false;
    }
  }
  exports2.isArgumentsObject = isArgumentsObject;
  exports2.isGeneratorFunction = isGeneratorFunction$1;
  exports2.isTypedArray = isTypedArray$1;
  function isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
  }
  exports2.isPromise = isPromise;
  function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value);
    }
    return isTypedArray$1(value) || isDataView(value);
  }
  exports2.isArrayBufferView = isArrayBufferView;
  function isUint8Array2(value) {
    return whichTypedArray3(value) === "Uint8Array";
  }
  exports2.isUint8Array = isUint8Array2;
  function isUint8ClampedArray(value) {
    return whichTypedArray3(value) === "Uint8ClampedArray";
  }
  exports2.isUint8ClampedArray = isUint8ClampedArray;
  function isUint16Array(value) {
    return whichTypedArray3(value) === "Uint16Array";
  }
  exports2.isUint16Array = isUint16Array;
  function isUint32Array(value) {
    return whichTypedArray3(value) === "Uint32Array";
  }
  exports2.isUint32Array = isUint32Array;
  function isInt8Array(value) {
    return whichTypedArray3(value) === "Int8Array";
  }
  exports2.isInt8Array = isInt8Array;
  function isInt16Array(value) {
    return whichTypedArray3(value) === "Int16Array";
  }
  exports2.isInt16Array = isInt16Array;
  function isInt32Array(value) {
    return whichTypedArray3(value) === "Int32Array";
  }
  exports2.isInt32Array = isInt32Array;
  function isFloat32Array(value) {
    return whichTypedArray3(value) === "Float32Array";
  }
  exports2.isFloat32Array = isFloat32Array;
  function isFloat64Array(value) {
    return whichTypedArray3(value) === "Float64Array";
  }
  exports2.isFloat64Array = isFloat64Array;
  function isBigInt64Array(value) {
    return whichTypedArray3(value) === "BigInt64Array";
  }
  exports2.isBigInt64Array = isBigInt64Array;
  function isBigUint64Array(value) {
    return whichTypedArray3(value) === "BigUint64Array";
  }
  exports2.isBigUint64Array = isBigUint64Array;
  function isMapToString(value) {
    return ObjectToString(value) === "[object Map]";
  }
  isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
  function isMap(value) {
    if (typeof Map === "undefined") {
      return false;
    }
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
  }
  exports2.isMap = isMap;
  function isSetToString(value) {
    return ObjectToString(value) === "[object Set]";
  }
  isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
  function isSet(value) {
    if (typeof Set === "undefined") {
      return false;
    }
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
  }
  exports2.isSet = isSet;
  function isWeakMapToString(value) {
    return ObjectToString(value) === "[object WeakMap]";
  }
  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
  function isWeakMap(value) {
    if (typeof WeakMap === "undefined") {
      return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
  }
  exports2.isWeakMap = isWeakMap;
  function isWeakSetToString(value) {
    return ObjectToString(value) === "[object WeakSet]";
  }
  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
  function isWeakSet(value) {
    return isWeakSetToString(value);
  }
  exports2.isWeakSet = isWeakSet;
  function isArrayBufferToString(value) {
    return ObjectToString(value) === "[object ArrayBuffer]";
  }
  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
  function isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") {
      return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
  }
  exports2.isArrayBuffer = isArrayBuffer;
  function isDataViewToString(value) {
    return ObjectToString(value) === "[object DataView]";
  }
  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
  function isDataView(value) {
    if (typeof DataView === "undefined") {
      return false;
    }
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
  }
  exports2.isDataView = isDataView;
  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
  function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === "[object SharedArrayBuffer]";
  }
  function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === "undefined") {
      return false;
    }
    if (typeof isSharedArrayBufferToString.working === "undefined") {
      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
  }
  exports2.isSharedArrayBuffer = isSharedArrayBuffer;
  function isAsyncFunction(value) {
    return ObjectToString(value) === "[object AsyncFunction]";
  }
  exports2.isAsyncFunction = isAsyncFunction;
  function isMapIterator(value) {
    return ObjectToString(value) === "[object Map Iterator]";
  }
  exports2.isMapIterator = isMapIterator;
  function isSetIterator(value) {
    return ObjectToString(value) === "[object Set Iterator]";
  }
  exports2.isSetIterator = isSetIterator;
  function isGeneratorObject(value) {
    return ObjectToString(value) === "[object Generator]";
  }
  exports2.isGeneratorObject = isGeneratorObject;
  function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === "[object WebAssembly.Module]";
  }
  exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
  function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
  }
  exports2.isNumberObject = isNumberObject;
  function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
  }
  exports2.isStringObject = isStringObject;
  function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
  }
  exports2.isBooleanObject = isBooleanObject;
  function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
  }
  exports2.isBigIntObject = isBigIntObject;
  function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
  }
  exports2.isSymbolObject = isSymbolObject;
  function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
  }
  exports2.isBoxedPrimitive = isBoxedPrimitive;
  function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
  }
  exports2.isAnyArrayBuffer = isAnyArrayBuffer;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
    Object.defineProperty(exports2, method, {
      enumerable: false,
      value: function() {
        throw new Error(method + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function isBuffer(arg) {
  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
(function(exports2) {
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
    var keys2 = Object.keys(obj);
    var descriptors = {};
    for (var i2 = 0; i2 < keys2.length; i2++) {
      descriptors[keys2[i2]] = Object.getOwnPropertyDescriptor(obj, keys2[i2]);
    }
    return descriptors;
  };
  var formatRegExp = /%[sdj%]/g;
  exports2.format = function(f2) {
    if (!isString(f2)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f2).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i2 >= len)
        return x3;
      switch (x3) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_2) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
      if (isNull(x2) || !isObject(x2)) {
        str += " " + x2;
      } else {
        str += " " + inspect(x2);
      }
    }
    return str;
  };
  exports2.deprecate = function(fn, msg) {
    if (typeof dist.process !== "undefined" && dist.process.noDeprecation === true) {
      return fn;
    }
    if (typeof dist.process === "undefined") {
      return function() {
        return exports2.deprecate(fn, msg).apply(this, arguments);
      };
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (dist.process.throwDeprecation) {
          throw new Error(msg);
        } else if (dist.process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnvRegex = /^$/;
  if (dist.process.env.NODE_DEBUG) {
    var debugEnv = dist.process.env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
    debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
  }
  exports2.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (debugEnvRegex.test(set)) {
        var pid = dist.process.pid;
        debugs[set] = function() {
          var msg = exports2.format.apply(exports2, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  };
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports2._extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports2.inspect = inspect;
  inspect.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style2 = inspect.styles[styleType];
    if (style2) {
      return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val2, idx) {
      hash[val2] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys2.length === 0) {
      if (isFunction(value)) {
        var name2 = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name2 + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base2 = "", array = false, braces = ["{", "}"];
    if (isArray3(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction(value)) {
      var n2 = value.name ? ": " + value.name : "";
      base2 = " [Function" + n2 + "]";
    }
    if (isRegExp(value)) {
      base2 = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base2 = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base2 = " " + formatError(value);
    }
    if (keys2.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base2 + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key2) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base2, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) {
      if (hasOwnProperty2(value, String(i2))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i2),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key2) {
      if (!key2.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key2,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
    var name2, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty2(visibleKeys, key2)) {
      name2 = "[" + key2 + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").slice(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name2)) {
      if (array && key2.match(/^\d+$/)) {
        return str;
      }
      name2 = JSON.stringify("" + key2);
      if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name2 = name2.slice(1, -1);
        name2 = ctx.stylize(name2, "name");
      } else {
        name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name2 = ctx.stylize(name2, "string");
      }
    }
    return name2 + ": " + str;
  }
  function reduceToSingleString(output, base2, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
  }
  exports2.types = types;
  function isArray3(ar) {
    return Array.isArray(ar);
  }
  exports2.isArray = isArray3;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re2) {
    return isObject(re2) && objectToString(re2) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  exports2.types.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d2) {
    return isObject(d2) && objectToString(d2) === "[object Date]";
  }
  exports2.isDate = isDate;
  exports2.types.isDate = isDate;
  function isError(e2) {
    return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
  }
  exports2.isError = isError;
  exports2.types.isNativeError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = isBufferBrowser;
  function objectToString(o2) {
    return Object.prototype.toString.call(o2);
  }
  function pad(n2) {
    return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp() {
    var d2 = /* @__PURE__ */ new Date();
    var time = [
      pad(d2.getHours()),
      pad(d2.getMinutes()),
      pad(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time].join(" ");
  }
  exports2.log = function() {
    console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
  };
  exports2.inherits = inherits_browserExports;
  exports2._extend = function(origin, add2) {
    if (!add2 || !isObject(add2))
      return origin;
    var keys2 = Object.keys(add2);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add2[keys2[i2]];
    }
    return origin;
  };
  function hasOwnProperty2(obj, prop2) {
    return Object.prototype.hasOwnProperty.call(obj, prop2);
  }
  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
  exports2.promisify = function promisify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function") {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }
    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function(resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      var args = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args.push(arguments[i2]);
      }
      args.push(function(err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
    return Object.defineProperties(
      fn,
      getOwnPropertyDescriptors(original)
    );
  };
  exports2.promisify.custom = kCustomPromisifiedSymbol;
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function callbackified() {
      var args = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args.push(arguments[i2]);
      }
      var maybeCb = args.pop();
      if (typeof maybeCb !== "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var self2 = this;
      var cb = function() {
        return maybeCb.apply(self2, arguments);
      };
      original.apply(this, args).then(
        function(ret) {
          dist.process.nextTick(cb.bind(null, null, ret));
        },
        function(rej) {
          dist.process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        }
      );
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(
      callbackified,
      getOwnPropertyDescriptors(original)
    );
    return callbackified;
  }
  exports2.callbackify = callbackify;
})(util);
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors)
    return errors;
  hasRequiredErrors = 1;
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return _typeof(key2) === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    } else if (call2 !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf(o2);
  }
  var codes = {};
  var assert2;
  var util$1;
  function createErrorType(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inherits(NodeError2, _Base);
      var _super = _createSuper(NodeError2);
      function NodeError2(arg1, arg2, arg3) {
        var _this;
        _classCallCheck(this, NodeError2);
        _this = _super.call(this, getMessage(arg1, arg2, arg3));
        _this.code = code2;
        return _this;
      }
      return _createClass(NodeError2);
    }(Base);
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i2) {
        return String(i2);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search2, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search2.length) === search2;
  }
  function endsWith(str, search2, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search2.length, this_len) === search2;
  }
  function includes(str, search2, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search2.length > str.length) {
      return false;
    } else {
      return str.indexOf(search2, start) !== -1;
    }
  }
  createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    if (assert2 === void 0)
      assert2 = requireAssert();
    assert2(typeof name2 === "string", "'name' must be a string");
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name2, " argument")) {
      msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type = includes(name2, ".") ? "property" : "argument";
      msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_VALUE", function(name2, value) {
    var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    if (util$1 === void 0)
      util$1 = util;
    var inspected = util$1.inspect(value);
    if (inspected.length > 128) {
      inspected = "".concat(inspected.slice(0, 128), "...");
    }
    return "The argument '".concat(name2, "' ").concat(reason, ". Received ").concat(inspected);
  }, TypeError);
  createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name2, value) {
    var type;
    if (value && value.constructor && value.constructor.name) {
      type = "instance of ".concat(value.constructor.name);
    } else {
      type = "type ".concat(_typeof(value));
    }
    return "Expected ".concat(input, ' to be returned from the "').concat(name2, '"') + " function but got ".concat(type, ".");
  }, TypeError);
  createErrorType("ERR_MISSING_ARGS", function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (assert2 === void 0)
      assert2 = requireAssert();
    assert2(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a2) {
      return '"'.concat(a2, '"');
    });
    switch (len) {
      case 1:
        msg += "".concat(args[0], " argument");
        break;
      case 2:
        msg += "".concat(args[0], " and ").concat(args[1], " arguments");
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and ".concat(args[len - 1], " arguments");
        break;
    }
    return "".concat(msg, " must be specified");
  }, TypeError);
  errors.codes = codes;
  return errors;
}
var assertion_error;
var hasRequiredAssertion_error;
function requireAssertion_error() {
  if (hasRequiredAssertion_error)
    return assertion_error;
  hasRequiredAssertion_error = 1;
  function ownKeys(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _defineProperty(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return _typeof(key2) === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    } else if (call2 !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf(o2);
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  var _require = util, inspect = _require.inspect;
  var _require2 = requireErrors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
  function endsWith(str, search2, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search2.length, this_len) === search2;
  }
  function repeat(str, count2) {
    count2 = Math.floor(count2);
    if (str.length == 0 || count2 == 0)
      return "";
    var maxCount = str.length * count2;
    count2 = Math.floor(Math.log(count2) / Math.log(2));
    while (count2) {
      str += str;
      count2--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
  }
  var blue = "";
  var green = "";
  var red = "";
  var white = "";
  var kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  };
  var kMaxShortLength = 10;
  function copyError(source) {
    var keys2 = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys2.forEach(function(key2) {
      target[key2] = source[key2];
    });
    Object.defineProperty(target, "message", {
      value: source.message
    });
    return target;
  }
  function inspectValue(val2) {
    return inspect(val2, {
      compact: false,
      customInspect: false,
      depth: 1e3,
      maxArrayLength: Infinity,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: false,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: Infinity,
      // Assert does not detect proxies currently.
      showProxy: false,
      sorted: true,
      // Inspect getters as we also check them when comparing entries.
      getters: true
    });
  }
  function createErrDiff(actual, expected, operator) {
    var other = "";
    var res = "";
    var lastPos = 0;
    var end2 = "";
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split("\n");
    var expectedLines = inspectValue(expected).split("\n");
    var i2 = 0;
    var indicator = "";
    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
      operator = "strictEqualObject";
    }
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
      var inputLength = actualLines[0].length + expectedLines[0].length;
      if (inputLength <= kMaxShortLength) {
        if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
          return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        }
      } else if (operator !== "strictEqualObject") {
        var maxLength = dist.process.stderr && dist.process.stderr.isTTY ? dist.process.stderr.columns : 80;
        if (inputLength < maxLength) {
          while (actualLines[0][i2] === expectedLines[0][i2]) {
            i2++;
          }
          if (i2 > 2) {
            indicator = "\n  ".concat(repeat(" ", i2), "^");
            i2 = 0;
          }
        }
      }
    }
    var a2 = actualLines[actualLines.length - 1];
    var b2 = expectedLines[expectedLines.length - 1];
    while (a2 === b2) {
      if (i2++ < 2) {
        end2 = "\n  ".concat(a2).concat(end2);
      } else {
        other = a2;
      }
      actualLines.pop();
      expectedLines.pop();
      if (actualLines.length === 0 || expectedLines.length === 0)
        break;
      a2 = actualLines[actualLines.length - 1];
      b2 = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length);
    if (maxLines === 0) {
      var _actualLines = actualInspected.split("\n");
      if (_actualLines.length > 30) {
        _actualLines[26] = "".concat(blue, "...").concat(white);
        while (_actualLines.length > 27) {
          _actualLines.pop();
        }
      }
      return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
    }
    if (i2 > 3) {
      end2 = "\n".concat(blue, "...").concat(white).concat(end2);
      skipped = true;
    }
    if (other !== "") {
      end2 = "\n  ".concat(other).concat(end2);
      other = "";
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for (i2 = 0; i2 < maxLines; i2++) {
      var cur = i2 - lastPos;
      if (actualLines.length < i2 + 1) {
        if (cur > 1 && i2 > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(expectedLines[i2 - 2]);
            printedLines++;
          }
          res += "\n  ".concat(expectedLines[i2 - 1]);
          printedLines++;
        }
        lastPos = i2;
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i2]);
        printedLines++;
      } else if (expectedLines.length < i2 + 1) {
        if (cur > 1 && i2 > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i2 - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i2 - 1]);
          printedLines++;
        }
        lastPos = i2;
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i2]);
        printedLines++;
      } else {
        var expectedLine = expectedLines[i2];
        var actualLine = actualLines[i2];
        var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
        if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
          divergingLines = false;
          actualLine += ",";
        }
        if (divergingLines) {
          if (cur > 1 && i2 > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i2 - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i2 - 1]);
            printedLines++;
          }
          lastPos = i2;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
          printedLines += 2;
        } else {
          res += other;
          other = "";
          if (cur === 1 || i2 === 0) {
            res += "\n  ".concat(actualLine);
            printedLines++;
          }
        }
      }
      if (printedLines > 20 && i2 < maxLines - 2) {
        return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
      }
    }
    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end2).concat(indicator);
  }
  var AssertionError = /* @__PURE__ */ function(_Error, _inspect$custom) {
    _inherits(AssertionError2, _Error);
    var _super = _createSuper(AssertionError2);
    function AssertionError2(options2) {
      var _this;
      _classCallCheck(this, AssertionError2);
      if (_typeof(options2) !== "object" || options2 === null) {
        throw new ERR_INVALID_ARG_TYPE("options", "Object", options2);
      }
      var message = options2.message, operator = options2.operator, stackStartFn = options2.stackStartFn;
      var actual = options2.actual, expected = options2.expected;
      var limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      if (message != null) {
        _this = _super.call(this, String(message));
      } else {
        if (dist.process.stderr && dist.process.stderr.isTTY) {
          if (dist.process.stderr && dist.process.stderr.getColorDepth && dist.process.stderr.getColorDepth() !== 1) {
            blue = "\x1B[34m";
            green = "\x1B[32m";
            white = "\x1B[39m";
            red = "\x1B[31m";
          } else {
            blue = "";
            green = "";
            white = "";
            red = "";
          }
        }
        if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
          actual = copyError(actual);
          expected = copyError(expected);
        }
        if (operator === "deepStrictEqual" || operator === "strictEqual") {
          _this = _super.call(this, createErrDiff(actual, expected, operator));
        } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
          var base2 = kReadableOperator[operator];
          var res = inspectValue(actual).split("\n");
          if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
            base2 = kReadableOperator.notStrictEqualObject;
          }
          if (res.length > 30) {
            res[26] = "".concat(blue, "...").concat(white);
            while (res.length > 27) {
              res.pop();
            }
          }
          if (res.length === 1) {
            _this = _super.call(this, "".concat(base2, " ").concat(res[0]));
          } else {
            _this = _super.call(this, "".concat(base2, "\n\n").concat(res.join("\n"), "\n"));
          }
        } else {
          var _res = inspectValue(actual);
          var other = "";
          var knownOperators = kReadableOperator[operator];
          if (operator === "notDeepEqual" || operator === "notEqual") {
            _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
            if (_res.length > 1024) {
              _res = "".concat(_res.slice(0, 1021), "...");
            }
          } else {
            other = "".concat(inspectValue(expected));
            if (_res.length > 512) {
              _res = "".concat(_res.slice(0, 509), "...");
            }
            if (other.length > 512) {
              other = "".concat(other.slice(0, 509), "...");
            }
            if (operator === "deepEqual" || operator === "equal") {
              _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
            } else {
              other = " ".concat(operator, " ").concat(other);
            }
          }
          _this = _super.call(this, "".concat(_res).concat(other));
        }
      }
      Error.stackTraceLimit = limit;
      _this.generatedMessage = !message;
      Object.defineProperty(_assertThisInitialized(_this), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: false,
        writable: true,
        configurable: true
      });
      _this.code = "ERR_ASSERTION";
      _this.actual = actual;
      _this.expected = expected;
      _this.operator = operator;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
      }
      _this.stack;
      _this.name = "AssertionError";
      return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError2, [{
      key: "toString",
      value: function toString2() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: _inspect$custom,
      value: function value(recurseTimes, ctx) {
        return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
          customInspect: false,
          depth: 0
        }));
      }
    }]);
    return AssertionError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error), inspect.custom);
  assertion_error = AssertionError;
  return assertion_error;
}
var toStr = Object.prototype.toString;
var isArguments3 = function isArguments4(value) {
  var str = toStr.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$5;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$5;
  hasRequiredImplementation$1 = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments3;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o2) {
      var ctor = o2.constructor;
      return ctor && ctor.prototype === o2;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k2 in window) {
        try {
          if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
            try {
              equalsConstructorPrototype(window[k2]);
            } catch (e2) {
              return true;
            }
          }
        } catch (e2) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o2) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o2);
      }
      try {
        return equalsConstructorPrototype(o2);
      } catch (e2) {
        return false;
      }
    };
    keysShim2 = function keys2(object) {
      var isObject = object !== null && typeof object === "object";
      var isFunction = toStr2.call(object) === "[object Function]";
      var isArguments5 = isArgs2(object);
      var isString = isObject && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject && !isFunction && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction;
      if (isString && object.length > 0 && !has2.call(object, 0)) {
        for (var i2 = 0; i2 < object.length; ++i2) {
          theKeys.push(String(i2));
        }
      }
      if (isArguments5 && object.length > 0) {
        for (var j2 = 0; j2 < object.length; ++j2) {
          theKeys.push(String(j2));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has2.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k2 = 0; k2 < dontEnums.length; ++k2) {
          if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object, dontEnums[k2])) {
            theKeys.push(dontEnums[k2]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$5 = keysShim2;
  return implementation$5;
}
var slice = Array.prototype.slice;
var isArgs = isArguments3;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o2) {
  return origKeys(o2);
} : requireImplementation$1();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys2(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim;
var objectKeys = objectKeys$1;
var hasSymbols2 = shams$1();
var callBound = callBound$3;
var toObject = Object;
var $push = callBound("Array.prototype.push");
var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols2 ? Object.getOwnPropertySymbols : null;
var implementation$4 = function assign(target, source1) {
  if (target == null) {
    throw new TypeError("target must be an object");
  }
  var to = toObject(target);
  if (arguments.length === 1) {
    return to;
  }
  for (var s2 = 1; s2 < arguments.length; ++s2) {
    var from = toObject(arguments[s2]);
    var keys2 = objectKeys(from);
    var getSymbols = hasSymbols2 && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j2 = 0; j2 < syms.length; ++j2) {
        var key2 = syms[j2];
        if ($propIsEnumerable(from, key2)) {
          $push(keys2, key2);
        }
      }
    }
    for (var i2 = 0; i2 < keys2.length; ++i2) {
      var nextKey = keys2[i2];
      if ($propIsEnumerable(from, nextKey)) {
        var propValue = from[nextKey];
        to[nextKey] = propValue;
      }
    }
  }
  return to;
};
var implementation$3 = implementation$4;
var lacksProperEnumerationOrder = function() {
  if (!Object.assign) {
    return false;
  }
  var str = "abcdefghijklmnopqrst";
  var letters = str.split("");
  var map2 = {};
  for (var i2 = 0; i2 < letters.length; ++i2) {
    map2[letters[i2]] = letters[i2];
  }
  var obj = Object.assign({}, map2);
  var actual = "";
  for (var k2 in obj) {
    actual += k2;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  var thrower = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(thrower, "xy");
  } catch (e2) {
    return thrower[1] === "y";
  }
  return false;
};
var polyfill$2 = function getPolyfill() {
  if (!Object.assign) {
    return implementation$3;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation$3;
  }
  if (assignHasPendingExceptions()) {
    return implementation$3;
  }
  return Object.assign;
};
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$2 = function is2(a2, b2) {
  if (a2 === 0 && b2 === 0) {
    return 1 / a2 === 1 / b2;
  }
  if (a2 === b2) {
    return true;
  }
  if (numberIsNaN(a2) && numberIsNaN(b2)) {
    return true;
  }
  return false;
};
var implementation$1 = implementation$2;
var polyfill$1 = function getPolyfill2() {
  return typeof Object.is === "function" ? Object.is : implementation$1;
};
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties)
    return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var keys2 = objectKeys$1;
  var hasSymbols3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr2 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var defineDataProperty$1 = defineDataProperty;
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr2.call(fn) === "[object Function]";
  };
  var supportsDescriptors = hasPropertyDescriptors_1();
  var defineProperty2 = function(object, name2, value, predicate) {
    if (name2 in object) {
      if (predicate === true) {
        if (object[name2] === value) {
          return;
        }
      } else if (!isFunction(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty$1(object, name2, value, true);
    } else {
      defineDataProperty$1(object, name2, value);
    }
  };
  var defineProperties = function(object, map2) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys2(map2);
    if (hasSymbols3) {
      props = concat.call(props, Object.getOwnPropertySymbols(map2));
    }
    for (var i2 = 0; i2 < props.length; i2 += 1) {
      defineProperty2(object, props[i2], map2[props[i2]], predicates[props[i2]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  defineProperties_1 = defineProperties;
  return defineProperties_1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var getPolyfill3 = polyfill$1;
  var define2 = requireDefineProperties();
  shim$1 = function shimObjectIs() {
    var polyfill2 = getPolyfill3();
    define2(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim$1;
}
var objectIs;
var hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs)
    return objectIs;
  hasRequiredObjectIs = 1;
  var define2 = requireDefineProperties();
  var callBind2 = callBindExports;
  var implementation2 = implementation$2;
  var getPolyfill3 = polyfill$1;
  var shim2 = requireShim$1();
  var polyfill2 = callBind2(getPolyfill3(), Object);
  define2(polyfill2, {
    getPolyfill: getPolyfill3,
    implementation: implementation2,
    shim: shim2
  });
  objectIs = polyfill2;
  return objectIs;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  implementation = function isNaN2(value) {
    return value !== value;
  };
  return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var implementation2 = requireImplementation();
  polyfill = function getPolyfill3() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
      return Number.isNaN;
    }
    return implementation2;
  };
  return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var define2 = requireDefineProperties();
  var getPolyfill3 = requirePolyfill();
  shim = function shimNumberIsNaN() {
    var polyfill2 = getPolyfill3();
    define2(Number, { isNaN: polyfill2 }, {
      isNaN: function testIsNaN() {
        return Number.isNaN !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim;
}
var isNan;
var hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan)
    return isNan;
  hasRequiredIsNan = 1;
  var callBind2 = callBindExports;
  var define2 = requireDefineProperties();
  var implementation2 = requireImplementation();
  var getPolyfill3 = requirePolyfill();
  var shim2 = requireShim();
  var polyfill2 = callBind2(getPolyfill3(), Number);
  define2(polyfill2, {
    getPolyfill: getPolyfill3,
    implementation: implementation2,
    shim: shim2
  });
  isNan = polyfill2;
  return isNan;
}
var comparisons;
var hasRequiredComparisons;
function requireComparisons() {
  if (hasRequiredComparisons)
    return comparisons;
  hasRequiredComparisons = 1;
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2)
            return;
          f2 = false;
        } else
          for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true)
            ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2))
            return;
        } finally {
          if (o2)
            throw n2;
        }
      }
      return a2;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  var regexFlagsSupported = /a/g.flags !== void 0;
  var arrayFromSet = function arrayFromSet2(set) {
    var array = [];
    set.forEach(function(value) {
      return array.push(value);
    });
    return array;
  };
  var arrayFromMap = function arrayFromMap2(map2) {
    var array = [];
    map2.forEach(function(value, key2) {
      return array.push([key2, value]);
    });
    return array;
  };
  var objectIs2 = Object.is ? Object.is : requireObjectIs();
  var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  };
  var numberIsNaN2 = Number.isNaN ? Number.isNaN : requireIsNan();
  function uncurryThis(f2) {
    return f2.call.bind(f2);
  }
  var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty);
  var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
  var objectToString = uncurryThis(Object.prototype.toString);
  var _require$types = util.types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
  function isNonIndex(key2) {
    if (key2.length === 0 || key2.length > 10)
      return true;
    for (var i2 = 0; i2 < key2.length; i2++) {
      var code2 = key2.charCodeAt(i2);
      if (code2 < 48 || code2 > 57)
        return true;
    }
    return key2.length === 10 && key2 >= Math.pow(2, 32);
  }
  function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function compare(a2, b2) {
    if (a2 === b2) {
      return 0;
    }
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2) {
      return -1;
    }
    if (y2 < x2) {
      return 1;
    }
    return 0;
  }
  var kStrict = true;
  var kLoose = false;
  var kNoIterator = 0;
  var kIsArray = 1;
  var kIsSet = 2;
  var kIsMap = 3;
  function areSimilarRegExps(a2, b2) {
    return regexFlagsSupported ? a2.source === b2.source && a2.flags === b2.flags : RegExp.prototype.toString.call(a2) === RegExp.prototype.toString.call(b2);
  }
  function areSimilarFloatArrays(a2, b2) {
    if (a2.byteLength !== b2.byteLength) {
      return false;
    }
    for (var offset = 0; offset < a2.byteLength; offset++) {
      if (a2[offset] !== b2[offset]) {
        return false;
      }
    }
    return true;
  }
  function areSimilarTypedArrays(a2, b2) {
    if (a2.byteLength !== b2.byteLength) {
      return false;
    }
    return compare(new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), new Uint8Array(b2.buffer, b2.byteOffset, b2.byteLength)) === 0;
  }
  function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
  }
  function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) {
      return isNumberObject(val2) && objectIs2(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    }
    if (isStringObject(val1)) {
      return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    }
    if (isBooleanObject(val1)) {
      return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    }
    if (isBigIntObject(val1)) {
      return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    }
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
  }
  function innerDeepEqual(val1, val2, strict, memos) {
    if (val1 === val2) {
      if (val1 !== 0)
        return true;
      return strict ? objectIs2(val1, val2) : true;
    }
    if (strict) {
      if (_typeof(val1) !== "object") {
        return typeof val1 === "number" && numberIsNaN2(val1) && numberIsNaN2(val2);
      }
      if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
        return false;
      }
      if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
        return false;
      }
    } else {
      if (val1 === null || _typeof(val1) !== "object") {
        if (val2 === null || _typeof(val2) !== "object") {
          return val1 == val2;
        }
        return false;
      }
      if (val2 === null || _typeof(val2) !== "object") {
        return false;
      }
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) {
      return false;
    }
    if (Array.isArray(val1)) {
      if (val1.length !== val2.length) {
        return false;
      }
      var keys1 = getOwnNonIndexProperties(val1);
      var keys2 = getOwnNonIndexProperties(val2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    }
    if (val1Tag === "[object Object]") {
      if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
        return false;
      }
    }
    if (isDate(val1)) {
      if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
        return false;
      }
    } else if (isRegExp(val1)) {
      if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
        return false;
      }
    } else if (isNativeError(val1) || val1 instanceof Error) {
      if (val1.message !== val2.message || val1.name !== val2.name) {
        return false;
      }
    } else if (isArrayBufferView(val1)) {
      if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
        if (!areSimilarFloatArrays(val1, val2)) {
          return false;
        }
      } else if (!areSimilarTypedArrays(val1, val2)) {
        return false;
      }
      var _keys = getOwnNonIndexProperties(val1);
      var _keys2 = getOwnNonIndexProperties(val2);
      if (_keys.length !== _keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
      if (!isSet(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
      if (!isMap(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
      if (!areEqualArrayBuffers(val1, val2)) {
        return false;
      }
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator);
  }
  function getEnumerables(val2, keys2) {
    return keys2.filter(function(k2) {
      return propertyIsEnumerable(val2, k2);
    });
  }
  function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    if (arguments.length === 5) {
      aKeys = Object.keys(val1);
      var bKeys = Object.keys(val2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
    }
    var i2 = 0;
    for (; i2 < aKeys.length; i2++) {
      if (!hasOwnProperty2(val2, aKeys[i2])) {
        return false;
      }
    }
    if (strict && arguments.length === 5) {
      var symbolKeysA = objectGetOwnPropertySymbols(val1);
      if (symbolKeysA.length !== 0) {
        var count2 = 0;
        for (i2 = 0; i2 < symbolKeysA.length; i2++) {
          var key2 = symbolKeysA[i2];
          if (propertyIsEnumerable(val1, key2)) {
            if (!propertyIsEnumerable(val2, key2)) {
              return false;
            }
            aKeys.push(key2);
            count2++;
          } else if (propertyIsEnumerable(val2, key2)) {
            return false;
          }
        }
        var symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count2) {
          return false;
        }
      } else {
        var _symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
          return false;
        }
      }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
      return true;
    }
    if (memos === void 0) {
      memos = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    } else {
      var val2MemoA = memos.val1.get(val1);
      if (val2MemoA !== void 0) {
        var val2MemoB = memos.val2.get(val2);
        if (val2MemoB !== void 0) {
          return val2MemoA === val2MemoB;
        }
      }
      memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
  }
  function setHasEqualElement(set, val1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i2 = 0; i2 < setValues.length; i2++) {
      var val2 = setValues[i2];
      if (innerDeepEqual(val1, val2, strict, memo)) {
        set.delete(val2);
        return true;
      }
    }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    switch (_typeof(prim)) {
      case "undefined":
        return null;
      case "object":
        return void 0;
      case "symbol":
        return false;
      case "string":
        prim = +prim;
      case "number":
        if (numberIsNaN2(prim)) {
          return false;
        }
    }
    return true;
  }
  function setMightHaveLoosePrim(a2, b2, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null)
      return altValue;
    return b2.has(altValue) && !a2.has(altValue);
  }
  function mapMightHaveLoosePrim(a2, b2, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    var curB = b2.get(altValue);
    if (curB === void 0 && !b2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
      return false;
    }
    return !a2.has(altValue) && innerDeepEqual(item, curB, false, memo);
  }
  function setEquiv(a2, b2, strict, memo) {
    var set = null;
    var aValues = arrayFromSet(a2);
    for (var i2 = 0; i2 < aValues.length; i2++) {
      var val2 = aValues[i2];
      if (_typeof(val2) === "object" && val2 !== null) {
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(val2);
      } else if (!b2.has(val2)) {
        if (strict)
          return false;
        if (!setMightHaveLoosePrim(a2, b2, val2)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(val2);
      }
    }
    if (set !== null) {
      var bValues = arrayFromSet(b2);
      for (var _i = 0; _i < bValues.length; _i++) {
        var _val = bValues[_i];
        if (_typeof(_val) === "object" && _val !== null) {
          if (!setHasEqualElement(set, _val, strict, memo))
            return false;
        } else if (!strict && !a2.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function mapHasEqualEntry(set, map2, key1, item1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i2 = 0; i2 < setValues.length; i2++) {
      var key2 = setValues[i2];
      if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map2.get(key2), strict, memo)) {
        set.delete(key2);
        return true;
      }
    }
    return false;
  }
  function mapEquiv(a2, b2, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a2);
    for (var i2 = 0; i2 < aEntries.length; i2++) {
      var _aEntries$i = _slicedToArray(aEntries[i2], 2), key2 = _aEntries$i[0], item1 = _aEntries$i[1];
      if (_typeof(key2) === "object" && key2 !== null) {
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      } else {
        var item2 = b2.get(key2);
        if (item2 === void 0 && !b2.has(key2) || !innerDeepEqual(item1, item2, strict, memo)) {
          if (strict)
            return false;
          if (!mapMightHaveLoosePrim(a2, b2, key2, item1, memo))
            return false;
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key2);
        }
      }
    }
    if (set !== null) {
      var bEntries = arrayFromMap(b2);
      for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
        var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
        if (_typeof(_key) === "object" && _key !== null) {
          if (!mapHasEqualEntry(set, a2, _key, item, strict, memo))
            return false;
        } else if (!strict && (!a2.has(_key) || !innerDeepEqual(a2.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a2, _key, item, false, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function objEquiv(a2, b2, strict, keys2, memos, iterationType) {
    var i2 = 0;
    if (iterationType === kIsSet) {
      if (!setEquiv(a2, b2, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsMap) {
      if (!mapEquiv(a2, b2, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsArray) {
      for (; i2 < a2.length; i2++) {
        if (hasOwnProperty2(a2, i2)) {
          if (!hasOwnProperty2(b2, i2) || !innerDeepEqual(a2[i2], b2[i2], strict, memos)) {
            return false;
          }
        } else if (hasOwnProperty2(b2, i2)) {
          return false;
        } else {
          var keysA = Object.keys(a2);
          for (; i2 < keysA.length; i2++) {
            var key2 = keysA[i2];
            if (!hasOwnProperty2(b2, key2) || !innerDeepEqual(a2[key2], b2[key2], strict, memos)) {
              return false;
            }
          }
          if (keysA.length !== Object.keys(b2).length) {
            return false;
          }
          return true;
        }
      }
    }
    for (i2 = 0; i2 < keys2.length; i2++) {
      var _key2 = keys2[i2];
      if (!innerDeepEqual(a2[_key2], b2[_key2], strict, memos)) {
        return false;
      }
    }
    return true;
  }
  function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
  }
  function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
  }
  comparisons = {
    isDeepEqual,
    isDeepStrictEqual
  };
  return comparisons;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert)
    return assert.exports;
  hasRequiredAssert = 1;
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return _typeof(key2) === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _require = requireErrors(), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var AssertionError = requireAssertion_error();
  var _require2 = util, inspect = _require2.inspect;
  var _require$types = util.types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
  var objectAssign = polyfill$2();
  var objectIs2 = polyfill$1();
  var RegExpPrototypeTest = callBound$3("RegExp.prototype.test");
  var isDeepEqual;
  var isDeepStrictEqual;
  function lazyLoadComparison() {
    var comparison = requireComparisons();
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
  }
  var warned = false;
  var assert$1 = assert.exports = ok2;
  var NO_EXCEPTION_SENTINEL = {};
  function innerFail(obj) {
    if (obj.message instanceof Error)
      throw obj.message;
    throw new AssertionError(obj);
  }
  function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) {
      internalMessage = "Failed";
    } else if (argsLen === 1) {
      message = actual;
      actual = void 0;
    } else {
      if (warned === false) {
        warned = true;
        var warn = dist.process.emitWarning ? dist.process.emitWarning : console.warn.bind(console);
        warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      if (argsLen === 2)
        operator = "!=";
    }
    if (message instanceof Error)
      throw message;
    var errArgs = {
      actual,
      expected,
      operator: operator === void 0 ? "fail" : operator,
      stackStartFn: stackStartFn || fail
    };
    if (message !== void 0) {
      errArgs.message = message;
    }
    var err = new AssertionError(errArgs);
    if (internalMessage) {
      err.message = internalMessage;
      err.generatedMessage = true;
    }
    throw err;
  }
  assert$1.fail = fail;
  assert$1.AssertionError = AssertionError;
  function innerOk(fn, argLen, value, message) {
    if (!value) {
      var generatedMessage = false;
      if (argLen === 0) {
        generatedMessage = true;
        message = "No value argument passed to `assert.ok()`";
      } else if (message instanceof Error) {
        throw message;
      }
      var err = new AssertionError({
        actual: value,
        expected: true,
        message,
        operator: "==",
        stackStartFn: fn
      });
      err.generatedMessage = generatedMessage;
      throw err;
    }
  }
  function ok2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    innerOk.apply(void 0, [ok2, args.length].concat(args));
  }
  assert$1.ok = ok2;
  assert$1.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual != expected) {
      innerFail({
        actual,
        expected,
        message,
        operator: "==",
        stackStartFn: equal
      });
    }
  };
  assert$1.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual == expected) {
      innerFail({
        actual,
        expected,
        message,
        operator: "!=",
        stackStartFn: notEqual
      });
    }
  };
  assert$1.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "deepEqual",
        stackStartFn: deepEqual
      });
    }
  };
  assert$1.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notDeepEqual",
        stackStartFn: notDeepEqual
      });
    }
  };
  assert$1.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
      });
    }
  };
  assert$1.notDeepStrictEqual = notDeepStrictEqual;
  function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
      });
    }
  }
  assert$1.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (!objectIs2(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "strictEqual",
        stackStartFn: strictEqual
      });
    }
  };
  assert$1.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (objectIs2(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notStrictEqual",
        stackStartFn: notStrictEqual
      });
    }
  };
  var Comparison = /* @__PURE__ */ _createClass(function Comparison2(obj, keys2, actual) {
    var _this = this;
    _classCallCheck(this, Comparison2);
    keys2.forEach(function(key2) {
      if (key2 in obj) {
        if (actual !== void 0 && typeof actual[key2] === "string" && isRegExp(obj[key2]) && RegExpPrototypeTest(obj[key2], actual[key2])) {
          _this[key2] = actual[key2];
        } else {
          _this[key2] = obj[key2];
        }
      }
    });
  });
  function compareExceptionKey(actual, expected, key2, message, keys2, fn) {
    if (!(key2 in actual) || !isDeepStrictEqual(actual[key2], expected[key2])) {
      if (!message) {
        var a2 = new Comparison(actual, keys2);
        var b2 = new Comparison(expected, keys2, actual);
        var err = new AssertionError({
          actual: a2,
          expected: b2,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err.actual = actual;
        err.expected = expected;
        err.operator = fn.name;
        throw err;
      }
      innerFail({
        actual,
        expected,
        message,
        operator: fn.name,
        stackStartFn: fn
      });
    }
  }
  function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== "function") {
      if (isRegExp(expected))
        return RegExpPrototypeTest(expected, actual);
      if (arguments.length === 2) {
        throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
      }
      if (_typeof(actual) !== "object" || actual === null) {
        var err = new AssertionError({
          actual,
          expected,
          message: msg,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err.operator = fn.name;
        throw err;
      }
      var keys2 = Object.keys(expected);
      if (expected instanceof Error) {
        keys2.push("name", "message");
      } else if (keys2.length === 0) {
        throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      keys2.forEach(function(key2) {
        if (typeof actual[key2] === "string" && isRegExp(expected[key2]) && RegExpPrototypeTest(expected[key2], actual[key2])) {
          return;
        }
        compareExceptionKey(actual, expected, key2, msg, keys2, fn);
      });
      return true;
    }
    if (expected.prototype !== void 0 && actual instanceof expected) {
      return true;
    }
    if (Error.isPrototypeOf(expected)) {
      return false;
    }
    return expected.call({}, actual) === true;
  }
  function getActual(fn) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
    }
    try {
      fn();
    } catch (e2) {
      return e2;
    }
    return NO_EXCEPTION_SENTINEL;
  }
  function checkIsPromise(obj) {
    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
  }
  function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
      var resultPromise;
      if (typeof promiseFn === "function") {
        resultPromise = promiseFn();
        if (!checkIsPromise(resultPromise)) {
          throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        }
      } else if (checkIsPromise(promiseFn)) {
        resultPromise = promiseFn;
      } else {
        throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
      }
      return Promise.resolve().then(function() {
        return resultPromise;
      }).then(function() {
        return NO_EXCEPTION_SENTINEL;
      }).catch(function(e2) {
        return e2;
      });
    });
  }
  function expectsError(stackStartFn, actual, error, message) {
    if (typeof error === "string") {
      if (arguments.length === 4) {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (_typeof(actual) === "object" && actual !== null) {
        if (actual.message === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        }
      } else if (actual === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
      }
      message = error;
      error = void 0;
    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
    }
    if (actual === NO_EXCEPTION_SENTINEL) {
      var details = "";
      if (error && error.name) {
        details += " (".concat(error.name, ")");
      }
      details += message ? ": ".concat(message) : ".";
      var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
      innerFail({
        actual: void 0,
        expected: error,
        operator: stackStartFn.name,
        message: "Missing expected ".concat(fnType).concat(details),
        stackStartFn
      });
    }
    if (error && !expectedException(actual, error, message, stackStartFn)) {
      throw actual;
    }
  }
  function expectsNoError(stackStartFn, actual, error, message) {
    if (actual === NO_EXCEPTION_SENTINEL)
      return;
    if (typeof error === "string") {
      message = error;
      error = void 0;
    }
    if (!error || expectedException(actual, error)) {
      var details = message ? ": ".concat(message) : ".";
      var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
      innerFail({
        actual,
        expected: error,
        operator: stackStartFn.name,
        message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
        stackStartFn
      });
    }
    throw actual;
  }
  assert$1.throws = function throws(promiseFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
  };
  assert$1.rejects = function rejects(promiseFn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return waitForActual(promiseFn).then(function(result) {
      return expectsError.apply(void 0, [rejects, result].concat(args));
    });
  };
  assert$1.doesNotThrow = function doesNotThrow(fn) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
  };
  assert$1.doesNotReject = function doesNotReject(fn) {
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    return waitForActual(fn).then(function(result) {
      return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
    });
  };
  assert$1.ifError = function ifError(err) {
    if (err !== null && err !== void 0) {
      var message = "ifError got unwanted exception: ";
      if (_typeof(err) === "object" && typeof err.message === "string") {
        if (err.message.length === 0 && err.constructor) {
          message += err.constructor.name;
        } else {
          message += err.message;
        }
      } else {
        message += inspect(err);
      }
      var newErr = new AssertionError({
        actual: err,
        expected: null,
        operator: "ifError",
        message,
        stackStartFn: ifError
      });
      var origStack = err.stack;
      if (typeof origStack === "string") {
        var tmp2 = origStack.split("\n");
        tmp2.shift();
        var tmp1 = newErr.stack.split("\n");
        for (var i2 = 0; i2 < tmp2.length; i2++) {
          var pos = tmp1.indexOf(tmp2[i2]);
          if (pos !== -1) {
            tmp1 = tmp1.slice(0, pos);
            break;
          }
        }
        newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
      }
      throw newErr;
    }
  };
  function internalMatch(string, regexp, message, fn, fnName) {
    if (!isRegExp(regexp)) {
      throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    }
    var match = fnName === "match";
    if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
      if (message instanceof Error) {
        throw message;
      }
      var generatedMessage = !message;
      message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
      var err = new AssertionError({
        actual: string,
        expected: regexp,
        message,
        operator: fnName,
        stackStartFn: fn
      });
      err.generatedMessage = generatedMessage;
      throw err;
    }
  }
  assert$1.match = function match(string, regexp, message) {
    internalMatch(string, regexp, message, match, "match");
  };
  assert$1.doesNotMatch = function doesNotMatch(string, regexp, message) {
    internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
  };
  function strict() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    innerOk.apply(void 0, [strict, args.length].concat(args));
  }
  assert$1.strict = objectAssign(strict, assert$1, {
    equal: assert$1.strictEqual,
    deepEqual: assert$1.deepStrictEqual,
    notEqual: assert$1.notStrictEqual,
    notDeepEqual: assert$1.notDeepStrictEqual
  });
  assert$1.strict.strict = assert$1.strict;
  return assert.exports;
}
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(empty$6);
var build$3;
var hasRequiredBuild$2;
function requireBuild$2() {
  if (hasRequiredBuild$2)
    return build$3;
  hasRequiredBuild$2 = 1;
  var fs = require$$1;
  var util$1 = util;
  var path2 = requirePathBrowserify();
  let shim2;
  class Y18N {
    constructor(opts) {
      opts = opts || {};
      this.directory = opts.directory || "./locales";
      this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
      this.locale = opts.locale || "en";
      this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
      this.cache = /* @__PURE__ */ Object.create(null);
      this.writeQueue = [];
    }
    __(...args) {
      if (typeof arguments[0] !== "string") {
        return this._taggedLiteral(arguments[0], ...arguments);
      }
      const str = args.shift();
      let cb = function() {
      };
      if (typeof args[args.length - 1] === "function")
        cb = args.pop();
      cb = cb || function() {
      };
      if (!this.cache[this.locale])
        this._readLocaleFile();
      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str;
        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb
        });
      } else {
        cb();
      }
      return shim2.format.apply(shim2.format, [this.cache[this.locale][str] || str].concat(args));
    }
    __n() {
      const args = Array.prototype.slice.call(arguments);
      const singular = args.shift();
      const plural = args.shift();
      const quantity = args.shift();
      let cb = function() {
      };
      if (typeof args[args.length - 1] === "function")
        cb = args.pop();
      if (!this.cache[this.locale])
        this._readLocaleFile();
      let str = quantity === 1 ? singular : plural;
      if (this.cache[this.locale][singular]) {
        const entry = this.cache[this.locale][singular];
        str = entry[quantity === 1 ? "one" : "other"];
      }
      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        };
        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb
        });
      } else {
        cb();
      }
      const values = [str];
      if (~str.indexOf("%d"))
        values.push(quantity);
      return shim2.format.apply(shim2.format, values.concat(args));
    }
    setLocale(locale) {
      this.locale = locale;
    }
    getLocale() {
      return this.locale;
    }
    updateLocale(obj) {
      if (!this.cache[this.locale])
        this._readLocaleFile();
      for (const key2 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key2)) {
          this.cache[this.locale][key2] = obj[key2];
        }
      }
    }
    _taggedLiteral(parts, ...args) {
      let str = "";
      parts.forEach(function(part, i2) {
        const arg = args[i2 + 1];
        str += part;
        if (typeof arg !== "undefined") {
          str += "%s";
        }
      });
      return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
      this.writeQueue.push(work);
      if (this.writeQueue.length === 1)
        this._processWriteQueue();
    }
    _processWriteQueue() {
      const _this = this;
      const work = this.writeQueue[0];
      const directory = work.directory;
      const locale = work.locale;
      const cb = work.cb;
      const languageFile = this._resolveLocaleFile(directory, locale);
      const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
      shim2.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
        _this.writeQueue.shift();
        if (_this.writeQueue.length > 0)
          _this._processWriteQueue();
        cb(err);
      });
    }
    _readLocaleFile() {
      let localeLookup = {};
      const languageFile = this._resolveLocaleFile(this.directory, this.locale);
      try {
        if (shim2.fs.readFileSync) {
          localeLookup = JSON.parse(shim2.fs.readFileSync(languageFile, "utf-8"));
        }
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = "syntax error in " + languageFile;
        }
        if (err.code === "ENOENT")
          localeLookup = {};
        else
          throw err;
      }
      this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
      let file = shim2.resolve(directory, "./", locale + ".json");
      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
        const languageFile = shim2.resolve(directory, "./", locale.split("_")[0] + ".json");
        if (this._fileExistsSync(languageFile))
          file = languageFile;
      }
      return file;
    }
    _fileExistsSync(file) {
      return shim2.exists(file);
    }
  }
  function y18n$1(opts, _shim) {
    shim2 = _shim;
    const y18n2 = new Y18N(opts);
    return {
      __: y18n2.__.bind(y18n2),
      __n: y18n2.__n.bind(y18n2),
      setLocale: y18n2.setLocale.bind(y18n2),
      getLocale: y18n2.getLocale.bind(y18n2),
      updateLocale: y18n2.updateLocale.bind(y18n2),
      locale: y18n2.locale
    };
  }
  var nodePlatformShim = {
    fs: {
      readFileSync: fs.readFileSync,
      writeFile: fs.writeFile
    },
    format: util$1.format,
    resolve: path2.resolve,
    exists: (file) => {
      try {
        return fs.statSync(file).isFile();
      } catch (err) {
        return false;
      }
    }
  };
  const y18n = (opts) => {
    return y18n$1(opts, nodePlatformShim);
  };
  build$3 = y18n;
  return build$3;
}
var build$2;
var hasRequiredBuild$1;
function requireBuild$1() {
  if (hasRequiredBuild$1)
    return build$2;
  hasRequiredBuild$1 = 1;
  var util$1 = util;
  var path2 = requirePathBrowserify();
  var fs = require$$1;
  function camelCase(str) {
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
      str = str.toLowerCase();
    }
    if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
      return str;
    } else {
      let camelcase2 = "";
      let nextChrUpper = false;
      const leadingHyphens = str.match(/^-+/);
      for (let i2 = leadingHyphens ? leadingHyphens[0].length : 0; i2 < str.length; i2++) {
        let chr = str.charAt(i2);
        if (nextChrUpper) {
          nextChrUpper = false;
          chr = chr.toUpperCase();
        }
        if (i2 !== 0 && (chr === "-" || chr === "_")) {
          nextChrUpper = true;
        } else if (chr !== "-" && chr !== "_") {
          camelcase2 += chr;
        }
      }
      return camelcase2;
    }
  }
  function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || "-";
    let notCamelcase = "";
    for (let i2 = 0; i2 < str.length; i2++) {
      const chrLower = lowercase.charAt(i2);
      const chrString = str.charAt(i2);
      if (chrLower !== chrString && i2 > 0) {
        notCamelcase += `${joinString}${lowercase.charAt(i2)}`;
      } else {
        notCamelcase += chrString;
      }
    }
    return notCamelcase;
  }
  function looksLikeNumber(x2) {
    if (x2 === null || x2 === void 0)
      return false;
    if (typeof x2 === "number")
      return true;
    if (/^0x[0-9a-f]+$/i.test(x2))
      return true;
    if (/^0[^.]/.test(x2))
      return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x2);
  }
  function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
      return argString.map((e2) => typeof e2 !== "string" ? e2 + "" : e2);
    }
    argString = argString.trim();
    let i2 = 0;
    let prevC = null;
    let c2 = null;
    let opening2 = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
      prevC = c2;
      c2 = argString.charAt(ii);
      if (c2 === " " && !opening2) {
        if (!(prevC === " ")) {
          i2++;
        }
        continue;
      }
      if (c2 === opening2) {
        opening2 = null;
      } else if ((c2 === "'" || c2 === '"') && !opening2) {
        opening2 = c2;
      }
      if (!args[i2])
        args[i2] = "";
      args[i2] += c2;
    }
    return args;
  }
  var DefaultValuesForTypeKey;
  (function(DefaultValuesForTypeKey2) {
    DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey2["STRING"] = "string";
    DefaultValuesForTypeKey2["NUMBER"] = "number";
    DefaultValuesForTypeKey2["ARRAY"] = "array";
  })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
  let mixin;
  class YargsParser {
    constructor(_mixin) {
      mixin = _mixin;
    }
    parse(argsInput, options2) {
      const opts = Object.assign({
        alias: void 0,
        array: void 0,
        boolean: void 0,
        config: void 0,
        configObjects: void 0,
        configuration: void 0,
        coerce: void 0,
        count: void 0,
        default: void 0,
        envPrefix: void 0,
        narg: void 0,
        normalize: void 0,
        string: void 0,
        number: void 0,
        __: void 0,
        key: void 0
      }, options2);
      const args = tokenizeArgString(argsInput);
      const inputIsString = typeof argsInput === "string";
      const aliases2 = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
      const configuration = Object.assign({
        "boolean-negation": true,
        "camel-case-expansion": true,
        "combine-arrays": false,
        "dot-notation": true,
        "duplicate-arguments-array": true,
        "flatten-duplicate-arrays": true,
        "greedy-arrays": true,
        "halt-at-non-option": false,
        "nargs-eats-options": false,
        "negation-prefix": "no-",
        "parse-numbers": true,
        "parse-positional-numbers": true,
        "populate--": false,
        "set-placeholder-key": false,
        "short-option-groups": true,
        "strip-aliased": false,
        "strip-dashed": false,
        "unknown-options-as-args": false
      }, opts.configuration);
      const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
      const configObjects = opts.configObjects || [];
      const envPrefix = opts.envPrefix;
      const notFlagsOption = configuration["populate--"];
      const notFlagsArgv = notFlagsOption ? "--" : "_";
      const newAliases = /* @__PURE__ */ Object.create(null);
      const defaulted = /* @__PURE__ */ Object.create(null);
      const __ = opts.__ || mixin.format;
      const flags = {
        aliases: /* @__PURE__ */ Object.create(null),
        arrays: /* @__PURE__ */ Object.create(null),
        bools: /* @__PURE__ */ Object.create(null),
        strings: /* @__PURE__ */ Object.create(null),
        numbers: /* @__PURE__ */ Object.create(null),
        counts: /* @__PURE__ */ Object.create(null),
        normalize: /* @__PURE__ */ Object.create(null),
        configs: /* @__PURE__ */ Object.create(null),
        nargs: /* @__PURE__ */ Object.create(null),
        coercions: /* @__PURE__ */ Object.create(null),
        keys: []
      };
      const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
      [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
        const key2 = typeof opt === "object" ? opt.key : opt;
        const assignment = Object.keys(opt).map(function(key3) {
          const arrayFlagKeys = {
            boolean: "bools",
            string: "strings",
            number: "numbers"
          };
          return arrayFlagKeys[key3];
        }).filter(Boolean).pop();
        if (assignment) {
          flags[assignment][key2] = true;
        }
        flags.arrays[key2] = true;
        flags.keys.push(key2);
      });
      [].concat(opts.boolean || []).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = true;
        flags.keys.push(key2);
      });
      [].concat(opts.string || []).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        flags.keys.push(key2);
      });
      [].concat(opts.number || []).filter(Boolean).forEach(function(key2) {
        flags.numbers[key2] = true;
        flags.keys.push(key2);
      });
      [].concat(opts.count || []).filter(Boolean).forEach(function(key2) {
        flags.counts[key2] = true;
        flags.keys.push(key2);
      });
      [].concat(opts.normalize || []).filter(Boolean).forEach(function(key2) {
        flags.normalize[key2] = true;
        flags.keys.push(key2);
      });
      if (typeof opts.narg === "object") {
        Object.entries(opts.narg).forEach(([key2, value]) => {
          if (typeof value === "number") {
            flags.nargs[key2] = value;
            flags.keys.push(key2);
          }
        });
      }
      if (typeof opts.coerce === "object") {
        Object.entries(opts.coerce).forEach(([key2, value]) => {
          if (typeof value === "function") {
            flags.coercions[key2] = value;
            flags.keys.push(key2);
          }
        });
      }
      if (typeof opts.config !== "undefined") {
        if (Array.isArray(opts.config) || typeof opts.config === "string") {
          [].concat(opts.config).filter(Boolean).forEach(function(key2) {
            flags.configs[key2] = true;
          });
        } else if (typeof opts.config === "object") {
          Object.entries(opts.config).forEach(([key2, value]) => {
            if (typeof value === "boolean" || typeof value === "function") {
              flags.configs[key2] = value;
            }
          });
        }
      }
      extendAliases(opts.key, aliases2, opts.default, flags.arrays);
      Object.keys(defaults).forEach(function(key2) {
        (flags.aliases[key2] || []).forEach(function(alias) {
          defaults[alias] = defaults[key2];
        });
      });
      let error = null;
      checkConfiguration();
      let notFlags = [];
      const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
      const argvReturn = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const arg = args[i2];
        const truncatedArg = arg.replace(/^-{3,}/, "---");
        let broken;
        let key2;
        let letters;
        let m2;
        let next;
        let value;
        if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
          pushPositional(arg);
        } else if (truncatedArg.match(/^---+(=|$)/)) {
          pushPositional(arg);
          continue;
        } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
          m2 = arg.match(/^--?([^=]+)=([\s\S]*)$/);
          if (m2 !== null && Array.isArray(m2) && m2.length >= 3) {
            if (checkAllAliases(m2[1], flags.arrays)) {
              i2 = eatArray(i2, m2[1], args, m2[2]);
            } else if (checkAllAliases(m2[1], flags.nargs) !== false) {
              i2 = eatNargs(i2, m2[1], args, m2[2]);
            } else {
              setArg(m2[1], m2[2], true);
            }
          }
        } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
          m2 = arg.match(negatedBoolean);
          if (m2 !== null && Array.isArray(m2) && m2.length >= 2) {
            key2 = m2[1];
            setArg(key2, checkAllAliases(key2, flags.arrays) ? [false] : false);
          }
        } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
          m2 = arg.match(/^--?(.+)/);
          if (m2 !== null && Array.isArray(m2) && m2.length >= 2) {
            key2 = m2[1];
            if (checkAllAliases(key2, flags.arrays)) {
              i2 = eatArray(i2, key2, args);
            } else if (checkAllAliases(key2, flags.nargs) !== false) {
              i2 = eatNargs(i2, key2, args);
            } else {
              next = args[i2 + 1];
              if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key2, flags.bools) && !checkAllAliases(key2, flags.counts)) {
                setArg(key2, next);
                i2++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key2, next);
                i2++;
              } else {
                setArg(key2, defaultValue(key2));
              }
            }
          }
        } else if (arg.match(/^-.\..+=/)) {
          m2 = arg.match(/^-([^=]+)=([\s\S]*)$/);
          if (m2 !== null && Array.isArray(m2) && m2.length >= 3) {
            setArg(m2[1], m2[2]);
          }
        } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
          next = args[i2 + 1];
          m2 = arg.match(/^-(.\..+)/);
          if (m2 !== null && Array.isArray(m2) && m2.length >= 2) {
            key2 = m2[1];
            if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key2, flags.bools) && !checkAllAliases(key2, flags.counts)) {
              setArg(key2, next);
              i2++;
            } else {
              setArg(key2, defaultValue(key2));
            }
          }
        } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
          letters = arg.slice(1, -1).split("");
          broken = false;
          for (let j2 = 0; j2 < letters.length; j2++) {
            next = arg.slice(j2 + 2);
            if (letters[j2 + 1] && letters[j2 + 1] === "=") {
              value = arg.slice(j2 + 3);
              key2 = letters[j2];
              if (checkAllAliases(key2, flags.arrays)) {
                i2 = eatArray(i2, key2, args, value);
              } else if (checkAllAliases(key2, flags.nargs) !== false) {
                i2 = eatNargs(i2, key2, args, value);
              } else {
                setArg(key2, value);
              }
              broken = true;
              break;
            }
            if (next === "-") {
              setArg(letters[j2], next);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j2]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
              setArg(letters[j2], next);
              broken = true;
              break;
            }
            if (letters[j2 + 1] && letters[j2 + 1].match(/\W/)) {
              setArg(letters[j2], next);
              broken = true;
              break;
            } else {
              setArg(letters[j2], defaultValue(letters[j2]));
            }
          }
          key2 = arg.slice(-1)[0];
          if (!broken && key2 !== "-") {
            if (checkAllAliases(key2, flags.arrays)) {
              i2 = eatArray(i2, key2, args);
            } else if (checkAllAliases(key2, flags.nargs) !== false) {
              i2 = eatNargs(i2, key2, args);
            } else {
              next = args[i2 + 1];
              if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key2, flags.bools) && !checkAllAliases(key2, flags.counts)) {
                setArg(key2, next);
                i2++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key2, next);
                i2++;
              } else {
                setArg(key2, defaultValue(key2));
              }
            }
          }
        } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
          key2 = arg.slice(1);
          setArg(key2, defaultValue(key2));
        } else if (arg === "--") {
          notFlags = args.slice(i2 + 1);
          break;
        } else if (configuration["halt-at-non-option"]) {
          notFlags = args.slice(i2);
          break;
        } else {
          pushPositional(arg);
        }
      }
      applyEnvVars(argv, true);
      applyEnvVars(argv, false);
      setConfig(argv);
      setConfigObjects();
      applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
      applyCoercions(argv);
      if (configuration["set-placeholder-key"])
        setPlaceholderKeys(argv);
      Object.keys(flags.counts).forEach(function(key2) {
        if (!hasKey(argv, key2.split(".")))
          setArg(key2, 0);
      });
      if (notFlagsOption && notFlags.length)
        argv[notFlagsArgv] = [];
      notFlags.forEach(function(key2) {
        argv[notFlagsArgv].push(key2);
      });
      if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
        Object.keys(argv).filter((key2) => key2 !== "--" && key2.includes("-")).forEach((key2) => {
          delete argv[key2];
        });
      }
      if (configuration["strip-aliased"]) {
        [].concat(...Object.keys(aliases2).map((k2) => aliases2[k2])).forEach((alias) => {
          if (configuration["camel-case-expansion"] && alias.includes("-")) {
            delete argv[alias.split(".").map((prop2) => camelCase(prop2)).join(".")];
          }
          delete argv[alias];
        });
      }
      function pushPositional(arg) {
        const maybeCoercedNumber = maybeCoerceNumber("_", arg);
        if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
          argv._.push(maybeCoercedNumber);
        }
      }
      function eatNargs(i2, key2, args2, argAfterEqualSign) {
        let ii;
        let toEat = checkAllAliases(key2, flags.nargs);
        toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
        if (toEat === 0) {
          if (!isUndefined(argAfterEqualSign)) {
            error = Error(__("Argument unexpected for: %s", key2));
          }
          setArg(key2, defaultValue(key2));
          return i2;
        }
        let available = isUndefined(argAfterEqualSign) ? 0 : 1;
        if (configuration["nargs-eats-options"]) {
          if (args2.length - (i2 + 1) + available < toEat) {
            error = Error(__("Not enough arguments following: %s", key2));
          }
          available = toEat;
        } else {
          for (ii = i2 + 1; ii < args2.length; ii++) {
            if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
              available++;
            else
              break;
          }
          if (available < toEat)
            error = Error(__("Not enough arguments following: %s", key2));
        }
        let consumed = Math.min(available, toEat);
        if (!isUndefined(argAfterEqualSign) && consumed > 0) {
          setArg(key2, argAfterEqualSign);
          consumed--;
        }
        for (ii = i2 + 1; ii < consumed + i2 + 1; ii++) {
          setArg(key2, args2[ii]);
        }
        return i2 + consumed;
      }
      function eatArray(i2, key2, args2, argAfterEqualSign) {
        let argsToSet = [];
        let next = argAfterEqualSign || args2[i2 + 1];
        const nargsCount = checkAllAliases(key2, flags.nargs);
        if (checkAllAliases(key2, flags.bools) && !/^(true|false)$/.test(next)) {
          argsToSet.push(true);
        } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
          if (defaults[key2] !== void 0) {
            const defVal = defaults[key2];
            argsToSet = Array.isArray(defVal) ? defVal : [defVal];
          }
        } else {
          if (!isUndefined(argAfterEqualSign)) {
            argsToSet.push(processValue(key2, argAfterEqualSign, true));
          }
          for (let ii = i2 + 1; ii < args2.length; ii++) {
            if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
              break;
            next = args2[ii];
            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
              break;
            i2 = ii;
            argsToSet.push(processValue(key2, next, inputIsString));
          }
        }
        if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
          error = Error(__("Not enough arguments following: %s", key2));
        }
        setArg(key2, argsToSet);
        return i2;
      }
      function setArg(key2, val2, shouldStripQuotes = inputIsString) {
        if (/-/.test(key2) && configuration["camel-case-expansion"]) {
          const alias = key2.split(".").map(function(prop2) {
            return camelCase(prop2);
          }).join(".");
          addNewAlias(key2, alias);
        }
        const value = processValue(key2, val2, shouldStripQuotes);
        const splitKey = key2.split(".");
        setKey(argv, splitKey, value);
        if (flags.aliases[key2]) {
          flags.aliases[key2].forEach(function(x2) {
            const keyProperties = x2.split(".");
            setKey(argv, keyProperties, value);
          });
        }
        if (splitKey.length > 1 && configuration["dot-notation"]) {
          (flags.aliases[splitKey[0]] || []).forEach(function(x2) {
            let keyProperties = x2.split(".");
            const a2 = [].concat(splitKey);
            a2.shift();
            keyProperties = keyProperties.concat(a2);
            if (!(flags.aliases[key2] || []).includes(keyProperties.join("."))) {
              setKey(argv, keyProperties, value);
            }
          });
        }
        if (checkAllAliases(key2, flags.normalize) && !checkAllAliases(key2, flags.arrays)) {
          const keys2 = [key2].concat(flags.aliases[key2] || []);
          keys2.forEach(function(key3) {
            Object.defineProperty(argvReturn, key3, {
              enumerable: true,
              get() {
                return val2;
              },
              set(value2) {
                val2 = typeof value2 === "string" ? mixin.normalize(value2) : value2;
              }
            });
          });
        }
      }
      function addNewAlias(key2, alias) {
        if (!(flags.aliases[key2] && flags.aliases[key2].length)) {
          flags.aliases[key2] = [alias];
          newAliases[alias] = true;
        }
        if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
          addNewAlias(alias, key2);
        }
      }
      function processValue(key2, val2, shouldStripQuotes) {
        if (shouldStripQuotes) {
          val2 = stripQuotes(val2);
        }
        if (checkAllAliases(key2, flags.bools) || checkAllAliases(key2, flags.counts)) {
          if (typeof val2 === "string")
            val2 = val2 === "true";
        }
        let value = Array.isArray(val2) ? val2.map(function(v2) {
          return maybeCoerceNumber(key2, v2);
        }) : maybeCoerceNumber(key2, val2);
        if (checkAllAliases(key2, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
          value = increment2();
        }
        if (checkAllAliases(key2, flags.normalize) && checkAllAliases(key2, flags.arrays)) {
          if (Array.isArray(val2))
            value = val2.map((val3) => {
              return mixin.normalize(val3);
            });
          else
            value = mixin.normalize(val2);
        }
        return value;
      }
      function maybeCoerceNumber(key2, value) {
        if (!configuration["parse-positional-numbers"] && key2 === "_")
          return value;
        if (!checkAllAliases(key2, flags.strings) && !checkAllAliases(key2, flags.bools) && !Array.isArray(value)) {
          const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
          if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key2, flags.numbers)) {
            value = Number(value);
          }
        }
        return value;
      }
      function setConfig(argv2) {
        const configLookup = /* @__PURE__ */ Object.create(null);
        applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
        Object.keys(flags.configs).forEach(function(configKey) {
          const configPath = argv2[configKey] || configLookup[configKey];
          if (configPath) {
            try {
              let config = null;
              const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
              const resolveConfig = flags.configs[configKey];
              if (typeof resolveConfig === "function") {
                try {
                  config = resolveConfig(resolvedConfigPath);
                } catch (e2) {
                  config = e2;
                }
                if (config instanceof Error) {
                  error = config;
                  return;
                }
              } else {
                config = mixin.require(resolvedConfigPath);
              }
              setConfigObject(config);
            } catch (ex) {
              if (ex.name === "PermissionDenied")
                error = ex;
              else if (argv2[configKey])
                error = Error(__("Invalid JSON config file: %s", configPath));
            }
          }
        });
      }
      function setConfigObject(config, prev) {
        Object.keys(config).forEach(function(key2) {
          const value = config[key2];
          const fullKey = prev ? prev + "." + key2 : key2;
          if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
            setConfigObject(value, fullKey);
          } else {
            if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
              setArg(fullKey, value);
            }
          }
        });
      }
      function setConfigObjects() {
        if (typeof configObjects !== "undefined") {
          configObjects.forEach(function(configObject) {
            setConfigObject(configObject);
          });
        }
      }
      function applyEnvVars(argv2, configOnly) {
        if (typeof envPrefix === "undefined")
          return;
        const prefix = typeof envPrefix === "string" ? envPrefix : "";
        const env2 = mixin.env();
        Object.keys(env2).forEach(function(envVar) {
          if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
            const keys2 = envVar.split("__").map(function(key2, i2) {
              if (i2 === 0) {
                key2 = key2.substring(prefix.length);
              }
              return camelCase(key2);
            });
            if ((configOnly && flags.configs[keys2.join(".")] || !configOnly) && !hasKey(argv2, keys2)) {
              setArg(keys2.join("."), env2[envVar]);
            }
          }
        });
      }
      function applyCoercions(argv2) {
        let coerce;
        const applied = /* @__PURE__ */ new Set();
        Object.keys(argv2).forEach(function(key2) {
          if (!applied.has(key2)) {
            coerce = checkAllAliases(key2, flags.coercions);
            if (typeof coerce === "function") {
              try {
                const value = maybeCoerceNumber(key2, coerce(argv2[key2]));
                [].concat(flags.aliases[key2] || [], key2).forEach((ali) => {
                  applied.add(ali);
                  argv2[ali] = value;
                });
              } catch (err) {
                error = err;
              }
            }
          }
        });
      }
      function setPlaceholderKeys(argv2) {
        flags.keys.forEach((key2) => {
          if (~key2.indexOf("."))
            return;
          if (typeof argv2[key2] === "undefined")
            argv2[key2] = void 0;
        });
        return argv2;
      }
      function applyDefaultsAndAliases(obj, aliases3, defaults2, canLog = false) {
        Object.keys(defaults2).forEach(function(key2) {
          if (!hasKey(obj, key2.split("."))) {
            setKey(obj, key2.split("."), defaults2[key2]);
            if (canLog)
              defaulted[key2] = true;
            (aliases3[key2] || []).forEach(function(x2) {
              if (hasKey(obj, x2.split(".")))
                return;
              setKey(obj, x2.split("."), defaults2[key2]);
            });
          }
        });
      }
      function hasKey(obj, keys2) {
        let o2 = obj;
        if (!configuration["dot-notation"])
          keys2 = [keys2.join(".")];
        keys2.slice(0, -1).forEach(function(key3) {
          o2 = o2[key3] || {};
        });
        const key2 = keys2[keys2.length - 1];
        if (typeof o2 !== "object")
          return false;
        else
          return key2 in o2;
      }
      function setKey(obj, keys2, value) {
        let o2 = obj;
        if (!configuration["dot-notation"])
          keys2 = [keys2.join(".")];
        keys2.slice(0, -1).forEach(function(key3) {
          key3 = sanitizeKey(key3);
          if (typeof o2 === "object" && o2[key3] === void 0) {
            o2[key3] = {};
          }
          if (typeof o2[key3] !== "object" || Array.isArray(o2[key3])) {
            if (Array.isArray(o2[key3])) {
              o2[key3].push({});
            } else {
              o2[key3] = [o2[key3], {}];
            }
            o2 = o2[key3][o2[key3].length - 1];
          } else {
            o2 = o2[key3];
          }
        });
        const key2 = sanitizeKey(keys2[keys2.length - 1]);
        const isTypeArray = checkAllAliases(keys2.join("."), flags.arrays);
        const isValueArray = Array.isArray(value);
        let duplicate = configuration["duplicate-arguments-array"];
        if (!duplicate && checkAllAliases(key2, flags.nargs)) {
          duplicate = true;
          if (!isUndefined(o2[key2]) && flags.nargs[key2] === 1 || Array.isArray(o2[key2]) && o2[key2].length === flags.nargs[key2]) {
            o2[key2] = void 0;
          }
        }
        if (value === increment2()) {
          o2[key2] = increment2(o2[key2]);
        } else if (Array.isArray(o2[key2])) {
          if (duplicate && isTypeArray && isValueArray) {
            o2[key2] = configuration["flatten-duplicate-arrays"] ? o2[key2].concat(value) : (Array.isArray(o2[key2][0]) ? o2[key2] : [o2[key2]]).concat([value]);
          } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
            o2[key2] = value;
          } else {
            o2[key2] = o2[key2].concat([value]);
          }
        } else if (o2[key2] === void 0 && isTypeArray) {
          o2[key2] = isValueArray ? value : [value];
        } else if (duplicate && !(o2[key2] === void 0 || checkAllAliases(key2, flags.counts) || checkAllAliases(key2, flags.bools))) {
          o2[key2] = [o2[key2], value];
        } else {
          o2[key2] = value;
        }
      }
      function extendAliases(...args2) {
        args2.forEach(function(obj) {
          Object.keys(obj || {}).forEach(function(key2) {
            if (flags.aliases[key2])
              return;
            flags.aliases[key2] = [].concat(aliases2[key2] || []);
            flags.aliases[key2].concat(key2).forEach(function(x2) {
              if (/-/.test(x2) && configuration["camel-case-expansion"]) {
                const c2 = camelCase(x2);
                if (c2 !== key2 && flags.aliases[key2].indexOf(c2) === -1) {
                  flags.aliases[key2].push(c2);
                  newAliases[c2] = true;
                }
              }
            });
            flags.aliases[key2].concat(key2).forEach(function(x2) {
              if (x2.length > 1 && /[A-Z]/.test(x2) && configuration["camel-case-expansion"]) {
                const c2 = decamelize(x2, "-");
                if (c2 !== key2 && flags.aliases[key2].indexOf(c2) === -1) {
                  flags.aliases[key2].push(c2);
                  newAliases[c2] = true;
                }
              }
            });
            flags.aliases[key2].forEach(function(x2) {
              flags.aliases[x2] = [key2].concat(flags.aliases[key2].filter(function(y2) {
                return x2 !== y2;
              }));
            });
          });
        });
      }
      function checkAllAliases(key2, flag) {
        const toCheck = [].concat(flags.aliases[key2] || [], key2);
        const keys2 = Object.keys(flag);
        const setAlias = toCheck.find((key3) => keys2.includes(key3));
        return setAlias ? flag[setAlias] : false;
      }
      function hasAnyFlag(key2) {
        const flagsKeys = Object.keys(flags);
        const toCheck = [].concat(flagsKeys.map((k2) => flags[k2]));
        return toCheck.some(function(flag) {
          return Array.isArray(flag) ? flag.includes(key2) : flag[key2];
        });
      }
      function hasFlagsMatching(arg, ...patterns) {
        const toCheck = [].concat(...patterns);
        return toCheck.some(function(pattern) {
          const match = arg.match(pattern);
          return match && hasAnyFlag(match[1]);
        });
      }
      function hasAllShortFlags(arg) {
        if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
          return false;
        }
        let hasAllFlags = true;
        let next;
        const letters = arg.slice(1).split("");
        for (let j2 = 0; j2 < letters.length; j2++) {
          next = arg.slice(j2 + 2);
          if (!hasAnyFlag(letters[j2])) {
            hasAllFlags = false;
            break;
          }
          if (letters[j2 + 1] && letters[j2 + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j2]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j2 + 1] && letters[j2 + 1].match(/\W/)) {
            break;
          }
        }
        return hasAllFlags;
      }
      function isUnknownOptionAsArg(arg) {
        return configuration["unknown-options-as-args"] && isUnknownOption(arg);
      }
      function isUnknownOption(arg) {
        arg = arg.replace(/^-{3,}/, "--");
        if (arg.match(negative)) {
          return false;
        }
        if (hasAllShortFlags(arg)) {
          return false;
        }
        const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
        const normalFlag = /^-+([^=]+?)$/;
        const flagEndingInHyphen = /^-+([^=]+?)-$/;
        const flagEndingInDigits = /^-+([^=]+?\d+)$/;
        const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
        return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
      }
      function defaultValue(key2) {
        if (!checkAllAliases(key2, flags.bools) && !checkAllAliases(key2, flags.counts) && `${key2}` in defaults) {
          return defaults[key2];
        } else {
          return defaultForType(guessType(key2));
        }
      }
      function defaultForType(type) {
        const def = {
          [DefaultValuesForTypeKey.BOOLEAN]: true,
          [DefaultValuesForTypeKey.STRING]: "",
          [DefaultValuesForTypeKey.NUMBER]: void 0,
          [DefaultValuesForTypeKey.ARRAY]: []
        };
        return def[type];
      }
      function guessType(key2) {
        let type = DefaultValuesForTypeKey.BOOLEAN;
        if (checkAllAliases(key2, flags.strings))
          type = DefaultValuesForTypeKey.STRING;
        else if (checkAllAliases(key2, flags.numbers))
          type = DefaultValuesForTypeKey.NUMBER;
        else if (checkAllAliases(key2, flags.bools))
          type = DefaultValuesForTypeKey.BOOLEAN;
        else if (checkAllAliases(key2, flags.arrays))
          type = DefaultValuesForTypeKey.ARRAY;
        return type;
      }
      function isUndefined(num) {
        return num === void 0;
      }
      function checkConfiguration() {
        Object.keys(flags.counts).find((key2) => {
          if (checkAllAliases(key2, flags.arrays)) {
            error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key2));
            return true;
          } else if (checkAllAliases(key2, flags.nargs)) {
            error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key2));
            return true;
          }
          return false;
        });
      }
      return {
        aliases: Object.assign({}, flags.aliases),
        argv: Object.assign(argvReturn, argv),
        configuration,
        defaulted: Object.assign({}, defaulted),
        error,
        newAliases: Object.assign({}, newAliases)
      };
    }
  }
  function combineAliases(aliases2) {
    const aliasArrays = [];
    const combined = /* @__PURE__ */ Object.create(null);
    let change = true;
    Object.keys(aliases2).forEach(function(key2) {
      aliasArrays.push([].concat(aliases2[key2], key2));
    });
    while (change) {
      change = false;
      for (let i2 = 0; i2 < aliasArrays.length; i2++) {
        for (let ii = i2 + 1; ii < aliasArrays.length; ii++) {
          const intersect = aliasArrays[i2].filter(function(v2) {
            return aliasArrays[ii].indexOf(v2) !== -1;
          });
          if (intersect.length) {
            aliasArrays[i2] = aliasArrays[i2].concat(aliasArrays[ii]);
            aliasArrays.splice(ii, 1);
            change = true;
            break;
          }
        }
      }
    }
    aliasArrays.forEach(function(aliasArray) {
      aliasArray = aliasArray.filter(function(v2, i2, self2) {
        return self2.indexOf(v2) === i2;
      });
      const lastAlias = aliasArray.pop();
      if (lastAlias !== void 0 && typeof lastAlias === "string") {
        combined[lastAlias] = aliasArray;
      }
    });
    return combined;
  }
  function increment2(orig) {
    return orig !== void 0 ? orig + 1 : 1;
  }
  function sanitizeKey(key2) {
    if (key2 === "__proto__")
      return "___proto___";
    return key2;
  }
  function stripQuotes(val2) {
    return typeof val2 === "string" && (val2[0] === "'" || val2[0] === '"') && val2[val2.length - 1] === val2[0] ? val2.substring(1, val2.length - 1) : val2;
  }
  var _a, _b, _c;
  const minNodeVersion = dist.process && dist.process.env && dist.process.env.YARGS_MIN_NODE_VERSION ? Number(dist.process.env.YARGS_MIN_NODE_VERSION) : 12;
  const nodeVersion = (_b = (_a = dist.process === null || dist.process === void 0 ? void 0 : dist.process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = dist.process === null || dist.process === void 0 ? void 0 : dist.process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
  if (nodeVersion) {
    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
    if (major < minNodeVersion) {
      throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
    }
  }
  const env = dist.process ? dist.process.env : {};
  const parser2 = new YargsParser({
    cwd: dist.process.cwd,
    env: () => {
      return env;
    },
    format: util$1.format,
    normalize: path2.normalize,
    resolve: path2.resolve,
    require: (path3) => {
      if (typeof commonjsRequire !== "undefined") {
        return commonjsRequire(path3);
      } else if (path3.match(/\.json$/)) {
        return JSON.parse(fs.readFileSync(path3, "utf8"));
      } else {
        throw Error("only .json config files are supported in ESM");
      }
    }
  });
  const yargsParser = function Parser3(args, opts) {
    const result = parser2.parse(args.slice(), opts);
    return result.argv;
  };
  yargsParser.detailed = function(args, opts) {
    return parser2.parse(args.slice(), opts);
  };
  yargsParser.camelCase = camelCase;
  yargsParser.decamelize = decamelize;
  yargsParser.looksLikeNumber = looksLikeNumber;
  build$2 = yargsParser;
  return build$2;
}
var stringWidth = { exports: {} };
var ansiRegex;
var hasRequiredAnsiRegex;
function requireAnsiRegex() {
  if (hasRequiredAnsiRegex)
    return ansiRegex;
  hasRequiredAnsiRegex = 1;
  ansiRegex = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
  return ansiRegex;
}
var stripAnsi;
var hasRequiredStripAnsi;
function requireStripAnsi() {
  if (hasRequiredStripAnsi)
    return stripAnsi;
  hasRequiredStripAnsi = 1;
  const ansiRegex2 = requireAnsiRegex();
  stripAnsi = (string) => typeof string === "string" ? string.replace(ansiRegex2(), "") : string;
  return stripAnsi;
}
var isFullwidthCodePoint = { exports: {} };
var hasRequiredIsFullwidthCodePoint;
function requireIsFullwidthCodePoint() {
  if (hasRequiredIsFullwidthCodePoint)
    return isFullwidthCodePoint.exports;
  hasRequiredIsFullwidthCodePoint = 1;
  const isFullwidthCodePoint$1 = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
    codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
    // CJK Radicals Supplement .. Enclosed CJK Letters and Months
    11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
    19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
    43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
    44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
    63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
    65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
    65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
    65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
    110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
    127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  isFullwidthCodePoint.exports = isFullwidthCodePoint$1;
  isFullwidthCodePoint.exports.default = isFullwidthCodePoint$1;
  return isFullwidthCodePoint.exports;
}
var emojiRegex;
var hasRequiredEmojiRegex;
function requireEmojiRegex() {
  if (hasRequiredEmojiRegex)
    return emojiRegex;
  hasRequiredEmojiRegex = 1;
  emojiRegex = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
  return emojiRegex;
}
var hasRequiredStringWidth;
function requireStringWidth() {
  if (hasRequiredStringWidth)
    return stringWidth.exports;
  hasRequiredStringWidth = 1;
  const stripAnsi2 = requireStripAnsi();
  const isFullwidthCodePoint2 = requireIsFullwidthCodePoint();
  const emojiRegex2 = requireEmojiRegex();
  const stringWidth$1 = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi2(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex2(), "  ");
    let width = 0;
    for (let i2 = 0; i2 < string.length; i2++) {
      const code2 = string.codePointAt(i2);
      if (code2 <= 31 || code2 >= 127 && code2 <= 159) {
        continue;
      }
      if (code2 >= 768 && code2 <= 879) {
        continue;
      }
      if (code2 > 65535) {
        i2++;
      }
      width += isFullwidthCodePoint2(code2) ? 2 : 1;
    }
    return width;
  };
  stringWidth.exports = stringWidth$1;
  stringWidth.exports.default = stringWidth$1;
  return stringWidth.exports;
}
var ansiStyles = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName)
    return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
var conversions;
var hasRequiredConversions;
function requireConversions() {
  if (hasRequiredConversions)
    return conversions;
  hasRequiredConversions = 1;
  const cssKeywords = requireColorName();
  const reverseKeywords = {};
  for (const key2 of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key2]] = key2;
  }
  const convert2 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  conversions = convert2;
  for (const model of Object.keys(convert2)) {
    if (!("channels" in convert2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert2[model].labels.length !== convert2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert2[model];
    delete convert2[model].channels;
    delete convert2[model].labels;
    Object.defineProperty(convert2[model], "channels", { value: channels });
    Object.defineProperty(convert2[model], "labels", { value: labels });
  }
  convert2.rgb.hsl = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const min = Math.min(r2, g2, b2);
    const max2 = Math.max(r2, g2, b2);
    const delta = max2 - min;
    let h2;
    let s2;
    if (max2 === min) {
      h2 = 0;
    } else if (r2 === max2) {
      h2 = (g2 - b2) / delta;
    } else if (g2 === max2) {
      h2 = 2 + (b2 - r2) / delta;
    } else if (b2 === max2) {
      h2 = 4 + (r2 - g2) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l2 = (min + max2) / 2;
    if (max2 === min) {
      s2 = 0;
    } else if (l2 <= 0.5) {
      s2 = delta / (max2 + min);
    } else {
      s2 = delta / (2 - max2 - min);
    }
    return [h2, s2 * 100, l2 * 100];
  };
  convert2.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const v2 = Math.max(r2, g2, b2);
    const diff = v2 - Math.min(r2, g2, b2);
    const diffc = function(c2) {
      return (v2 - c2) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff / v2;
      rdif = diffc(r2);
      gdif = diffc(g2);
      bdif = diffc(b2);
      if (r2 === v2) {
        h2 = bdif - gdif;
      } else if (g2 === v2) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b2 === v2) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v2 * 100
    ];
  };
  convert2.rgb.hwb = function(rgb) {
    const r2 = rgb[0];
    const g2 = rgb[1];
    let b2 = rgb[2];
    const h2 = convert2.rgb.hsl(rgb)[0];
    const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
    b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
    return [h2, w2 * 100, b2 * 100];
  };
  convert2.rgb.cmyk = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
    const c2 = (1 - r2 - k2) / (1 - k2) || 0;
    const m2 = (1 - g2 - k2) / (1 - k2) || 0;
    const y2 = (1 - b2 - k2) / (1 - k2) || 0;
    return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
  };
  function comparativeDistance(x2, y2) {
    return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
  }
  convert2.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert2.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert2.rgb.xyz = function(rgb) {
    let r2 = rgb[0] / 255;
    let g2 = rgb[1] / 255;
    let b2 = rgb[2] / 255;
    r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
    g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
    b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
    const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
    const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
    const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
    return [x2 * 100, y2 * 100, z2 * 100];
  };
  convert2.rgb.lab = function(rgb) {
    const xyz = convert2.rgb.xyz(rgb);
    let x2 = xyz[0];
    let y2 = xyz[1];
    let z2 = xyz[2];
    x2 /= 95.047;
    y2 /= 100;
    z2 /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
    const l2 = 116 * y2 - 16;
    const a2 = 500 * (x2 - y2);
    const b2 = 200 * (y2 - z2);
    return [l2, a2, b2];
  };
  convert2.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l2 = hsl[2] / 100;
    let t2;
    let t3;
    let val2;
    if (s2 === 0) {
      val2 = l2 * 255;
      return [val2, val2, val2];
    }
    if (l2 < 0.5) {
      t2 = l2 * (1 + s2);
    } else {
      t2 = l2 + s2 - l2 * s2;
    }
    const t1 = 2 * l2 - t2;
    const rgb = [0, 0, 0];
    for (let i2 = 0; i2 < 3; i2++) {
      t3 = h2 + 1 / 3 * -(i2 - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val2 = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val2 = t2;
      } else if (3 * t3 < 2) {
        val2 = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val2 = t1;
      }
      rgb[i2] = val2 * 255;
    }
    return rgb;
  };
  convert2.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l2 = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l2, 0.01);
    l2 *= 2;
    s2 *= l2 <= 1 ? l2 : 2 - l2;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v2 = (l2 + s2) / 2;
    const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
    return [h2, sv * 100, v2 * 100];
  };
  convert2.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v2 = hsv[2] / 100;
    const hi = Math.floor(h2) % 6;
    const f2 = h2 - Math.floor(h2);
    const p2 = 255 * v2 * (1 - s2);
    const q2 = 255 * v2 * (1 - s2 * f2);
    const t2 = 255 * v2 * (1 - s2 * (1 - f2));
    v2 *= 255;
    switch (hi) {
      case 0:
        return [v2, t2, p2];
      case 1:
        return [q2, v2, p2];
      case 2:
        return [p2, v2, t2];
      case 3:
        return [p2, q2, v2];
      case 4:
        return [t2, p2, v2];
      case 5:
        return [v2, p2, q2];
    }
  };
  convert2.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const vmin = Math.max(v2, 0.01);
    let sl;
    let l2;
    l2 = (2 - s2) * v2;
    const lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l2 /= 2;
    return [h2, sl * 100, l2 * 100];
  };
  convert2.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f2;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i2 = Math.floor(6 * h2);
    const v2 = 1 - bl;
    f2 = 6 * h2 - i2;
    if ((i2 & 1) !== 0) {
      f2 = 1 - f2;
    }
    const n2 = wh + f2 * (v2 - wh);
    let r2;
    let g2;
    let b2;
    switch (i2) {
      default:
      case 6:
      case 0:
        r2 = v2;
        g2 = n2;
        b2 = wh;
        break;
      case 1:
        r2 = n2;
        g2 = v2;
        b2 = wh;
        break;
      case 2:
        r2 = wh;
        g2 = v2;
        b2 = n2;
        break;
      case 3:
        r2 = wh;
        g2 = n2;
        b2 = v2;
        break;
      case 4:
        r2 = n2;
        g2 = wh;
        b2 = v2;
        break;
      case 5:
        r2 = v2;
        g2 = wh;
        b2 = n2;
        break;
    }
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert2.cmyk.rgb = function(cmyk) {
    const c2 = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y2 = cmyk[2] / 100;
    const k2 = cmyk[3] / 100;
    const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
    const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
    const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert2.xyz.rgb = function(xyz) {
    const x2 = xyz[0] / 100;
    const y2 = xyz[1] / 100;
    const z2 = xyz[2] / 100;
    let r2;
    let g2;
    let b2;
    r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
    g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
    b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
    r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
    g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
    b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
    r2 = Math.min(Math.max(0, r2), 1);
    g2 = Math.min(Math.max(0, g2), 1);
    b2 = Math.min(Math.max(0, b2), 1);
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert2.xyz.lab = function(xyz) {
    let x2 = xyz[0];
    let y2 = xyz[1];
    let z2 = xyz[2];
    x2 /= 95.047;
    y2 /= 100;
    z2 /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
    const l2 = 116 * y2 - 16;
    const a2 = 500 * (x2 - y2);
    const b2 = 200 * (y2 - z2);
    return [l2, a2, b2];
  };
  convert2.lab.xyz = function(lab) {
    const l2 = lab[0];
    const a2 = lab[1];
    const b2 = lab[2];
    let x2;
    let y2;
    let z2;
    y2 = (l2 + 16) / 116;
    x2 = a2 / 500 + y2;
    z2 = y2 - b2 / 200;
    const y22 = y2 ** 3;
    const x22 = x2 ** 3;
    const z22 = z2 ** 3;
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
    z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
    x2 *= 95.047;
    y2 *= 100;
    z2 *= 108.883;
    return [x2, y2, z2];
  };
  convert2.lab.lch = function(lab) {
    const l2 = lab[0];
    const a2 = lab[1];
    const b2 = lab[2];
    let h2;
    const hr = Math.atan2(b2, a2);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c2 = Math.sqrt(a2 * a2 + b2 * b2);
    return [l2, c2, h2];
  };
  convert2.lch.lab = function(lch) {
    const l2 = lch[0];
    const c2 = lch[1];
    const h2 = lch[2];
    const hr = h2 / 360 * 2 * Math.PI;
    const a2 = c2 * Math.cos(hr);
    const b2 = c2 * Math.sin(hr);
    return [l2, a2, b2];
  };
  convert2.rgb.ansi16 = function(args, saturation = null) {
    const [r2, g2, b2] = args;
    let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert2.hsv.ansi16 = function(args) {
    return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
  };
  convert2.rgb.ansi256 = function(args) {
    const r2 = args[0];
    const g2 = args[1];
    const b2 = args[2];
    if (r2 === g2 && g2 === b2) {
      if (r2 < 8) {
        return 16;
      }
      if (r2 > 248) {
        return 231;
      }
      return Math.round((r2 - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
    return ansi;
  };
  convert2.ansi16.rgb = function(args) {
    let color2 = args % 10;
    if (color2 === 0 || color2 === 7) {
      if (args > 50) {
        color2 += 3.5;
      }
      color2 = color2 / 10.5 * 255;
      return [color2, color2, color2];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r2 = (color2 & 1) * mult * 255;
    const g2 = (color2 >> 1 & 1) * mult * 255;
    const b2 = (color2 >> 2 & 1) * mult * 255;
    return [r2, g2, b2];
  };
  convert2.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c2 = (args - 232) * 10 + 8;
      return [c2, c2, c2];
    }
    args -= 16;
    let rem;
    const r2 = Math.floor(args / 36) / 5 * 255;
    const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b2 = rem % 6 / 5 * 255;
    return [r2, g2, b2];
  };
  convert2.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert2.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r2 = integer >> 16 & 255;
    const g2 = integer >> 8 & 255;
    const b2 = integer & 255;
    return [r2, g2, b2];
  };
  convert2.rgb.hcg = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const max2 = Math.max(Math.max(r2, g2), b2);
    const min = Math.min(Math.min(r2, g2), b2);
    const chroma = max2 - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r2) {
      hue = (g2 - b2) / chroma % 6;
    } else if (max2 === g2) {
      hue = 2 + (b2 - r2) / chroma;
    } else {
      hue = 4 + (r2 - g2) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert2.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l2 = hsl[2] / 100;
    const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
    let f2 = 0;
    if (c2 < 1) {
      f2 = (l2 - 0.5 * c2) / (1 - c2);
    }
    return [hsl[0], c2 * 100, f2 * 100];
  };
  convert2.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const c2 = s2 * v2;
    let f2 = 0;
    if (c2 < 1) {
      f2 = (v2 - c2) / (1 - c2);
    }
    return [hsv[0], c2 * 100, f2 * 100];
  };
  convert2.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    if (c2 === 0) {
      return [g2 * 255, g2 * 255, g2 * 255];
    }
    const pure = [0, 0, 0];
    const hi = h2 % 1 * 6;
    const v2 = hi % 1;
    const w2 = 1 - v2;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v2;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v2;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v2;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg = (1 - c2) * g2;
    return [
      (c2 * pure[0] + mg) * 255,
      (c2 * pure[1] + mg) * 255,
      (c2 * pure[2] + mg) * 255
    ];
  };
  convert2.hcg.hsv = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c2 + g2 * (1 - c2);
    let f2 = 0;
    if (v2 > 0) {
      f2 = c2 / v2;
    }
    return [hcg[0], f2 * 100, v2 * 100];
  };
  convert2.hcg.hsl = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const l2 = g2 * (1 - c2) + 0.5 * c2;
    let s2 = 0;
    if (l2 > 0 && l2 < 0.5) {
      s2 = c2 / (2 * l2);
    } else if (l2 >= 0.5 && l2 < 1) {
      s2 = c2 / (2 * (1 - l2));
    }
    return [hcg[0], s2 * 100, l2 * 100];
  };
  convert2.hcg.hwb = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c2 + g2 * (1 - c2);
    return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
  };
  convert2.hwb.hcg = function(hwb) {
    const w2 = hwb[1] / 100;
    const b2 = hwb[2] / 100;
    const v2 = 1 - b2;
    const c2 = v2 - w2;
    let g2 = 0;
    if (c2 < 1) {
      g2 = (v2 - c2) / (1 - c2);
    }
    return [hwb[0], c2 * 100, g2 * 100];
  };
  convert2.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert2.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert2.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert2.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert2.gray.hsv = convert2.gray.hsl;
  convert2.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert2.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert2.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert2.gray.hex = function(gray) {
    const val2 = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val2 << 16) + (val2 << 8) + val2;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert2.rgb.gray = function(rgb) {
    const val2 = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val2 / 255 * 100];
  };
  return conversions;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute)
    return route;
  hasRequiredRoute = 1;
  const conversions2 = requireConversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions2);
    for (let len = models.length, i2 = 0; i2 < len; i2++) {
      graph[models[i2]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue2 = [fromModel];
    graph[fromModel].distance = 0;
    while (queue2.length) {
      const current = queue2.pop();
      const adjacents = Object.keys(conversions2[current]);
      for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
        const adjacent = adjacents[i2];
        const node2 = graph[adjacent];
        if (node2.distance === -1) {
          node2.distance = graph[current].distance + 1;
          node2.parent = current;
          queue2.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions2[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions2[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  route = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i2 = 0; i2 < len; i2++) {
      const toModel = models[i2];
      const node2 = graph[toModel];
      if (node2.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  return route;
}
var colorConvert;
var hasRequiredColorConvert;
function requireColorConvert() {
  if (hasRequiredColorConvert)
    return colorConvert;
  hasRequiredColorConvert = 1;
  const conversions2 = requireConversions();
  const route2 = requireRoute();
  const convert2 = {};
  const models = Object.keys(conversions2);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i2 = 0; i2 < len; i2++) {
          result[i2] = Math.round(result[i2]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", { value: conversions2[fromModel].channels });
    Object.defineProperty(convert2[fromModel], "labels", { value: conversions2[fromModel].labels });
    const routes = route2(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert2[fromModel][toModel] = wrapRounded(fn);
      convert2[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  colorConvert = convert2;
  return colorConvert;
}
ansiStyles.exports;
var hasRequiredAnsiStyles;
function requireAnsiStyles() {
  if (hasRequiredAnsiStyles)
    return ansiStyles.exports;
  hasRequiredAnsiStyles = 1;
  (function(module2) {
    const wrapAnsi16 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${code2 + offset}m`;
    };
    const wrapAnsi256 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${38 + offset};5;${code2}m`;
    };
    const wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    const ansi2ansi = (n2) => n2;
    const rgb2rgb = (r2, g2, b2) => [r2, g2, b2];
    const setLazyProperty = (object, property2, get2) => {
      Object.defineProperty(object, property2, {
        get: () => {
          const value = get2();
          Object.defineProperty(object, property2, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    let colorConvert2;
    const makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert2 === void 0) {
        colorConvert2 = requireColorConvert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert2)) {
        const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name2] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles[name2] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style2] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style2[0]}m`,
            close: `\x1B[${style2[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style2[0], style2[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  })(ansiStyles);
  return ansiStyles.exports;
}
var wrapAnsi_1;
var hasRequiredWrapAnsi;
function requireWrapAnsi() {
  if (hasRequiredWrapAnsi)
    return wrapAnsi_1;
  hasRequiredWrapAnsi = 1;
  const stringWidth2 = requireStringWidth();
  const stripAnsi2 = requireStripAnsi();
  const ansiStyles2 = requireAnsiStyles();
  const ESCAPES = /* @__PURE__ */ new Set([
    "\x1B",
    ""
  ]);
  const END_CODE = 39;
  const ANSI_ESCAPE_BELL = "\x07";
  const ANSI_CSI = "[";
  const ANSI_OSC = "]";
  const ANSI_SGR_TERMINATOR = "m";
  const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
  const wrapAnsi = (code2) => `${ESCAPES.values().next().value}${ANSI_CSI}${code2}${ANSI_SGR_TERMINATOR}`;
  const wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
  const wordLengths = (string) => string.split(" ").map((character) => stringWidth2(character));
  const wrapWord = (rows, word, columns) => {
    const characters2 = [...word];
    let isInsideEscape = false;
    let isInsideLinkEscape = false;
    let visible = stringWidth2(stripAnsi2(rows[rows.length - 1]));
    for (const [index2, character] of characters2.entries()) {
      const characterLength = stringWidth2(character);
      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }
      if (ESCAPES.has(character)) {
        isInsideEscape = true;
        isInsideLinkEscape = characters2.slice(index2 + 1).join("").startsWith(ANSI_ESCAPE_LINK);
      }
      if (isInsideEscape) {
        if (isInsideLinkEscape) {
          if (character === ANSI_ESCAPE_BELL) {
            isInsideEscape = false;
            isInsideLinkEscape = false;
          }
        } else if (character === ANSI_SGR_TERMINATOR) {
          isInsideEscape = false;
        }
        continue;
      }
      visible += characterLength;
      if (visible === columns && index2 < characters2.length - 1) {
        rows.push("");
        visible = 0;
      }
    }
    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
      rows[rows.length - 2] += rows.pop();
    }
  };
  const stringVisibleTrimSpacesRight = (string) => {
    const words = string.split(" ");
    let last2 = words.length;
    while (last2 > 0) {
      if (stringWidth2(words[last2 - 1]) > 0) {
        break;
      }
      last2--;
    }
    if (last2 === words.length) {
      return string;
    }
    return words.slice(0, last2).join(" ") + words.slice(last2).join("");
  };
  const exec2 = (string, columns, options2 = {}) => {
    if (options2.trim !== false && string.trim() === "") {
      return "";
    }
    let returnValue = "";
    let escapeCode;
    let escapeUrl;
    const lengths = wordLengths(string);
    let rows = [""];
    for (const [index2, word] of string.split(" ").entries()) {
      if (options2.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimStart();
      }
      let rowLength = stringWidth2(rows[rows.length - 1]);
      if (index2 !== 0) {
        if (rowLength >= columns && (options2.wordWrap === false || options2.trim === false)) {
          rows.push("");
          rowLength = 0;
        }
        if (rowLength > 0 || options2.trim === false) {
          rows[rows.length - 1] += " ";
          rowLength++;
        }
      }
      if (options2.hard && lengths[index2] > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine = 1 + Math.floor((lengths[index2] - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor((lengths[index2] - 1) / columns);
        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push("");
        }
        wrapWord(rows, word, columns);
        continue;
      }
      if (rowLength + lengths[index2] > columns && rowLength > 0 && lengths[index2] > 0) {
        if (options2.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows.push("");
      }
      if (rowLength + lengths[index2] > columns && options2.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows[rows.length - 1] += word;
    }
    if (options2.trim !== false) {
      rows = rows.map(stringVisibleTrimSpacesRight);
    }
    const pre = [...rows.join("\n")];
    for (const [index2, character] of pre.entries()) {
      returnValue += character;
      if (ESCAPES.has(character)) {
        const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index2).join("")) || { groups: {} };
        if (groups.code !== void 0) {
          const code3 = Number.parseFloat(groups.code);
          escapeCode = code3 === END_CODE ? void 0 : code3;
        } else if (groups.uri !== void 0) {
          escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
        }
      }
      const code2 = ansiStyles2.codes.get(Number(escapeCode));
      if (pre[index2 + 1] === "\n") {
        if (escapeUrl) {
          returnValue += wrapAnsiHyperlink("");
        }
        if (escapeCode && code2) {
          returnValue += wrapAnsi(code2);
        }
      } else if (character === "\n") {
        if (escapeCode && code2) {
          returnValue += wrapAnsi(escapeCode);
        }
        if (escapeUrl) {
          returnValue += wrapAnsiHyperlink(escapeUrl);
        }
      }
    }
    return returnValue;
  };
  wrapAnsi_1 = (string, columns, options2) => {
    return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec2(line, columns, options2)).join("\n");
  };
  return wrapAnsi_1;
}
var build$1;
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild)
    return build$1;
  hasRequiredBuild = 1;
  const align = {
    right: alignRight,
    center: alignCenter
  };
  const top = 0;
  const right = 1;
  const bottom = 2;
  const left = 3;
  class UI {
    constructor(opts) {
      var _a;
      this.width = opts.width;
      this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
      this.rows = [];
    }
    span(...args) {
      const cols = this.div(...args);
      cols.span = true;
    }
    resetOutput() {
      this.rows = [];
    }
    div(...args) {
      if (args.length === 0) {
        this.div("");
      }
      if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
        return this.applyLayoutDSL(args[0]);
      }
      const cols = args.map((arg) => {
        if (typeof arg === "string") {
          return this.colFromString(arg);
        }
        return arg;
      });
      this.rows.push(cols);
      return cols;
    }
    shouldApplyLayoutDSL(...args) {
      return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
      const rows = str.split("\n").map((row) => row.split("	"));
      let leftColumnWidth = 0;
      rows.forEach((columns) => {
        if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
          leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
        }
      });
      rows.forEach((columns) => {
        this.div(...columns.map((r2, i2) => {
          return {
            text: r2.trim(),
            padding: this.measurePadding(r2),
            width: i2 === 0 && columns.length > 1 ? leftColumnWidth : void 0
          };
        }));
      });
      return this.rows[this.rows.length - 1];
    }
    colFromString(text2) {
      return {
        text: text2,
        padding: this.measurePadding(text2)
      };
    }
    measurePadding(str) {
      const noAnsi = mixin.stripAnsi(str);
      return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
      const lines = [];
      this.rows.forEach((row) => {
        this.rowToString(row, lines);
      });
      return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
    }
    rowToString(row, lines) {
      this.rasterize(row).forEach((rrow, r2) => {
        let str = "";
        rrow.forEach((col, c2) => {
          const { width } = row[c2];
          const wrapWidth = this.negatePadding(row[c2]);
          let ts = col;
          if (wrapWidth > mixin.stringWidth(col)) {
            ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
          }
          if (row[c2].align && row[c2].align !== "left" && this.wrap) {
            const fn = align[row[c2].align];
            ts = fn(ts, wrapWidth);
            if (mixin.stringWidth(ts) < wrapWidth) {
              ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
            }
          }
          const padding = row[c2].padding || [0, 0, 0, 0];
          if (padding[left]) {
            str += " ".repeat(padding[left]);
          }
          str += addBorder(row[c2], ts, "| ");
          str += ts;
          str += addBorder(row[c2], ts, " |");
          if (padding[right]) {
            str += " ".repeat(padding[right]);
          }
          if (r2 === 0 && lines.length > 0) {
            str = this.renderInline(str, lines[lines.length - 1]);
          }
        });
        lines.push({
          text: str.replace(/ +$/, ""),
          span: row.span
        });
      });
      return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
      const match = source.match(/^ */);
      const leadingWhitespace = match ? match[0].length : 0;
      const target = previousLine.text;
      const targetTextWidth = mixin.stringWidth(target.trimRight());
      if (!previousLine.span) {
        return source;
      }
      if (!this.wrap) {
        previousLine.hidden = true;
        return target + source;
      }
      if (leadingWhitespace < targetTextWidth) {
        return source;
      }
      previousLine.hidden = true;
      return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
      const rrows = [];
      const widths = this.columnWidths(row);
      let wrapped;
      row.forEach((col, c2) => {
        col.width = widths[c2];
        if (this.wrap) {
          wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
        } else {
          wrapped = col.text.split("\n");
        }
        if (col.border) {
          wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
          wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
        }
        if (col.padding) {
          wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
          wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
        }
        wrapped.forEach((str, r2) => {
          if (!rrows[r2]) {
            rrows.push([]);
          }
          const rrow = rrows[r2];
          for (let i2 = 0; i2 < c2; i2++) {
            if (rrow[i2] === void 0) {
              rrow.push("");
            }
          }
          rrow.push(str);
        });
      });
      return rrows;
    }
    negatePadding(col) {
      let wrapWidth = col.width || 0;
      if (col.padding) {
        wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
      }
      if (col.border) {
        wrapWidth -= 4;
      }
      return wrapWidth;
    }
    columnWidths(row) {
      if (!this.wrap) {
        return row.map((col) => {
          return col.width || mixin.stringWidth(col.text);
        });
      }
      let unset = row.length;
      let remainingWidth = this.width;
      const widths = row.map((col) => {
        if (col.width) {
          unset--;
          remainingWidth -= col.width;
          return col.width;
        }
        return void 0;
      });
      const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
      return widths.map((w2, i2) => {
        if (w2 === void 0) {
          return Math.max(unsetWidth, _minWidth(row[i2]));
        }
        return w2;
      });
    }
  }
  function addBorder(col, ts, style2) {
    if (col.border) {
      if (/[.']-+[.']/.test(ts)) {
        return "";
      }
      if (ts.trim().length !== 0) {
        return style2;
      }
      return "  ";
    }
    return "";
  }
  function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
      return minWidth + 4;
    }
    return minWidth;
  }
  function getWindowWidth() {
    if (typeof dist.process === "object" && dist.process.stdout && dist.process.stdout.columns) {
      return dist.process.stdout.columns;
    }
    return 80;
  }
  function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
      return " ".repeat(width - strWidth) + str;
    }
    return str;
  }
  function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth >= width) {
      return str;
    }
    return " ".repeat(width - strWidth >> 1) + str;
  }
  let mixin;
  function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
      width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
      wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
  }
  const stringWidth2 = requireStringWidth();
  const stripAnsi2 = requireStripAnsi();
  const wrap2 = requireWrapAnsi();
  function ui(opts) {
    return cliui(opts, {
      stringWidth: stringWidth2,
      stripAnsi: stripAnsi2,
      wrap: wrap2
    });
  }
  build$1 = ui;
  return build$1;
}
var sync;
var hasRequiredSync;
function requireSync() {
  if (hasRequiredSync)
    return sync;
  hasRequiredSync = 1;
  const { dirname: dirname2, resolve } = requirePathBrowserify();
  const { readdirSync, statSync } = require$$1;
  sync = function(start, callback) {
    let dir2 = resolve(".", start);
    let tmp, stats = statSync(dir2);
    if (!stats.isDirectory()) {
      dir2 = dirname2(dir2);
    }
    while (true) {
      tmp = callback(dir2, readdirSync(dir2));
      if (tmp)
        return resolve(dir2, tmp);
      dir2 = dirname2(tmp = dir2);
      if (tmp === dir2)
        break;
    }
  };
  return sync;
}
var getCallerFile;
var hasRequiredGetCallerFile;
function requireGetCallerFile() {
  if (hasRequiredGetCallerFile)
    return getCallerFile;
  hasRequiredGetCallerFile = 1;
  getCallerFile = function getCallerFile2(position2) {
    if (position2 === void 0) {
      position2 = 2;
    }
    if (position2 >= Error.stackTraceLimit) {
      throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position2 + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
    }
    var oldPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_2, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = oldPrepareStackTrace;
    if (stack !== null && typeof stack === "object") {
      return stack[position2] ? stack[position2].getFileName() : void 0;
    }
  };
  return getCallerFile;
}
var requireDirectory = { exports: {} };
var hasRequiredRequireDirectory;
function requireRequireDirectory() {
  if (hasRequiredRequireDirectory)
    return requireDirectory.exports;
  hasRequiredRequireDirectory = 1;
  var fs = require$$1, join2 = requirePathBrowserify().join, resolve = requirePathBrowserify().resolve, dirname2 = requirePathBrowserify().dirname, defaultOptions = {
    extensions: ["js", "json", "coffee"],
    recurse: true,
    rename: function(name2) {
      return name2;
    },
    visit: function(obj) {
      return obj;
    }
  };
  function checkFileInclusion(path2, filename, options2) {
    return (
      // verify file has valid extension
      new RegExp("\\.(" + options2.extensions.join("|") + ")$", "i").test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes
      !(options2.include && options2.include instanceof RegExp && !options2.include.test(path2)) && // if options.include is a function, evaluate it and make sure the path passes
      !(options2.include && typeof options2.include === "function" && !options2.include(path2, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
      !(options2.exclude && options2.exclude instanceof RegExp && options2.exclude.test(path2)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass
      !(options2.exclude && typeof options2.exclude === "function" && options2.exclude(path2, filename))
    );
  }
  function requireDirectory$1(m2, path2, options2) {
    var retval = {};
    if (path2 && !options2 && typeof path2 !== "string") {
      options2 = path2;
      path2 = null;
    }
    options2 = options2 || {};
    for (var prop2 in defaultOptions) {
      if (typeof options2[prop2] === "undefined") {
        options2[prop2] = defaultOptions[prop2];
      }
    }
    path2 = !path2 ? dirname2(m2.filename) : resolve(dirname2(m2.filename), path2);
    fs.readdirSync(path2).forEach(function(filename) {
      var joined = join2(path2, filename), files, key2, obj;
      if (fs.statSync(joined).isDirectory() && options2.recurse) {
        files = requireDirectory$1(m2, joined, options2);
        if (Object.keys(files).length) {
          retval[options2.rename(filename, joined, filename)] = files;
        }
      } else {
        if (joined !== m2.filename && checkFileInclusion(joined, filename, options2)) {
          key2 = filename.substring(0, filename.lastIndexOf("."));
          obj = m2.require(joined);
          retval[options2.rename(key2, joined, filename)] = options2.visit(obj, joined, filename) || obj;
        }
      }
    });
    return retval;
  }
  requireDirectory.exports = requireDirectory$1;
  requireDirectory.exports.defaults = defaultOptions;
  return requireDirectory.exports;
}
var t = requireAssert();
class e extends Error {
  constructor(t2) {
    super(t2 || "yargs error"), this.name = "YError", Error.captureStackTrace && Error.captureStackTrace(this, e);
  }
}
let s, i = [];
function n(t2, o2, a2, h2) {
  s = h2;
  let l2 = {};
  if (Object.prototype.hasOwnProperty.call(t2, "extends")) {
    if ("string" != typeof t2.extends)
      return l2;
    const r2 = /\.json|\..*rc$/.test(t2.extends);
    let h3 = null;
    if (r2)
      h3 = function(t3, e2) {
        return s.path.resolve(t3, e2);
      }(o2, t2.extends);
    else
      try {
        h3 = require.resolve(t2.extends);
      } catch (e2) {
        return t2;
      }
    !function(t3) {
      if (i.indexOf(t3) > -1)
        throw new e(`Circular extended configurations: '${t3}'.`);
    }(h3), i.push(h3), l2 = r2 ? JSON.parse(s.readFileSync(h3, "utf8")) : commonjsRequire(t2.extends), delete t2.extends, l2 = n(l2, s.path.dirname(h3), a2, s);
  }
  return i = [], a2 ? r(l2, t2) : Object.assign({}, l2, t2);
}
function r(t2, e2) {
  const s2 = {};
  function i2(t3) {
    return t3 && "object" == typeof t3 && !Array.isArray(t3);
  }
  Object.assign(s2, t2);
  for (const n2 of Object.keys(e2))
    i2(e2[n2]) && i2(s2[n2]) ? s2[n2] = r(t2[n2], e2[n2]) : s2[n2] = e2[n2];
  return s2;
}
function o(t2) {
  const e2 = t2.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/), s2 = /\.*[\][<>]/g, i2 = e2.shift();
  if (!i2)
    throw new Error(`No command found in: ${t2}`);
  const n2 = { cmd: i2.replace(s2, ""), demanded: [], optional: [] };
  return e2.forEach((t3, i3) => {
    let r2 = false;
    t3 = t3.replace(/\s/g, ""), /\.+[\]>]/.test(t3) && i3 === e2.length - 1 && (r2 = true), /^\[/.test(t3) ? n2.optional.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 }) : n2.demanded.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 });
  }), n2;
}
const a = ["first", "second", "third", "fourth", "fifth", "sixth"];
function h(t2, s2, i2) {
  try {
    let n2 = 0;
    const [r2, a2, h2] = "object" == typeof t2 ? [{ demanded: [], optional: [] }, t2, s2] : [o(`cmd ${t2}`), s2, i2], f2 = [].slice.call(a2);
    for (; f2.length && void 0 === f2[f2.length - 1]; )
      f2.pop();
    const d2 = h2 || f2.length;
    if (d2 < r2.demanded.length)
      throw new e(`Not enough arguments provided. Expected ${r2.demanded.length} but received ${f2.length}.`);
    const u2 = r2.demanded.length + r2.optional.length;
    if (d2 > u2)
      throw new e(`Too many arguments provided. Expected max ${u2} but received ${d2}.`);
    r2.demanded.forEach((t3) => {
      const e2 = l(f2.shift());
      0 === t3.cmd.filter((t4) => t4 === e2 || "*" === t4).length && c(e2, t3.cmd, n2), n2 += 1;
    }), r2.optional.forEach((t3) => {
      if (0 === f2.length)
        return;
      const e2 = l(f2.shift());
      0 === t3.cmd.filter((t4) => t4 === e2 || "*" === t4).length && c(e2, t3.cmd, n2), n2 += 1;
    });
  } catch (t3) {
    console.warn(t3.stack);
  }
}
function l(t2) {
  return Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
}
function c(t2, s2, i2) {
  throw new e(`Invalid ${a[i2] || "manyith"} argument. Expected ${s2.join(" or ")} but received ${t2}.`);
}
function f(t2) {
  return !!t2 && !!t2.then && "function" == typeof t2.then;
}
function d(t2, e2, s2, i2) {
  s2.assert.notStrictEqual(t2, e2, i2);
}
function u(t2, e2) {
  e2.assert.strictEqual(typeof t2, "string");
}
function p(t2) {
  return Object.keys(t2);
}
function g(t2 = {}, e2 = () => true) {
  const s2 = {};
  return p(t2).forEach((i2) => {
    e2(i2, t2[i2]) && (s2[i2] = t2[i2]);
  }), s2;
}
function m() {
  return dist.process.versions.electron && !dist.process.defaultApp ? 0 : 1;
}
function y$1() {
  return dist.process.argv[m()];
}
var b = Object.freeze({ __proto__: null, hideBin: function(t2) {
  return t2.slice(m() + 1);
}, getProcessArgvBin: y$1 });
function v(t2, e2, s2, i2) {
  if ("a" === s2 && !i2)
    throw new TypeError("Private accessor was defined without a getter");
  if ("function" == typeof e2 ? t2 !== e2 || !i2 : !e2.has(t2))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return "m" === s2 ? i2 : "a" === s2 ? i2.call(t2) : i2 ? i2.value : e2.get(t2);
}
function O(t2, e2, s2, i2, n2) {
  if ("m" === i2)
    throw new TypeError("Private method is not writable");
  if ("a" === i2 && !n2)
    throw new TypeError("Private accessor was defined without a setter");
  if ("function" == typeof e2 ? t2 !== e2 || !n2 : !e2.has(t2))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return "a" === i2 ? n2.call(t2, s2) : n2 ? n2.value = s2 : e2.set(t2, s2), s2;
}
class w {
  constructor(t2) {
    this.globalMiddleware = [], this.frozens = [], this.yargs = t2;
  }
  addMiddleware(t2, e2, s2 = true, i2 = false) {
    if (h("<array|function> [boolean] [boolean] [boolean]", [t2, e2, s2], arguments.length), Array.isArray(t2)) {
      for (let i3 = 0; i3 < t2.length; i3++) {
        if ("function" != typeof t2[i3])
          throw Error("middleware must be a function");
        const n2 = t2[i3];
        n2.applyBeforeValidation = e2, n2.global = s2;
      }
      Array.prototype.push.apply(this.globalMiddleware, t2);
    } else if ("function" == typeof t2) {
      const n2 = t2;
      n2.applyBeforeValidation = e2, n2.global = s2, n2.mutates = i2, this.globalMiddleware.push(t2);
    }
    return this.yargs;
  }
  addCoerceMiddleware(t2, e2) {
    const s2 = this.yargs.getAliases();
    return this.globalMiddleware = this.globalMiddleware.filter((t3) => {
      const i2 = [...s2[e2] || [], e2];
      return !t3.option || !i2.includes(t3.option);
    }), t2.option = e2, this.addMiddleware(t2, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const t2 = this.frozens.pop();
    void 0 !== t2 && (this.globalMiddleware = t2);
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((t2) => t2.global);
  }
}
function C(t2, e2, s2, i2) {
  return s2.reduce((t3, s3) => {
    if (s3.applyBeforeValidation !== i2)
      return t3;
    if (s3.mutates) {
      if (s3.applied)
        return t3;
      s3.applied = true;
    }
    if (f(t3))
      return t3.then((t4) => Promise.all([t4, s3(t4, e2)])).then(([t4, e3]) => Object.assign(t4, e3));
    {
      const i3 = s3(t3, e2);
      return f(i3) ? i3.then((e3) => Object.assign(t3, e3)) : Object.assign(t3, i3);
    }
  }, t2);
}
function j(t2, e2, s2 = (t3) => {
  throw t3;
}) {
  try {
    const s3 = "function" == typeof t2 ? t2() : t2;
    return f(s3) ? s3.then((t3) => e2(t3)) : e2(s3);
  } catch (t3) {
    return s2(t3);
  }
}
const M = /(^\*)|(^\$0)/;
class _ {
  constructor(t2, e2, s2, i2) {
    this.requireCache = /* @__PURE__ */ new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i2, this.usage = t2, this.globalMiddleware = s2, this.validation = e2;
  }
  addDirectory(t2, e2, s2, i2) {
    "boolean" != typeof (i2 = i2 || {}).recurse && (i2.recurse = false), Array.isArray(i2.extensions) || (i2.extensions = ["js"]);
    const n2 = "function" == typeof i2.visit ? i2.visit : (t3) => t3;
    i2.visit = (t3, e3, s3) => {
      const i3 = n2(t3, e3, s3);
      if (i3) {
        if (this.requireCache.has(e3))
          return i3;
        this.requireCache.add(e3), this.addHandler(i3);
      }
      return i3;
    }, this.shim.requireDirectory({ require: e2, filename: s2 }, t2, i2);
  }
  addHandler(t2, e2, s2, i2, n2, r2) {
    let a2 = [];
    const h2 = function(t3) {
      return t3 ? t3.map((t4) => (t4.applyBeforeValidation = false, t4)) : [];
    }(n2);
    if (i2 = i2 || (() => {
    }), Array.isArray(t2))
      if (function(t3) {
        return t3.every((t4) => "string" == typeof t4);
      }(t2))
        [t2, ...a2] = t2;
      else
        for (const e3 of t2)
          this.addHandler(e3);
    else {
      if (function(t3) {
        return "object" == typeof t3 && !Array.isArray(t3);
      }(t2)) {
        let e3 = Array.isArray(t2.command) || "string" == typeof t2.command ? t2.command : this.moduleName(t2);
        return t2.aliases && (e3 = [].concat(e3).concat(t2.aliases)), void this.addHandler(e3, this.extractDesc(t2), t2.builder, t2.handler, t2.middlewares, t2.deprecated);
      }
      if (k(s2))
        return void this.addHandler([t2].concat(a2), e2, s2.builder, s2.handler, s2.middlewares, s2.deprecated);
    }
    if ("string" == typeof t2) {
      const n3 = o(t2);
      a2 = a2.map((t3) => o(t3).cmd);
      let l2 = false;
      const c2 = [n3.cmd].concat(a2).filter((t3) => !M.test(t3) || (l2 = true, false));
      0 === c2.length && l2 && c2.push("$0"), l2 && (n3.cmd = c2[0], a2 = c2.slice(1), t2 = t2.replace(M, n3.cmd)), a2.forEach((t3) => {
        this.aliasMap[t3] = n3.cmd;
      }), false !== e2 && this.usage.command(t2, e2, l2, a2, r2), this.handlers[n3.cmd] = { original: t2, description: e2, handler: i2, builder: s2 || {}, middlewares: h2, deprecated: r2, demanded: n3.demanded, optional: n3.optional }, l2 && (this.defaultCommand = this.handlers[n3.cmd]);
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(t2, e2, s2, i2, n2, r2) {
    const o2 = this.handlers[t2] || this.handlers[this.aliasMap[t2]] || this.defaultCommand, a2 = e2.getInternalMethods().getContext(), h2 = a2.commands.slice(), l2 = !t2;
    t2 && (a2.commands.push(t2), a2.fullCommands.push(o2.original));
    const c2 = this.applyBuilderUpdateUsageAndParse(l2, o2, e2, s2.aliases, h2, i2, n2, r2);
    return f(c2) ? c2.then((t3) => this.applyMiddlewareAndGetResult(l2, o2, t3.innerArgv, a2, n2, t3.aliases, e2)) : this.applyMiddlewareAndGetResult(l2, o2, c2.innerArgv, a2, n2, c2.aliases, e2);
  }
  applyBuilderUpdateUsageAndParse(t2, e2, s2, i2, n2, r2, o2, a2) {
    const h2 = e2.builder;
    let l2 = s2;
    if (x(h2)) {
      s2.getInternalMethods().getUsageInstance().freeze();
      const c2 = h2(s2.getInternalMethods().reset(i2), a2);
      if (f(c2))
        return c2.then((i3) => {
          var a3;
          return l2 = (a3 = i3) && "function" == typeof a3.getInternalMethods ? i3 : s2, this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
        });
    } else
      (function(t3) {
        return "object" == typeof t3;
      })(h2) && (s2.getInternalMethods().getUsageInstance().freeze(), l2 = s2.getInternalMethods().reset(i2), Object.keys(e2.builder).forEach((t3) => {
        l2.option(t3, h2[t3]);
      }));
    return this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
  }
  parseAndUpdateUsage(t2, e2, s2, i2, n2, r2) {
    t2 && s2.getInternalMethods().getUsageInstance().unfreeze(true), this.shouldUpdateUsage(s2) && s2.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i2, e2), e2.description);
    const o2 = s2.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, n2, r2);
    return f(o2) ? o2.then((t3) => ({ aliases: s2.parsed.aliases, innerArgv: t3 })) : { aliases: s2.parsed.aliases, innerArgv: o2 };
  }
  shouldUpdateUsage(t2) {
    return !t2.getInternalMethods().getUsageInstance().getUsageDisabled() && 0 === t2.getInternalMethods().getUsageInstance().getUsage().length;
  }
  usageFromParentCommandsCommandHandler(t2, e2) {
    const s2 = M.test(e2.original) ? e2.original.replace(M, "").trim() : e2.original, i2 = t2.filter((t3) => !M.test(t3));
    return i2.push(s2), `$0 ${i2.join(" ")}`;
  }
  handleValidationAndGetResult(t2, e2, s2, i2, n2, r2, o2, a2) {
    if (!r2.getInternalMethods().getHasOutput()) {
      const e3 = r2.getInternalMethods().runValidation(n2, a2, r2.parsed.error, t2);
      s2 = j(s2, (t3) => (e3(t3), t3));
    }
    if (e2.handler && !r2.getInternalMethods().getHasOutput()) {
      r2.getInternalMethods().setHasOutput();
      const i3 = !!r2.getOptions().configuration["populate--"];
      r2.getInternalMethods().postProcess(s2, i3, false, false), s2 = j(s2 = C(s2, r2, o2, false), (t3) => {
        const s3 = e2.handler(t3);
        return f(s3) ? s3.then(() => t3) : t3;
      }), t2 || r2.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s2) && !r2.getInternalMethods().hasParseCallback() && s2.catch((t3) => {
        try {
          r2.getInternalMethods().getUsageInstance().fail(null, t3);
        } catch (t4) {
        }
      });
    }
    return t2 || (i2.commands.pop(), i2.fullCommands.pop()), s2;
  }
  applyMiddlewareAndGetResult(t2, e2, s2, i2, n2, r2, o2) {
    let a2 = {};
    if (n2)
      return s2;
    o2.getInternalMethods().getHasOutput() || (a2 = this.populatePositionals(e2, s2, i2, o2));
    const h2 = this.globalMiddleware.getMiddleware().slice(0).concat(e2.middlewares), l2 = C(s2, o2, h2, true);
    return f(l2) ? l2.then((s3) => this.handleValidationAndGetResult(t2, e2, s3, i2, r2, o2, h2, a2)) : this.handleValidationAndGetResult(t2, e2, l2, i2, r2, o2, h2, a2);
  }
  populatePositionals(t2, e2, s2, i2) {
    e2._ = e2._.slice(s2.commands.length);
    const n2 = t2.demanded.slice(0), r2 = t2.optional.slice(0), o2 = {};
    for (this.validation.positionalCount(n2.length, e2._.length); n2.length; ) {
      const t3 = n2.shift();
      this.populatePositional(t3, e2, o2);
    }
    for (; r2.length; ) {
      const t3 = r2.shift();
      this.populatePositional(t3, e2, o2);
    }
    return e2._ = s2.commands.concat(e2._.map((t3) => "" + t3)), this.postProcessPositionals(e2, o2, this.cmdToParseOptions(t2.original), i2), o2;
  }
  populatePositional(t2, e2, s2) {
    const i2 = t2.cmd[0];
    t2.variadic ? s2[i2] = e2._.splice(0).map(String) : e2._.length && (s2[i2] = [String(e2._.shift())]);
  }
  cmdToParseOptions(t2) {
    const e2 = { array: [], default: {}, alias: {}, demand: {} }, s2 = o(t2);
    return s2.demanded.forEach((t3) => {
      const [s3, ...i2] = t3.cmd;
      t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2, e2.demand[s3] = true;
    }), s2.optional.forEach((t3) => {
      const [s3, ...i2] = t3.cmd;
      t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2;
    }), e2;
  }
  postProcessPositionals(t2, e2, s2, i2) {
    const n2 = Object.assign({}, i2.getOptions());
    n2.default = Object.assign(s2.default, n2.default);
    for (const t3 of Object.keys(s2.alias))
      n2.alias[t3] = (n2.alias[t3] || []).concat(s2.alias[t3]);
    n2.array = n2.array.concat(s2.array), n2.config = {};
    const r2 = [];
    if (Object.keys(e2).forEach((t3) => {
      e2[t3].map((e3) => {
        n2.configuration["unknown-options-as-args"] && (n2.key[t3] = true), r2.push(`--${t3}`), r2.push(e3);
      });
    }), !r2.length)
      return;
    const o2 = Object.assign({}, n2.configuration, { "populate--": false }), a2 = this.shim.Parser.detailed(r2, Object.assign({}, n2, { configuration: o2 }));
    if (a2.error)
      i2.getInternalMethods().getUsageInstance().fail(a2.error.message, a2.error);
    else {
      const s3 = Object.keys(e2);
      Object.keys(e2).forEach((t3) => {
        s3.push(...a2.aliases[t3]);
      }), Object.keys(a2.argv).forEach((n3) => {
        s3.includes(n3) && (e2[n3] || (e2[n3] = a2.argv[n3]), !this.isInConfigs(i2, n3) && !this.isDefaulted(i2, n3) && Object.prototype.hasOwnProperty.call(t2, n3) && Object.prototype.hasOwnProperty.call(a2.argv, n3) && (Array.isArray(t2[n3]) || Array.isArray(a2.argv[n3])) ? t2[n3] = [].concat(t2[n3], a2.argv[n3]) : t2[n3] = a2.argv[n3]);
      });
    }
  }
  isDefaulted(t2, e2) {
    const { default: s2 } = t2.getOptions();
    return Object.prototype.hasOwnProperty.call(s2, e2) || Object.prototype.hasOwnProperty.call(s2, this.shim.Parser.camelCase(e2));
  }
  isInConfigs(t2, e2) {
    const { configObjects: s2 } = t2.getOptions();
    return s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, e2)) || s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, this.shim.Parser.camelCase(e2)));
  }
  runDefaultBuilderOn(t2) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(t2)) {
      const e3 = M.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      t2.getInternalMethods().getUsageInstance().usage(e3, this.defaultCommand.description);
    }
    const e2 = this.defaultCommand.builder;
    if (x(e2))
      return e2(t2, true);
    k(e2) || Object.keys(e2).forEach((s2) => {
      t2.option(s2, e2[s2]);
    });
  }
  moduleName(t2) {
    const e2 = function(t3) {
      if ("undefined" == typeof commonjsRequire)
        return null;
      for (let e3, s2 = 0, i2 = Object.keys(require.cache); s2 < i2.length; s2++)
        if (e3 = require.cache[i2[s2]], e3.exports === t3)
          return e3;
      return null;
    }(t2);
    if (!e2)
      throw new Error(`No command name given for module: ${this.shim.inspect(t2)}`);
    return this.commandFromFilename(e2.filename);
  }
  commandFromFilename(t2) {
    return this.shim.path.basename(t2, this.shim.path.extname(t2));
  }
  extractDesc({ describe: t2, description: e2, desc: s2 }) {
    for (const i2 of [t2, e2, s2]) {
      if ("string" == typeof i2 || false === i2)
        return i2;
      d(i2, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand });
  }
  unfreeze() {
    const t2 = this.frozens.pop();
    d(t2, void 0, this.shim), { handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = t2;
  }
  reset() {
    return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = /* @__PURE__ */ new Set(), this;
  }
}
function k(t2) {
  return "object" == typeof t2 && !!t2.builder && "function" == typeof t2.handler;
}
function x(t2) {
  return "function" == typeof t2;
}
function E(t2) {
  "undefined" != typeof dist.process && [dist.process.stdout, dist.process.stderr].forEach((e2) => {
    const s2 = e2;
    s2._handle && s2.isTTY && "function" == typeof s2._handle.setBlocking && s2._handle.setBlocking(t2);
  });
}
function A(t2) {
  return "boolean" == typeof t2;
}
function P(t2, s2) {
  const i2 = s2.y18n.__, n2 = {}, r2 = [];
  n2.failFn = function(t3) {
    r2.push(t3);
  };
  let o2 = null, a2 = null, h2 = true;
  n2.showHelpOnFail = function(e2 = true, s3) {
    const [i3, r3] = "string" == typeof e2 ? [true, e2] : [e2, s3];
    return t2.getInternalMethods().isGlobalContext() && (a2 = r3), o2 = r3, h2 = i3, n2;
  };
  let l2 = false;
  n2.fail = function(s3, i3) {
    const c3 = t2.getInternalMethods().getLoggerInstance();
    if (!r2.length) {
      if (t2.getExitProcess() && E(true), !l2) {
        l2 = true, h2 && (t2.showHelp("error"), c3.error()), (s3 || i3) && c3.error(s3 || i3);
        const e2 = o2 || a2;
        e2 && ((s3 || i3) && c3.error(""), c3.error(e2));
      }
      if (i3 = i3 || new e(s3), t2.getExitProcess())
        return t2.exit(1);
      if (t2.getInternalMethods().hasParseCallback())
        return t2.exit(1, i3);
      throw i3;
    }
    for (let t3 = r2.length - 1; t3 >= 0; --t3) {
      const e2 = r2[t3];
      if (A(e2)) {
        if (i3)
          throw i3;
        if (s3)
          throw Error(s3);
      } else
        e2(s3, i3, n2);
    }
  };
  let c2 = [], f2 = false;
  n2.usage = (t3, e2) => null === t3 ? (f2 = true, c2 = [], n2) : (f2 = false, c2.push([t3, e2 || ""]), n2), n2.getUsage = () => c2, n2.getUsageDisabled = () => f2, n2.getPositionalGroupName = () => i2("Positionals:");
  let d2 = [];
  n2.example = (t3, e2) => {
    d2.push([t3, e2 || ""]);
  };
  let u2 = [];
  n2.command = function(t3, e2, s3, i3, n3 = false) {
    s3 && (u2 = u2.map((t4) => (t4[2] = false, t4))), u2.push([t3, e2 || "", s3, i3, n3]);
  }, n2.getCommands = () => u2;
  let p2 = {};
  n2.describe = function(t3, e2) {
    Array.isArray(t3) ? t3.forEach((t4) => {
      n2.describe(t4, e2);
    }) : "object" == typeof t3 ? Object.keys(t3).forEach((e3) => {
      n2.describe(e3, t3[e3]);
    }) : p2[t3] = e2;
  }, n2.getDescriptions = () => p2;
  let m2 = [];
  n2.epilog = (t3) => {
    m2.push(t3);
  };
  let y2, b2 = false;
  n2.wrap = (t3) => {
    b2 = true, y2 = t3;
  }, n2.getWrap = () => s2.getEnv("YARGS_DISABLE_WRAP") ? null : (b2 || (y2 = function() {
    const t3 = 80;
    return s2.process.stdColumns ? Math.min(t3, s2.process.stdColumns) : t3;
  }(), b2 = true), y2);
  const v2 = "__yargsString__:";
  function O2(t3, e2, i3) {
    let n3 = 0;
    return Array.isArray(t3) || (t3 = Object.values(t3).map((t4) => [t4])), t3.forEach((t4) => {
      n3 = Math.max(s2.stringWidth(i3 ? `${i3} ${I(t4[0])}` : I(t4[0])) + $(t4[0]), n3);
    }), e2 && (n3 = Math.min(n3, parseInt((0.5 * e2).toString(), 10))), n3;
  }
  let w2;
  function C2(e2) {
    return t2.getOptions().hiddenOptions.indexOf(e2) < 0 || t2.parsed.argv[t2.getOptions().showHiddenOpt];
  }
  function j2(t3, e2) {
    let s3 = `[${i2("default:")} `;
    if (void 0 === t3 && !e2)
      return null;
    if (e2)
      s3 += e2;
    else
      switch (typeof t3) {
        case "string":
          s3 += `"${t3}"`;
          break;
        case "object":
          s3 += JSON.stringify(t3);
          break;
        default:
          s3 += t3;
      }
    return `${s3}]`;
  }
  n2.deferY18nLookup = (t3) => v2 + t3, n2.help = function() {
    if (w2)
      return w2;
    !function() {
      const e3 = t2.getDemandedOptions(), s3 = t2.getOptions();
      (Object.keys(s3.alias) || []).forEach((i3) => {
        s3.alias[i3].forEach((r4) => {
          p2[r4] && n2.describe(i3, p2[r4]), r4 in e3 && t2.demandOption(i3, e3[r4]), s3.boolean.includes(r4) && t2.boolean(i3), s3.count.includes(r4) && t2.count(i3), s3.string.includes(r4) && t2.string(i3), s3.normalize.includes(r4) && t2.normalize(i3), s3.array.includes(r4) && t2.array(i3), s3.number.includes(r4) && t2.number(i3);
        });
      });
    }();
    const e2 = t2.customScriptName ? t2.$0 : s2.path.basename(t2.$0), r3 = t2.getDemandedOptions(), o3 = t2.getDemandedCommands(), a3 = t2.getDeprecatedOptions(), h3 = t2.getGroups(), l3 = t2.getOptions();
    let g2 = [];
    g2 = g2.concat(Object.keys(p2)), g2 = g2.concat(Object.keys(r3)), g2 = g2.concat(Object.keys(o3)), g2 = g2.concat(Object.keys(l3.default)), g2 = g2.filter(C2), g2 = Object.keys(g2.reduce((t3, e3) => ("_" !== e3 && (t3[e3] = true), t3), {}));
    const y3 = n2.getWrap(), b3 = s2.cliui({ width: y3, wrap: !!y3 });
    if (!f2) {
      if (c2.length)
        c2.forEach((t3) => {
          b3.div({ text: `${t3[0].replace(/\$0/g, e2)}` }), t3[1] && b3.div({ text: `${t3[1]}`, padding: [1, 0, 0, 0] });
        }), b3.div();
      else if (u2.length) {
        let t3 = null;
        t3 = o3._ ? `${e2} <${i2("command")}>
` : `${e2} [${i2("command")}]
`, b3.div(`${t3}`);
      }
    }
    if (u2.length > 1 || 1 === u2.length && !u2[0][2]) {
      b3.div(i2("Commands:"));
      const s3 = t2.getInternalMethods().getContext(), n3 = s3.commands.length ? `${s3.commands.join(" ")} ` : "";
      true === t2.getInternalMethods().getParserConfiguration()["sort-commands"] && (u2 = u2.sort((t3, e3) => t3[0].localeCompare(e3[0])));
      const r4 = e2 ? `${e2} ` : "";
      u2.forEach((t3) => {
        const s4 = `${r4}${n3}${t3[0].replace(/^\$0 ?/, "")}`;
        b3.span({ text: s4, padding: [0, 2, 0, 2], width: O2(u2, y3, `${e2}${n3}`) + 4 }, { text: t3[1] });
        const o4 = [];
        t3[2] && o4.push(`[${i2("default")}]`), t3[3] && t3[3].length && o4.push(`[${i2("aliases:")} ${t3[3].join(", ")}]`), t3[4] && ("string" == typeof t3[4] ? o4.push(`[${i2("deprecated: %s", t3[4])}]`) : o4.push(`[${i2("deprecated")}]`)), o4.length ? b3.div({ text: o4.join(" "), padding: [0, 0, 0, 2], align: "right" }) : b3.div();
      }), b3.div();
    }
    const M3 = (Object.keys(l3.alias) || []).concat(Object.keys(t2.parsed.newAliases) || []);
    g2 = g2.filter((e3) => !t2.parsed.newAliases[e3] && M3.every((t3) => -1 === (l3.alias[t3] || []).indexOf(e3)));
    const _3 = i2("Options:");
    h3[_3] || (h3[_3] = []), function(t3, e3, s3, i3) {
      let n3 = [], r4 = null;
      Object.keys(s3).forEach((t4) => {
        n3 = n3.concat(s3[t4]);
      }), t3.forEach((t4) => {
        r4 = [t4].concat(e3[t4]), r4.some((t5) => -1 !== n3.indexOf(t5)) || s3[i3].push(t4);
      });
    }(g2, l3.alias, h3, _3);
    const k2 = (t3) => /^--/.test(I(t3)), x2 = Object.keys(h3).filter((t3) => h3[t3].length > 0).map((t3) => ({ groupName: t3, normalizedKeys: h3[t3].filter(C2).map((t4) => {
      if (M3.includes(t4))
        return t4;
      for (let e3, s3 = 0; void 0 !== (e3 = M3[s3]); s3++)
        if ((l3.alias[e3] || []).includes(t4))
          return e3;
      return t4;
    }) })).filter(({ normalizedKeys: t3 }) => t3.length > 0).map(({ groupName: t3, normalizedKeys: e3 }) => {
      const s3 = e3.reduce((e4, s4) => (e4[s4] = [s4].concat(l3.alias[s4] || []).map((e5) => t3 === n2.getPositionalGroupName() ? e5 : (/^[0-9]$/.test(e5) ? l3.boolean.includes(s4) ? "-" : "--" : e5.length > 1 ? "--" : "-") + e5).sort((t4, e5) => k2(t4) === k2(e5) ? 0 : k2(t4) ? 1 : -1).join(", "), e4), {});
      return { groupName: t3, normalizedKeys: e3, switches: s3 };
    });
    if (x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).some(({ normalizedKeys: t3, switches: e3 }) => !t3.every((t4) => k2(e3[t4]))) && x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).forEach(({ normalizedKeys: t3, switches: e3 }) => {
      t3.forEach((t4) => {
        var s3, i3;
        k2(e3[t4]) && (e3[t4] = (s3 = e3[t4], i3 = 4, S(s3) ? { text: s3.text, indentation: s3.indentation + i3 } : { text: s3, indentation: i3 }));
      });
    }), x2.forEach(({ groupName: e3, normalizedKeys: s3, switches: o4 }) => {
      b3.div(e3), s3.forEach((e4) => {
        const s4 = o4[e4];
        let h4 = p2[e4] || "", c3 = null;
        h4.includes(v2) && (h4 = i2(h4.substring(16))), l3.boolean.includes(e4) && (c3 = `[${i2("boolean")}]`), l3.count.includes(e4) && (c3 = `[${i2("count")}]`), l3.string.includes(e4) && (c3 = `[${i2("string")}]`), l3.normalize.includes(e4) && (c3 = `[${i2("string")}]`), l3.array.includes(e4) && (c3 = `[${i2("array")}]`), l3.number.includes(e4) && (c3 = `[${i2("number")}]`);
        const f3 = [e4 in a3 ? (d3 = a3[e4], "string" == typeof d3 ? `[${i2("deprecated: %s", d3)}]` : `[${i2("deprecated")}]`) : null, c3, e4 in r3 ? `[${i2("required")}]` : null, l3.choices && l3.choices[e4] ? `[${i2("choices:")} ${n2.stringifiedValues(l3.choices[e4])}]` : null, j2(l3.default[e4], l3.defaultDescription[e4])].filter(Boolean).join(" ");
        var d3;
        b3.span({ text: I(s4), padding: [0, 2, 0, 2 + $(s4)], width: O2(o4, y3) + 4 }, h4);
        const u3 = true === t2.getInternalMethods().getUsageConfiguration()["hide-types"];
        f3 && !u3 ? b3.div({ text: f3, padding: [0, 0, 0, 2], align: "right" }) : b3.div();
      }), b3.div();
    }), d2.length && (b3.div(i2("Examples:")), d2.forEach((t3) => {
      t3[0] = t3[0].replace(/\$0/g, e2);
    }), d2.forEach((t3) => {
      "" === t3[1] ? b3.div({ text: t3[0], padding: [0, 2, 0, 2] }) : b3.div({ text: t3[0], padding: [0, 2, 0, 2], width: O2(d2, y3) + 4 }, { text: t3[1] });
    }), b3.div()), m2.length > 0) {
      const t3 = m2.map((t4) => t4.replace(/\$0/g, e2)).join("\n");
      b3.div(`${t3}
`);
    }
    return b3.toString().replace(/\s*$/, "");
  }, n2.cacheHelpMessage = function() {
    w2 = this.help();
  }, n2.clearCachedHelpMessage = function() {
    w2 = void 0;
  }, n2.hasCachedHelpMessage = function() {
    return !!w2;
  }, n2.showHelp = (e2) => {
    const s3 = t2.getInternalMethods().getLoggerInstance();
    e2 || (e2 = "error");
    ("function" == typeof e2 ? e2 : s3[e2])(n2.help());
  }, n2.functionDescription = (t3) => ["(", t3.name ? s2.Parser.decamelize(t3.name, "-") : i2("generated-value"), ")"].join(""), n2.stringifiedValues = function(t3, e2) {
    let s3 = "";
    const i3 = e2 || ", ", n3 = [].concat(t3);
    return t3 && n3.length ? (n3.forEach((t4) => {
      s3.length && (s3 += i3), s3 += JSON.stringify(t4);
    }), s3) : s3;
  };
  let M2 = null;
  n2.version = (t3) => {
    M2 = t3;
  }, n2.showVersion = (e2) => {
    const s3 = t2.getInternalMethods().getLoggerInstance();
    e2 || (e2 = "error");
    ("function" == typeof e2 ? e2 : s3[e2])(M2);
  }, n2.reset = function(t3) {
    return o2 = null, l2 = false, c2 = [], f2 = false, m2 = [], d2 = [], u2 = [], p2 = g(p2, (e2) => !t3[e2]), n2;
  };
  const _2 = [];
  return n2.freeze = function() {
    _2.push({ failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 });
  }, n2.unfreeze = function(t3 = false) {
    const e2 = _2.pop();
    e2 && (t3 ? (p2 = { ...e2.descriptions, ...p2 }, u2 = [...e2.commands, ...u2], c2 = [...e2.usages, ...c2], d2 = [...e2.examples, ...d2], m2 = [...e2.epilogs, ...m2]) : { failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 } = e2);
  }, n2;
}
function S(t2) {
  return "object" == typeof t2;
}
function $(t2) {
  return S(t2) ? t2.indentation : 0;
}
function I(t2) {
  return S(t2) ? t2.text : t2;
}
class D {
  constructor(t2, e2, s2, i2) {
    var n2, r2, o2;
    this.yargs = t2, this.usage = e2, this.command = s2, this.shim = i2, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.indexAfterLastReset = 0, this.zshShell = null !== (o2 = (null === (n2 = this.shim.getEnv("SHELL")) || void 0 === n2 ? void 0 : n2.includes("zsh")) || (null === (r2 = this.shim.getEnv("ZSH_NAME")) || void 0 === r2 ? void 0 : r2.includes("zsh"))) && void 0 !== o2 && o2;
  }
  defaultCompletion(t2, e2, s2, i2) {
    const n2 = this.command.getCommandHandlers();
    for (let e3 = 0, s3 = t2.length; e3 < s3; ++e3)
      if (n2[t2[e3]] && n2[t2[e3]].builder) {
        const s4 = n2[t2[e3]].builder;
        if (x(s4)) {
          this.indexAfterLastReset = e3 + 1;
          const t3 = this.yargs.getInternalMethods().reset();
          return s4(t3, true), t3.argv;
        }
      }
    const r2 = [];
    this.commandCompletions(r2, t2, s2), this.optionCompletions(r2, t2, e2, s2), this.choicesFromOptionsCompletions(r2, t2, e2, s2), this.choicesFromPositionalsCompletions(r2, t2, e2, s2), i2(null, r2);
  }
  commandCompletions(t2, e2, s2) {
    const i2 = this.yargs.getInternalMethods().getContext().commands;
    s2.match(/^-/) || i2[i2.length - 1] === s2 || this.previousArgHasChoices(e2) || this.usage.getCommands().forEach((s3) => {
      const i3 = o(s3[0]).cmd;
      if (-1 === e2.indexOf(i3))
        if (this.zshShell) {
          const e3 = s3[1] || "";
          t2.push(i3.replace(/:/g, "\\:") + ":" + e3);
        } else
          t2.push(i3);
    });
  }
  optionCompletions(t2, e2, s2, i2) {
    if ((i2.match(/^-/) || "" === i2 && 0 === t2.length) && !this.previousArgHasChoices(e2)) {
      const s3 = this.yargs.getOptions(), n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(s3.key).forEach((r2) => {
        const o2 = !!s3.configuration["boolean-negation"] && s3.boolean.includes(r2);
        n2.includes(r2) || s3.hiddenOptions.includes(r2) || this.argsContainKey(e2, r2, o2) || this.completeOptionKey(r2, t2, i2, o2 && !!s3.default[r2]);
      });
    }
  }
  choicesFromOptionsCompletions(t2, e2, s2, i2) {
    if (this.previousArgHasChoices(e2)) {
      const s3 = this.getPreviousArgChoices(e2);
      s3 && s3.length > 0 && t2.push(...s3.map((t3) => t3.replace(/:/g, "\\:")));
    }
  }
  choicesFromPositionalsCompletions(t2, e2, s2, i2) {
    if ("" === i2 && t2.length > 0 && this.previousArgHasChoices(e2))
      return;
    const n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [], r2 = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1), o2 = n2[s2._.length - r2 - 1];
    if (!o2)
      return;
    const a2 = this.yargs.getOptions().choices[o2] || [];
    for (const e3 of a2)
      e3.startsWith(i2) && t2.push(e3.replace(/:/g, "\\:"));
  }
  getPreviousArgChoices(t2) {
    if (t2.length < 1)
      return;
    let e2 = t2[t2.length - 1], s2 = "";
    if (!e2.startsWith("-") && t2.length > 1 && (s2 = e2, e2 = t2[t2.length - 2]), !e2.startsWith("-"))
      return;
    const i2 = e2.replace(/^-+/, ""), n2 = this.yargs.getOptions(), r2 = [i2, ...this.yargs.getAliases()[i2] || []];
    let o2;
    for (const t3 of r2)
      if (Object.prototype.hasOwnProperty.call(n2.key, t3) && Array.isArray(n2.choices[t3])) {
        o2 = n2.choices[t3];
        break;
      }
    return o2 ? o2.filter((t3) => !s2 || t3.startsWith(s2)) : void 0;
  }
  previousArgHasChoices(t2) {
    const e2 = this.getPreviousArgChoices(t2);
    return void 0 !== e2 && e2.length > 0;
  }
  argsContainKey(t2, e2, s2) {
    const i2 = (e3) => -1 !== t2.indexOf((/^[^0-9]$/.test(e3) ? "-" : "--") + e3);
    if (i2(e2))
      return true;
    if (s2 && i2(`no-${e2}`))
      return true;
    if (this.aliases) {
      for (const t3 of this.aliases[e2])
        if (i2(t3))
          return true;
    }
    return false;
  }
  completeOptionKey(t2, e2, s2, i2) {
    var n2, r2, o2, a2;
    let h2 = t2;
    if (this.zshShell) {
      const e3 = this.usage.getDescriptions(), s3 = null === (r2 = null === (n2 = null == this ? void 0 : this.aliases) || void 0 === n2 ? void 0 : n2[t2]) || void 0 === r2 ? void 0 : r2.find((t3) => {
        const s4 = e3[t3];
        return "string" == typeof s4 && s4.length > 0;
      }), i3 = s3 ? e3[s3] : void 0, l3 = null !== (a2 = null !== (o2 = e3[t2]) && void 0 !== o2 ? o2 : i3) && void 0 !== a2 ? a2 : "";
      h2 = `${t2.replace(/:/g, "\\:")}:${l3.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const l2 = !/^--/.test(s2) && ((t3) => /^[^0-9]$/.test(t3))(t2) ? "-" : "--";
    e2.push(l2 + h2), i2 && e2.push(l2 + "no-" + h2);
  }
  customCompletion(t2, e2, s2, i2) {
    if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {
      const t3 = this.customCompletionFunction(s2, e2);
      return f(t3) ? t3.then((t4) => {
        this.shim.process.nextTick(() => {
          i2(null, t4);
        });
      }).catch((t4) => {
        this.shim.process.nextTick(() => {
          i2(t4, void 0);
        });
      }) : i2(null, t3);
    }
    return function(t3) {
      return t3.length > 3;
    }(this.customCompletionFunction) ? this.customCompletionFunction(s2, e2, (n2 = i2) => this.defaultCompletion(t2, e2, s2, n2), (t3) => {
      i2(null, t3);
    }) : this.customCompletionFunction(s2, e2, (t3) => {
      i2(null, t3);
    });
  }
  getCompletion(t2, e2) {
    const s2 = t2.length ? t2[t2.length - 1] : "", i2 = this.yargs.parse(t2, true), n2 = this.customCompletionFunction ? (i3) => this.customCompletion(t2, i3, s2, e2) : (i3) => this.defaultCompletion(t2, i3, s2, e2);
    return f(i2) ? i2.then(n2) : n2(i2);
  }
  generateCompletionScript(t2, e2) {
    let s2 = this.zshShell ? `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
` : '###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="${COMP_WORDS[COMP_CWORD]}"\n    args=("${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "${args[@]}")\n\n    COMPREPLY=( $(compgen -W "${type_list}" -- ${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n';
    const i2 = this.shim.path.basename(t2);
    return t2.match(/\.js$/) && (t2 = `./${t2}`), s2 = s2.replace(/{{app_name}}/g, i2), s2 = s2.replace(/{{completion_command}}/g, e2), s2.replace(/{{app_path}}/g, t2);
  }
  registerFunction(t2) {
    this.customCompletionFunction = t2;
  }
  setParsed(t2) {
    this.aliases = t2.aliases;
  }
}
function N(t2, e2) {
  if (0 === t2.length)
    return e2.length;
  if (0 === e2.length)
    return t2.length;
  const s2 = [];
  let i2, n2;
  for (i2 = 0; i2 <= e2.length; i2++)
    s2[i2] = [i2];
  for (n2 = 0; n2 <= t2.length; n2++)
    s2[0][n2] = n2;
  for (i2 = 1; i2 <= e2.length; i2++)
    for (n2 = 1; n2 <= t2.length; n2++)
      e2.charAt(i2 - 1) === t2.charAt(n2 - 1) ? s2[i2][n2] = s2[i2 - 1][n2 - 1] : i2 > 1 && n2 > 1 && e2.charAt(i2 - 2) === t2.charAt(n2 - 1) && e2.charAt(i2 - 1) === t2.charAt(n2 - 2) ? s2[i2][n2] = s2[i2 - 2][n2 - 2] + 1 : s2[i2][n2] = Math.min(s2[i2 - 1][n2 - 1] + 1, Math.min(s2[i2][n2 - 1] + 1, s2[i2 - 1][n2] + 1));
  return s2[e2.length][t2.length];
}
const H = ["$0", "--", "_"];
var z, W, q, U, F, L, V, G, R, T, B, Y, K, J, Z, X, Q, tt, et, st, it, nt, rt, ot, at, ht, lt, ct, ft, dt, ut, pt, gt, mt, yt;
const bt = Symbol("copyDoubleDash"), vt = Symbol("copyDoubleDash"), Ot = Symbol("deleteFromParserHintObject"), wt = Symbol("emitWarning"), Ct = Symbol("freeze"), jt = Symbol("getDollarZero"), Mt = Symbol("getParserConfiguration"), _t = Symbol("getUsageConfiguration"), kt = Symbol("guessLocale"), xt = Symbol("guessVersion"), Et = Symbol("parsePositionalNumbers"), At = Symbol("pkgUp"), Pt = Symbol("populateParserHintArray"), St = Symbol("populateParserHintSingleValueDictionary"), $t = Symbol("populateParserHintArrayDictionary"), It = Symbol("populateParserHintDictionary"), Dt = Symbol("sanitizeKey"), Nt = Symbol("setKey"), Ht = Symbol("unfreeze"), zt = Symbol("validateAsync"), Wt = Symbol("getCommandInstance"), qt = Symbol("getContext"), Ut = Symbol("getHasOutput"), Ft = Symbol("getLoggerInstance"), Lt = Symbol("getParseContext"), Vt = Symbol("getUsageInstance"), Gt = Symbol("getValidationInstance"), Rt = Symbol("hasParseCallback"), Tt = Symbol("isGlobalContext"), Bt = Symbol("postProcess"), Yt = Symbol("rebase"), Kt = Symbol("reset"), Jt = Symbol("runYargsParserAndExecuteCommands"), Zt = Symbol("runValidation"), Xt = Symbol("setHasOutput"), Qt = Symbol("kTrackManuallySetKeys");
class te {
  constructor(t2 = [], e2, s2, i2) {
    this.customScriptName = false, this.parsed = false, z.set(this, void 0), W.set(this, void 0), q.set(this, { commands: [], fullCommands: [] }), U.set(this, null), F.set(this, null), L.set(this, "show-hidden"), V.set(this, null), G.set(this, true), R.set(this, {}), T.set(this, true), B.set(this, []), Y.set(this, void 0), K.set(this, {}), J.set(this, false), Z.set(this, null), X.set(this, true), Q.set(this, void 0), tt.set(this, ""), et.set(this, void 0), st.set(this, void 0), it.set(this, {}), nt.set(this, null), rt.set(this, null), ot.set(this, {}), at.set(this, {}), ht.set(this, void 0), lt.set(this, false), ct.set(this, void 0), ft.set(this, false), dt.set(this, false), ut.set(this, false), pt.set(this, void 0), gt.set(this, {}), mt.set(this, null), yt.set(this, void 0), O(this, ct, i2, "f"), O(this, ht, t2, "f"), O(this, W, e2, "f"), O(this, st, s2, "f"), O(this, Y, new w(this), "f"), this.$0 = this[jt](), this[Kt](), O(this, z, v(this, z, "f"), "f"), O(this, pt, v(this, pt, "f"), "f"), O(this, yt, v(this, yt, "f"), "f"), O(this, et, v(this, et, "f"), "f"), v(this, et, "f").showHiddenOpt = v(this, L, "f"), O(this, Q, this[vt](), "f");
  }
  addHelpOpt(t2, e2) {
    return h("[string|boolean] [string]", [t2, e2], arguments.length), v(this, Z, "f") && (this[Ot](v(this, Z, "f")), O(this, Z, null, "f")), false === t2 && void 0 === e2 || (O(this, Z, "string" == typeof t2 ? t2 : "help", "f"), this.boolean(v(this, Z, "f")), this.describe(v(this, Z, "f"), e2 || v(this, pt, "f").deferY18nLookup("Show help"))), this;
  }
  help(t2, e2) {
    return this.addHelpOpt(t2, e2);
  }
  addShowHiddenOpt(t2, e2) {
    if (h("[string|boolean] [string]", [t2, e2], arguments.length), false === t2 && void 0 === e2)
      return this;
    const s2 = "string" == typeof t2 ? t2 : v(this, L, "f");
    return this.boolean(s2), this.describe(s2, e2 || v(this, pt, "f").deferY18nLookup("Show hidden options")), v(this, et, "f").showHiddenOpt = s2, this;
  }
  showHidden(t2, e2) {
    return this.addShowHiddenOpt(t2, e2);
  }
  alias(t2, e2) {
    return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.alias.bind(this), "alias", t2, e2), this;
  }
  array(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("array", t2), this[Qt](t2), this;
  }
  boolean(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("boolean", t2), this[Qt](t2), this;
  }
  check(t2, e2) {
    return h("<function> [boolean]", [t2, e2], arguments.length), this.middleware((e3, s2) => j(() => t2(e3, s2.getOptions()), (s3) => (s3 ? ("string" == typeof s3 || s3 instanceof Error) && v(this, pt, "f").fail(s3.toString(), s3) : v(this, pt, "f").fail(v(this, ct, "f").y18n.__("Argument check failed: %s", t2.toString())), e3), (t3) => (v(this, pt, "f").fail(t3.message ? t3.message : t3.toString(), t3), e3)), false, e2), this;
  }
  choices(t2, e2) {
    return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.choices.bind(this), "choices", t2, e2), this;
  }
  coerce(t2, s2) {
    if (h("<object|string|array> [function]", [t2, s2], arguments.length), Array.isArray(t2)) {
      if (!s2)
        throw new e("coerce callback must be provided");
      for (const e2 of t2)
        this.coerce(e2, s2);
      return this;
    }
    if ("object" == typeof t2) {
      for (const e2 of Object.keys(t2))
        this.coerce(e2, t2[e2]);
      return this;
    }
    if (!s2)
      throw new e("coerce callback must be provided");
    return v(this, et, "f").key[t2] = true, v(this, Y, "f").addCoerceMiddleware((i2, n2) => {
      let r2;
      return Object.prototype.hasOwnProperty.call(i2, t2) ? j(() => (r2 = n2.getAliases(), s2(i2[t2])), (e2) => {
        i2[t2] = e2;
        const s3 = n2.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (r2[t2] && true !== s3)
          for (const s4 of r2[t2])
            i2[s4] = e2;
        return i2;
      }, (t3) => {
        throw new e(t3.message);
      }) : i2;
    }, t2), this;
  }
  conflicts(t2, e2) {
    return h("<string|object> [string|array]", [t2, e2], arguments.length), v(this, yt, "f").conflicts(t2, e2), this;
  }
  config(t2 = "config", e2, s2) {
    return h("[object|string] [string|function] [function]", [t2, e2, s2], arguments.length), "object" != typeof t2 || Array.isArray(t2) ? ("function" == typeof e2 && (s2 = e2, e2 = void 0), this.describe(t2, e2 || v(this, pt, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t2) ? t2 : [t2]).forEach((t3) => {
      v(this, et, "f").config[t3] = s2 || true;
    }), this) : (t2 = n(t2, v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(t2), this);
  }
  completion(t2, e2, s2) {
    return h("[string] [string|boolean|function] [function]", [t2, e2, s2], arguments.length), "function" == typeof e2 && (s2 = e2, e2 = void 0), O(this, F, t2 || v(this, F, "f") || "completion", "f"), e2 || false === e2 || (e2 = "generate completion script"), this.command(v(this, F, "f"), e2), s2 && v(this, U, "f").registerFunction(s2), this;
  }
  command(t2, e2, s2, i2, n2, r2) {
    return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t2, e2, s2, i2, n2, r2], arguments.length), v(this, z, "f").addHandler(t2, e2, s2, i2, n2, r2), this;
  }
  commands(t2, e2, s2, i2, n2, r2) {
    return this.command(t2, e2, s2, i2, n2, r2);
  }
  commandDir(t2, e2) {
    h("<string> [object]", [t2, e2], arguments.length);
    const s2 = v(this, st, "f") || v(this, ct, "f").require;
    return v(this, z, "f").addDirectory(t2, s2, v(this, ct, "f").getCallerFile(), e2), this;
  }
  count(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("count", t2), this[Qt](t2), this;
  }
  default(t2, e2, s2) {
    return h("<object|string|array> [*] [string]", [t2, e2, s2], arguments.length), s2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] = s2), "function" == typeof e2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] || (v(this, et, "f").defaultDescription[t2] = v(this, pt, "f").functionDescription(e2)), e2 = e2.call()), this[St](this.default.bind(this), "default", t2, e2), this;
  }
  defaults(t2, e2, s2) {
    return this.default(t2, e2, s2);
  }
  demandCommand(t2 = 1, e2, s2, i2) {
    return h("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t2, e2, s2, i2], arguments.length), "number" != typeof e2 && (s2 = e2, e2 = 1 / 0), this.global("_", false), v(this, et, "f").demandedCommands._ = { min: t2, max: e2, minMsg: s2, maxMsg: i2 }, this;
  }
  demand(t2, e2, s2) {
    return Array.isArray(e2) ? (e2.forEach((t3) => {
      d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
    }), e2 = 1 / 0) : "number" != typeof e2 && (s2 = e2, e2 = 1 / 0), "number" == typeof t2 ? (d(s2, true, v(this, ct, "f")), this.demandCommand(t2, e2, s2, s2)) : Array.isArray(t2) ? t2.forEach((t3) => {
      d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
    }) : "string" == typeof s2 ? this.demandOption(t2, s2) : true !== s2 && void 0 !== s2 || this.demandOption(t2), this;
  }
  demandOption(t2, e2) {
    return h("<object|string|array> [string]", [t2, e2], arguments.length), this[St](this.demandOption.bind(this), "demandedOptions", t2, e2), this;
  }
  deprecateOption(t2, e2) {
    return h("<string> [string|boolean]", [t2, e2], arguments.length), v(this, et, "f").deprecatedOptions[t2] = e2, this;
  }
  describe(t2, e2) {
    return h("<object|string|array> [string]", [t2, e2], arguments.length), this[Nt](t2, true), v(this, pt, "f").describe(t2, e2), this;
  }
  detectLocale(t2) {
    return h("<boolean>", [t2], arguments.length), O(this, G, t2, "f"), this;
  }
  env(t2) {
    return h("[string|boolean]", [t2], arguments.length), false === t2 ? delete v(this, et, "f").envPrefix : v(this, et, "f").envPrefix = t2 || "", this;
  }
  epilogue(t2) {
    return h("<string>", [t2], arguments.length), v(this, pt, "f").epilog(t2), this;
  }
  epilog(t2) {
    return this.epilogue(t2);
  }
  example(t2, e2) {
    return h("<string|array> [string]", [t2, e2], arguments.length), Array.isArray(t2) ? t2.forEach((t3) => this.example(...t3)) : v(this, pt, "f").example(t2, e2), this;
  }
  exit(t2, e2) {
    O(this, J, true, "f"), O(this, V, e2, "f"), v(this, T, "f") && v(this, ct, "f").process.exit(t2);
  }
  exitProcess(t2 = true) {
    return h("[boolean]", [t2], arguments.length), O(this, T, t2, "f"), this;
  }
  fail(t2) {
    if (h("<function|boolean>", [t2], arguments.length), "boolean" == typeof t2 && false !== t2)
      throw new e("Invalid first argument. Expected function or boolean 'false'");
    return v(this, pt, "f").failFn(t2), this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(t2, e2) {
    return h("<array> [function]", [t2, e2], arguments.length), e2 ? v(this, U, "f").getCompletion(t2, e2) : new Promise((e3, s2) => {
      v(this, U, "f").getCompletion(t2, (t3, i2) => {
        t3 ? s2(t3) : e3(i2);
      });
    });
  }
  getDemandedOptions() {
    return h([], 0), v(this, et, "f").demandedOptions;
  }
  getDemandedCommands() {
    return h([], 0), v(this, et, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    return h([], 0), v(this, et, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return v(this, G, "f");
  }
  getExitProcess() {
    return v(this, T, "f");
  }
  getGroups() {
    return Object.assign({}, v(this, K, "f"), v(this, at, "f"));
  }
  getHelp() {
    if (O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const t3 = this[Jt](v(this, ht, "f"), void 0, void 0, 0, true);
        if (f(t3))
          return t3.then(() => v(this, pt, "f").help());
      }
      const t2 = v(this, z, "f").runDefaultBuilderOn(this);
      if (f(t2))
        return t2.then(() => v(this, pt, "f").help());
    }
    return Promise.resolve(v(this, pt, "f").help());
  }
  getOptions() {
    return v(this, et, "f");
  }
  getStrict() {
    return v(this, ft, "f");
  }
  getStrictCommands() {
    return v(this, dt, "f");
  }
  getStrictOptions() {
    return v(this, ut, "f");
  }
  global(t2, e2) {
    return h("<string|array> [boolean]", [t2, e2], arguments.length), t2 = [].concat(t2), false !== e2 ? v(this, et, "f").local = v(this, et, "f").local.filter((e3) => -1 === t2.indexOf(e3)) : t2.forEach((t3) => {
      v(this, et, "f").local.includes(t3) || v(this, et, "f").local.push(t3);
    }), this;
  }
  group(t2, e2) {
    h("<string|array> <string>", [t2, e2], arguments.length);
    const s2 = v(this, at, "f")[e2] || v(this, K, "f")[e2];
    v(this, at, "f")[e2] && delete v(this, at, "f")[e2];
    const i2 = {};
    return v(this, K, "f")[e2] = (s2 || []).concat(t2).filter((t3) => !i2[t3] && (i2[t3] = true)), this;
  }
  hide(t2) {
    return h("<string>", [t2], arguments.length), v(this, et, "f").hiddenOptions.push(t2), this;
  }
  implies(t2, e2) {
    return h("<string|object> [number|string|array]", [t2, e2], arguments.length), v(this, yt, "f").implies(t2, e2), this;
  }
  locale(t2) {
    return h("[string]", [t2], arguments.length), void 0 === t2 ? (this[kt](), v(this, ct, "f").y18n.getLocale()) : (O(this, G, false, "f"), v(this, ct, "f").y18n.setLocale(t2), this);
  }
  middleware(t2, e2, s2) {
    return v(this, Y, "f").addMiddleware(t2, !!e2, s2);
  }
  nargs(t2, e2) {
    return h("<string|object|array> [number]", [t2, e2], arguments.length), this[St](this.nargs.bind(this), "narg", t2, e2), this;
  }
  normalize(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("normalize", t2), this;
  }
  number(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("number", t2), this[Qt](t2), this;
  }
  option(t2, e2) {
    if (h("<string|object> [object]", [t2, e2], arguments.length), "object" == typeof t2)
      Object.keys(t2).forEach((e3) => {
        this.options(e3, t2[e3]);
      });
    else {
      "object" != typeof e2 && (e2 = {}), this[Qt](t2), !v(this, mt, "f") || "version" !== t2 && "version" !== (null == e2 ? void 0 : e2.alias) || this[wt](['"version" is a reserved word.', "Please do one of the following:", '- Disable version with `yargs.version(false)` if using "version" as an option', "- Use the built-in `yargs.version` method instead (if applicable)", "- Use a different option key", "https://yargs.js.org/docs/#api-reference-version"].join("\n"), void 0, "versionWarning"), v(this, et, "f").key[t2] = true, e2.alias && this.alias(t2, e2.alias);
      const s2 = e2.deprecate || e2.deprecated;
      s2 && this.deprecateOption(t2, s2);
      const i2 = e2.demand || e2.required || e2.require;
      i2 && this.demand(t2, i2), e2.demandOption && this.demandOption(t2, "string" == typeof e2.demandOption ? e2.demandOption : void 0), e2.conflicts && this.conflicts(t2, e2.conflicts), "default" in e2 && this.default(t2, e2.default), void 0 !== e2.implies && this.implies(t2, e2.implies), void 0 !== e2.nargs && this.nargs(t2, e2.nargs), e2.config && this.config(t2, e2.configParser), e2.normalize && this.normalize(t2), e2.choices && this.choices(t2, e2.choices), e2.coerce && this.coerce(t2, e2.coerce), e2.group && this.group(t2, e2.group), (e2.boolean || "boolean" === e2.type) && (this.boolean(t2), e2.alias && this.boolean(e2.alias)), (e2.array || "array" === e2.type) && (this.array(t2), e2.alias && this.array(e2.alias)), (e2.number || "number" === e2.type) && (this.number(t2), e2.alias && this.number(e2.alias)), (e2.string || "string" === e2.type) && (this.string(t2), e2.alias && this.string(e2.alias)), (e2.count || "count" === e2.type) && this.count(t2), "boolean" == typeof e2.global && this.global(t2, e2.global), e2.defaultDescription && (v(this, et, "f").defaultDescription[t2] = e2.defaultDescription), e2.skipValidation && this.skipValidation(t2);
      const n2 = e2.describe || e2.description || e2.desc, r2 = v(this, pt, "f").getDescriptions();
      Object.prototype.hasOwnProperty.call(r2, t2) && "string" != typeof n2 || this.describe(t2, n2), e2.hidden && this.hide(t2), e2.requiresArg && this.requiresArg(t2);
    }
    return this;
  }
  options(t2, e2) {
    return this.option(t2, e2);
  }
  parse(t2, e2, s2) {
    h("[string|array] [function|boolean|object] [function]", [t2, e2, s2], arguments.length), this[Ct](), void 0 === t2 && (t2 = v(this, ht, "f")), "object" == typeof e2 && (O(this, rt, e2, "f"), e2 = s2), "function" == typeof e2 && (O(this, nt, e2, "f"), e2 = false), e2 || O(this, ht, t2, "f"), v(this, nt, "f") && O(this, T, false, "f");
    const i2 = this[Jt](t2, !!e2), n2 = this.parsed;
    return v(this, U, "f").setParsed(this.parsed), f(i2) ? i2.then((t3) => (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), t3, v(this, tt, "f")), t3)).catch((t3) => {
      throw v(this, nt, "f") && v(this, nt, "f")(t3, this.parsed.argv, v(this, tt, "f")), t3;
    }).finally(() => {
      this[Ht](), this.parsed = n2;
    }) : (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), i2, v(this, tt, "f")), this[Ht](), this.parsed = n2, i2);
  }
  parseAsync(t2, e2, s2) {
    const i2 = this.parse(t2, e2, s2);
    return f(i2) ? i2 : Promise.resolve(i2);
  }
  parseSync(t2, s2, i2) {
    const n2 = this.parse(t2, s2, i2);
    if (f(n2))
      throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    return n2;
  }
  parserConfiguration(t2) {
    return h("<object>", [t2], arguments.length), O(this, it, t2, "f"), this;
  }
  pkgConf(t2, e2) {
    h("<string> [string]", [t2, e2], arguments.length);
    let s2 = null;
    const i2 = this[At](e2 || v(this, W, "f"));
    return i2[t2] && "object" == typeof i2[t2] && (s2 = n(i2[t2], e2 || v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(s2)), this;
  }
  positional(t2, e2) {
    h("<string> <object>", [t2, e2], arguments.length);
    const s2 = ["default", "defaultDescription", "implies", "normalize", "choices", "conflicts", "coerce", "type", "describe", "desc", "description", "alias"];
    e2 = g(e2, (t3, e3) => !("type" === t3 && !["string", "number", "boolean"].includes(e3)) && s2.includes(t3));
    const i2 = v(this, q, "f").fullCommands[v(this, q, "f").fullCommands.length - 1], n2 = i2 ? v(this, z, "f").cmdToParseOptions(i2) : { array: [], alias: {}, default: {}, demand: {} };
    return p(n2).forEach((s3) => {
      const i3 = n2[s3];
      Array.isArray(i3) ? -1 !== i3.indexOf(t2) && (e2[s3] = true) : i3[t2] && !(s3 in e2) && (e2[s3] = i3[t2]);
    }), this.group(t2, v(this, pt, "f").getPositionalGroupName()), this.option(t2, e2);
  }
  recommendCommands(t2 = true) {
    return h("[boolean]", [t2], arguments.length), O(this, lt, t2, "f"), this;
  }
  required(t2, e2, s2) {
    return this.demand(t2, e2, s2);
  }
  require(t2, e2, s2) {
    return this.demand(t2, e2, s2);
  }
  requiresArg(t2) {
    return h("<array|string|object> [number]", [t2], arguments.length), "string" == typeof t2 && v(this, et, "f").narg[t2] || this[St](this.requiresArg.bind(this), "narg", t2, NaN), this;
  }
  showCompletionScript(t2, e2) {
    return h("[string] [string]", [t2, e2], arguments.length), t2 = t2 || this.$0, v(this, Q, "f").log(v(this, U, "f").generateCompletionScript(t2, e2 || v(this, F, "f") || "completion")), this;
  }
  showHelp(t2) {
    if (h("[string|function]", [t2], arguments.length), O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const e3 = this[Jt](v(this, ht, "f"), void 0, void 0, 0, true);
        if (f(e3))
          return e3.then(() => {
            v(this, pt, "f").showHelp(t2);
          }), this;
      }
      const e2 = v(this, z, "f").runDefaultBuilderOn(this);
      if (f(e2))
        return e2.then(() => {
          v(this, pt, "f").showHelp(t2);
        }), this;
    }
    return v(this, pt, "f").showHelp(t2), this;
  }
  scriptName(t2) {
    return this.customScriptName = true, this.$0 = t2, this;
  }
  showHelpOnFail(t2, e2) {
    return h("[boolean|string] [string]", [t2, e2], arguments.length), v(this, pt, "f").showHelpOnFail(t2, e2), this;
  }
  showVersion(t2) {
    return h("[string|function]", [t2], arguments.length), v(this, pt, "f").showVersion(t2), this;
  }
  skipValidation(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("skipValidation", t2), this;
  }
  strict(t2) {
    return h("[boolean]", [t2], arguments.length), O(this, ft, false !== t2, "f"), this;
  }
  strictCommands(t2) {
    return h("[boolean]", [t2], arguments.length), O(this, dt, false !== t2, "f"), this;
  }
  strictOptions(t2) {
    return h("[boolean]", [t2], arguments.length), O(this, ut, false !== t2, "f"), this;
  }
  string(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("string", t2), this[Qt](t2), this;
  }
  terminalWidth() {
    return h([], 0), v(this, ct, "f").process.stdColumns;
  }
  updateLocale(t2) {
    return this.updateStrings(t2);
  }
  updateStrings(t2) {
    return h("<object>", [t2], arguments.length), O(this, G, false, "f"), v(this, ct, "f").y18n.updateLocale(t2), this;
  }
  usage(t2, s2, i2, n2) {
    if (h("<string|null|undefined> [string|boolean] [function|object] [function]", [t2, s2, i2, n2], arguments.length), void 0 !== s2) {
      if (d(t2, null, v(this, ct, "f")), (t2 || "").match(/^\$0( |$)/))
        return this.command(t2, s2, i2, n2);
      throw new e(".usage() description must start with $0 if being used as alias for .command()");
    }
    return v(this, pt, "f").usage(t2), this;
  }
  usageConfiguration(t2) {
    return h("<object>", [t2], arguments.length), O(this, gt, t2, "f"), this;
  }
  version(t2, e2, s2) {
    const i2 = "version";
    if (h("[boolean|string] [string] [string]", [t2, e2, s2], arguments.length), v(this, mt, "f") && (this[Ot](v(this, mt, "f")), v(this, pt, "f").version(void 0), O(this, mt, null, "f")), 0 === arguments.length)
      s2 = this[xt](), t2 = i2;
    else if (1 === arguments.length) {
      if (false === t2)
        return this;
      s2 = t2, t2 = i2;
    } else
      2 === arguments.length && (s2 = e2, e2 = void 0);
    return O(this, mt, "string" == typeof t2 ? t2 : i2, "f"), e2 = e2 || v(this, pt, "f").deferY18nLookup("Show version number"), v(this, pt, "f").version(s2 || void 0), this.boolean(v(this, mt, "f")), this.describe(v(this, mt, "f"), e2), this;
  }
  wrap(t2) {
    return h("<number|null|undefined>", [t2], arguments.length), v(this, pt, "f").wrap(t2), this;
  }
  [(z = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), Z = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), tt = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), ht = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), ft = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), mt = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt)](t2) {
    if (!t2._ || !t2["--"])
      return t2;
    t2._.push.apply(t2._, t2["--"]);
    try {
      delete t2["--"];
    } catch (t3) {
    }
    return t2;
  }
  [vt]() {
    return { log: (...t2) => {
      this[Rt]() || console.log(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + "\n", "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
    }, error: (...t2) => {
      this[Rt]() || console.error(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + "\n", "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
    } };
  }
  [Ot](t2) {
    p(v(this, et, "f")).forEach((e2) => {
      if ("configObjects" === e2)
        return;
      const s2 = v(this, et, "f")[e2];
      Array.isArray(s2) ? s2.includes(t2) && s2.splice(s2.indexOf(t2), 1) : "object" == typeof s2 && delete s2[t2];
    }), delete v(this, pt, "f").getDescriptions()[t2];
  }
  [wt](t2, e2, s2) {
    v(this, R, "f")[s2] || (v(this, ct, "f").process.emitWarning(t2, e2), v(this, R, "f")[s2] = true);
  }
  [Ct]() {
    v(this, B, "f").push({ options: v(this, et, "f"), configObjects: v(this, et, "f").configObjects.slice(0), exitProcess: v(this, T, "f"), groups: v(this, K, "f"), strict: v(this, ft, "f"), strictCommands: v(this, dt, "f"), strictOptions: v(this, ut, "f"), completionCommand: v(this, F, "f"), output: v(this, tt, "f"), exitError: v(this, V, "f"), hasOutput: v(this, J, "f"), parsed: this.parsed, parseFn: v(this, nt, "f"), parseContext: v(this, rt, "f") }), v(this, pt, "f").freeze(), v(this, yt, "f").freeze(), v(this, z, "f").freeze(), v(this, Y, "f").freeze();
  }
  [jt]() {
    let t2, e2 = "";
    return t2 = /\b(node|iojs|electron)(\.exe)?$/.test(v(this, ct, "f").process.argv()[0]) ? v(this, ct, "f").process.argv().slice(1, 2) : v(this, ct, "f").process.argv().slice(0, 1), e2 = t2.map((t3) => {
      const e3 = this[Yt](v(this, W, "f"), t3);
      return t3.match(/^(\/|([a-zA-Z]:)?\\)/) && e3.length < t3.length ? e3 : t3;
    }).join(" ").trim(), v(this, ct, "f").getEnv("_") && v(this, ct, "f").getProcessArgvBin() === v(this, ct, "f").getEnv("_") && (e2 = v(this, ct, "f").getEnv("_").replace(`${v(this, ct, "f").path.dirname(v(this, ct, "f").process.execPath())}/`, "")), e2;
  }
  [Mt]() {
    return v(this, it, "f");
  }
  [_t]() {
    return v(this, gt, "f");
  }
  [kt]() {
    if (!v(this, G, "f"))
      return;
    const t2 = v(this, ct, "f").getEnv("LC_ALL") || v(this, ct, "f").getEnv("LC_MESSAGES") || v(this, ct, "f").getEnv("LANG") || v(this, ct, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(t2.replace(/[.:].*/, ""));
  }
  [xt]() {
    return this[At]().version || "unknown";
  }
  [Et](t2) {
    const e2 = t2["--"] ? t2["--"] : t2._;
    for (let t3, s2 = 0; void 0 !== (t3 = e2[s2]); s2++)
      v(this, ct, "f").Parser.looksLikeNumber(t3) && Number.isSafeInteger(Math.floor(parseFloat(`${t3}`))) && (e2[s2] = Number(t3));
    return t2;
  }
  [At](t2) {
    const e2 = t2 || "*";
    if (v(this, ot, "f")[e2])
      return v(this, ot, "f")[e2];
    let s2 = {};
    try {
      let e3 = t2 || v(this, ct, "f").mainFilename;
      !t2 && v(this, ct, "f").path.extname(e3) && (e3 = v(this, ct, "f").path.dirname(e3));
      const i2 = v(this, ct, "f").findUp(e3, (t3, e4) => e4.includes("package.json") ? "package.json" : void 0);
      d(i2, void 0, v(this, ct, "f")), s2 = JSON.parse(v(this, ct, "f").readFileSync(i2, "utf8"));
    } catch (t3) {
    }
    return v(this, ot, "f")[e2] = s2 || {}, v(this, ot, "f")[e2];
  }
  [Pt](t2, e2) {
    (e2 = [].concat(e2)).forEach((e3) => {
      e3 = this[Dt](e3), v(this, et, "f")[t2].push(e3);
    });
  }
  [St](t2, e2, s2, i2) {
    this[It](t2, e2, s2, i2, (t3, e3, s3) => {
      v(this, et, "f")[t3][e3] = s3;
    });
  }
  [$t](t2, e2, s2, i2) {
    this[It](t2, e2, s2, i2, (t3, e3, s3) => {
      v(this, et, "f")[t3][e3] = (v(this, et, "f")[t3][e3] || []).concat(s3);
    });
  }
  [It](t2, e2, s2, i2, n2) {
    if (Array.isArray(s2))
      s2.forEach((e3) => {
        t2(e3, i2);
      });
    else if (((t3) => "object" == typeof t3)(s2))
      for (const e3 of p(s2))
        t2(e3, s2[e3]);
    else
      n2(e2, this[Dt](s2), i2);
  }
  [Dt](t2) {
    return "__proto__" === t2 ? "___proto___" : t2;
  }
  [Nt](t2, e2) {
    return this[St](this[Nt].bind(this), "key", t2, e2), this;
  }
  [Ht]() {
    var t2, e2, s2, i2, n2, r2, o2, a2, h2, l2, c2, f2;
    const u2 = v(this, B, "f").pop();
    let p2;
    d(u2, void 0, v(this, ct, "f")), t2 = this, e2 = this, s2 = this, i2 = this, n2 = this, r2 = this, o2 = this, a2 = this, h2 = this, l2 = this, c2 = this, f2 = this, { options: { set value(e3) {
      O(t2, et, e3, "f");
    } }.value, configObjects: p2, exitProcess: { set value(t3) {
      O(e2, T, t3, "f");
    } }.value, groups: { set value(t3) {
      O(s2, K, t3, "f");
    } }.value, output: { set value(t3) {
      O(i2, tt, t3, "f");
    } }.value, exitError: { set value(t3) {
      O(n2, V, t3, "f");
    } }.value, hasOutput: { set value(t3) {
      O(r2, J, t3, "f");
    } }.value, parsed: this.parsed, strict: { set value(t3) {
      O(o2, ft, t3, "f");
    } }.value, strictCommands: { set value(t3) {
      O(a2, dt, t3, "f");
    } }.value, strictOptions: { set value(t3) {
      O(h2, ut, t3, "f");
    } }.value, completionCommand: { set value(t3) {
      O(l2, F, t3, "f");
    } }.value, parseFn: { set value(t3) {
      O(c2, nt, t3, "f");
    } }.value, parseContext: { set value(t3) {
      O(f2, rt, t3, "f");
    } }.value } = u2, v(this, et, "f").configObjects = p2, v(this, pt, "f").unfreeze(), v(this, yt, "f").unfreeze(), v(this, z, "f").unfreeze(), v(this, Y, "f").unfreeze();
  }
  [zt](t2, e2) {
    return j(e2, (e3) => (t2(e3), e3));
  }
  getInternalMethods() {
    return { getCommandInstance: this[Wt].bind(this), getContext: this[qt].bind(this), getHasOutput: this[Ut].bind(this), getLoggerInstance: this[Ft].bind(this), getParseContext: this[Lt].bind(this), getParserConfiguration: this[Mt].bind(this), getUsageConfiguration: this[_t].bind(this), getUsageInstance: this[Vt].bind(this), getValidationInstance: this[Gt].bind(this), hasParseCallback: this[Rt].bind(this), isGlobalContext: this[Tt].bind(this), postProcess: this[Bt].bind(this), reset: this[Kt].bind(this), runValidation: this[Zt].bind(this), runYargsParserAndExecuteCommands: this[Jt].bind(this), setHasOutput: this[Xt].bind(this) };
  }
  [Wt]() {
    return v(this, z, "f");
  }
  [qt]() {
    return v(this, q, "f");
  }
  [Ut]() {
    return v(this, J, "f");
  }
  [Ft]() {
    return v(this, Q, "f");
  }
  [Lt]() {
    return v(this, rt, "f") || {};
  }
  [Vt]() {
    return v(this, pt, "f");
  }
  [Gt]() {
    return v(this, yt, "f");
  }
  [Rt]() {
    return !!v(this, nt, "f");
  }
  [Tt]() {
    return v(this, X, "f");
  }
  [Bt](t2, e2, s2, i2) {
    if (s2)
      return t2;
    if (f(t2))
      return t2;
    e2 || (t2 = this[bt](t2));
    return (this[Mt]()["parse-positional-numbers"] || void 0 === this[Mt]()["parse-positional-numbers"]) && (t2 = this[Et](t2)), i2 && (t2 = C(t2, this, v(this, Y, "f").getMiddleware(), false)), t2;
  }
  [Kt](t2 = {}) {
    O(this, et, v(this, et, "f") || {}, "f");
    const e2 = {};
    e2.local = v(this, et, "f").local || [], e2.configObjects = v(this, et, "f").configObjects || [];
    const s2 = {};
    e2.local.forEach((e3) => {
      s2[e3] = true, (t2[e3] || []).forEach((t3) => {
        s2[t3] = true;
      });
    }), Object.assign(v(this, at, "f"), Object.keys(v(this, K, "f")).reduce((t3, e3) => {
      const i2 = v(this, K, "f")[e3].filter((t4) => !(t4 in s2));
      return i2.length > 0 && (t3[e3] = i2), t3;
    }, {})), O(this, K, {}, "f");
    return ["array", "boolean", "string", "skipValidation", "count", "normalize", "number", "hiddenOptions"].forEach((t3) => {
      e2[t3] = (v(this, et, "f")[t3] || []).filter((t4) => !s2[t4]);
    }), ["narg", "key", "alias", "default", "defaultDescription", "config", "choices", "demandedOptions", "demandedCommands", "deprecatedOptions"].forEach((t3) => {
      e2[t3] = g(v(this, et, "f")[t3], (t4) => !s2[t4]);
    }), e2.envPrefix = v(this, et, "f").envPrefix, O(this, et, e2, "f"), O(this, pt, v(this, pt, "f") ? v(this, pt, "f").reset(s2) : P(this, v(this, ct, "f")), "f"), O(this, yt, v(this, yt, "f") ? v(this, yt, "f").reset(s2) : function(t3, e3, s3) {
      const i2 = s3.y18n.__, n2 = s3.y18n.__n, r2 = { nonOptionCount: function(s4) {
        const i3 = t3.getDemandedCommands(), r3 = s4._.length + (s4["--"] ? s4["--"].length : 0) - t3.getInternalMethods().getContext().commands.length;
        i3._ && (r3 < i3._.min || r3 > i3._.max) && (r3 < i3._.min ? void 0 !== i3._.minMsg ? e3.fail(i3._.minMsg ? i3._.minMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.min.toString()) : null) : e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", r3, r3.toString(), i3._.min.toString())) : r3 > i3._.max && (void 0 !== i3._.maxMsg ? e3.fail(i3._.maxMsg ? i3._.maxMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.max.toString()) : null) : e3.fail(n2("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", r3, r3.toString(), i3._.max.toString()))));
      }, positionalCount: function(t4, s4) {
        s4 < t4 && e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", s4, s4 + "", t4 + ""));
      }, requiredArguments: function(t4, s4) {
        let i3 = null;
        for (const e4 of Object.keys(s4))
          Object.prototype.hasOwnProperty.call(t4, e4) && void 0 !== t4[e4] || (i3 = i3 || {}, i3[e4] = s4[e4]);
        if (i3) {
          const t5 = [];
          for (const e4 of Object.keys(i3)) {
            const s6 = i3[e4];
            s6 && t5.indexOf(s6) < 0 && t5.push(s6);
          }
          const s5 = t5.length ? `
${t5.join("\n")}` : "";
          e3.fail(n2("Missing required argument: %s", "Missing required arguments: %s", Object.keys(i3).length, Object.keys(i3).join(", ") + s5));
        }
      }, unknownArguments: function(s4, i3, o3, a3, h2 = true) {
        var l3;
        const c3 = t3.getInternalMethods().getCommandInstance().getCommands(), f2 = [], d2 = t3.getInternalMethods().getContext();
        if (Object.keys(s4).forEach((e4) => {
          H.includes(e4) || Object.prototype.hasOwnProperty.call(o3, e4) || Object.prototype.hasOwnProperty.call(t3.getInternalMethods().getParseContext(), e4) || r2.isValidAndSomeAliasIsNotNew(e4, i3) || f2.push(e4);
        }), h2 && (d2.commands.length > 0 || c3.length > 0 || a3) && s4._.slice(d2.commands.length).forEach((t4) => {
          c3.includes("" + t4) || f2.push("" + t4);
        }), h2) {
          const e4 = (null === (l3 = t3.getDemandedCommands()._) || void 0 === l3 ? void 0 : l3.max) || 0, i4 = d2.commands.length + e4;
          i4 < s4._.length && s4._.slice(i4).forEach((t4) => {
            t4 = String(t4), d2.commands.includes(t4) || f2.includes(t4) || f2.push(t4);
          });
        }
        f2.length && e3.fail(n2("Unknown argument: %s", "Unknown arguments: %s", f2.length, f2.map((t4) => t4.trim() ? t4 : `"${t4}"`).join(", ")));
      }, unknownCommands: function(s4) {
        const i3 = t3.getInternalMethods().getCommandInstance().getCommands(), r3 = [], o3 = t3.getInternalMethods().getContext();
        return (o3.commands.length > 0 || i3.length > 0) && s4._.slice(o3.commands.length).forEach((t4) => {
          i3.includes("" + t4) || r3.push("" + t4);
        }), r3.length > 0 && (e3.fail(n2("Unknown command: %s", "Unknown commands: %s", r3.length, r3.join(", "))), true);
      }, isValidAndSomeAliasIsNotNew: function(e4, s4) {
        if (!Object.prototype.hasOwnProperty.call(s4, e4))
          return false;
        const i3 = t3.parsed.newAliases;
        return [e4, ...s4[e4]].some((t4) => !Object.prototype.hasOwnProperty.call(i3, t4) || !i3[e4]);
      }, limitedChoices: function(s4) {
        const n3 = t3.getOptions(), r3 = {};
        if (!Object.keys(n3.choices).length)
          return;
        Object.keys(s4).forEach((t4) => {
          -1 === H.indexOf(t4) && Object.prototype.hasOwnProperty.call(n3.choices, t4) && [].concat(s4[t4]).forEach((e4) => {
            -1 === n3.choices[t4].indexOf(e4) && void 0 !== e4 && (r3[t4] = (r3[t4] || []).concat(e4));
          });
        });
        const o3 = Object.keys(r3);
        if (!o3.length)
          return;
        let a3 = i2("Invalid values:");
        o3.forEach((t4) => {
          a3 += `
  ${i2("Argument: %s, Given: %s, Choices: %s", t4, e3.stringifiedValues(r3[t4]), e3.stringifiedValues(n3.choices[t4]))}`;
        }), e3.fail(a3);
      } };
      let o2 = {};
      function a2(t4, e4) {
        const s4 = Number(e4);
        return "number" == typeof (e4 = isNaN(s4) ? e4 : s4) ? e4 = t4._.length >= e4 : e4.match(/^--no-.+/) ? (e4 = e4.match(/^--no-(.+)/)[1], e4 = !Object.prototype.hasOwnProperty.call(t4, e4)) : e4 = Object.prototype.hasOwnProperty.call(t4, e4), e4;
      }
      r2.implies = function(e4, i3) {
        h("<string|object> [array|number|string]", [e4, i3], arguments.length), "object" == typeof e4 ? Object.keys(e4).forEach((t4) => {
          r2.implies(t4, e4[t4]);
        }) : (t3.global(e4), o2[e4] || (o2[e4] = []), Array.isArray(i3) ? i3.forEach((t4) => r2.implies(e4, t4)) : (d(i3, void 0, s3), o2[e4].push(i3)));
      }, r2.getImplied = function() {
        return o2;
      }, r2.implications = function(t4) {
        const s4 = [];
        if (Object.keys(o2).forEach((e4) => {
          const i3 = e4;
          (o2[e4] || []).forEach((e5) => {
            let n3 = i3;
            const r3 = e5;
            n3 = a2(t4, n3), e5 = a2(t4, e5), n3 && !e5 && s4.push(` ${i3} -> ${r3}`);
          });
        }), s4.length) {
          let t5 = `${i2("Implications failed:")}
`;
          s4.forEach((e4) => {
            t5 += e4;
          }), e3.fail(t5);
        }
      };
      let l2 = {};
      r2.conflicts = function(e4, s4) {
        h("<string|object> [array|string]", [e4, s4], arguments.length), "object" == typeof e4 ? Object.keys(e4).forEach((t4) => {
          r2.conflicts(t4, e4[t4]);
        }) : (t3.global(e4), l2[e4] || (l2[e4] = []), Array.isArray(s4) ? s4.forEach((t4) => r2.conflicts(e4, t4)) : l2[e4].push(s4));
      }, r2.getConflicting = () => l2, r2.conflicting = function(n3) {
        Object.keys(n3).forEach((t4) => {
          l2[t4] && l2[t4].forEach((s4) => {
            s4 && void 0 !== n3[t4] && void 0 !== n3[s4] && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, s4));
          });
        }), t3.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l2).forEach((t4) => {
          l2[t4].forEach((r3) => {
            r3 && void 0 !== n3[s3.Parser.camelCase(t4)] && void 0 !== n3[s3.Parser.camelCase(r3)] && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, r3));
          });
        });
      }, r2.recommendCommands = function(t4, s4) {
        s4 = s4.sort((t5, e4) => e4.length - t5.length);
        let n3 = null, r3 = 1 / 0;
        for (let e4, i3 = 0; void 0 !== (e4 = s4[i3]); i3++) {
          const s5 = N(t4, e4);
          s5 <= 3 && s5 < r3 && (r3 = s5, n3 = e4);
        }
        n3 && e3.fail(i2("Did you mean %s?", n3));
      }, r2.reset = function(t4) {
        return o2 = g(o2, (e4) => !t4[e4]), l2 = g(l2, (e4) => !t4[e4]), r2;
      };
      const c2 = [];
      return r2.freeze = function() {
        c2.push({ implied: o2, conflicting: l2 });
      }, r2.unfreeze = function() {
        const t4 = c2.pop();
        d(t4, void 0, s3), { implied: o2, conflicting: l2 } = t4;
      }, r2;
    }(this, v(this, pt, "f"), v(this, ct, "f")), "f"), O(this, z, v(this, z, "f") ? v(this, z, "f").reset() : function(t3, e3, s3, i2) {
      return new _(t3, e3, s3, i2);
    }(v(this, pt, "f"), v(this, yt, "f"), v(this, Y, "f"), v(this, ct, "f")), "f"), v(this, U, "f") || O(this, U, function(t3, e3, s3, i2) {
      return new D(t3, e3, s3, i2);
    }(this, v(this, pt, "f"), v(this, z, "f"), v(this, ct, "f")), "f"), v(this, Y, "f").reset(), O(this, F, null, "f"), O(this, tt, "", "f"), O(this, V, null, "f"), O(this, J, false, "f"), this.parsed = false, this;
  }
  [Yt](t2, e2) {
    return v(this, ct, "f").path.relative(t2, e2);
  }
  [Jt](t2, s2, i2, n2 = 0, r2 = false) {
    let o2 = !!i2 || r2;
    t2 = t2 || v(this, ht, "f"), v(this, et, "f").__ = v(this, ct, "f").y18n.__, v(this, et, "f").configuration = this[Mt]();
    const a2 = !!v(this, et, "f").configuration["populate--"], h2 = Object.assign({}, v(this, et, "f").configuration, { "populate--": true }), l2 = v(this, ct, "f").Parser.detailed(t2, Object.assign({}, v(this, et, "f"), { configuration: { "parse-positional-numbers": false, ...h2 } })), c2 = Object.assign(l2.argv, v(this, rt, "f"));
    let d2;
    const u2 = l2.aliases;
    let p2 = false, g2 = false;
    Object.keys(c2).forEach((t3) => {
      t3 === v(this, Z, "f") && c2[t3] ? p2 = true : t3 === v(this, mt, "f") && c2[t3] && (g2 = true);
    }), c2.$0 = this.$0, this.parsed = l2, 0 === n2 && v(this, pt, "f").clearCachedHelpMessage();
    try {
      if (this[kt](), s2)
        return this[Bt](c2, a2, !!i2, false);
      if (v(this, Z, "f")) {
        [v(this, Z, "f")].concat(u2[v(this, Z, "f")] || []).filter((t3) => t3.length > 1).includes("" + c2._[c2._.length - 1]) && (c2._.pop(), p2 = true);
      }
      O(this, X, false, "f");
      const h3 = v(this, z, "f").getCommands(), m2 = v(this, U, "f").completionKey in c2, y2 = p2 || m2 || r2;
      if (c2._.length) {
        if (h3.length) {
          let t3;
          for (let e2, s3 = n2 || 0; void 0 !== c2._[s3]; s3++) {
            if (e2 = String(c2._[s3]), h3.includes(e2) && e2 !== v(this, F, "f")) {
              const t4 = v(this, z, "f").runCommand(e2, this, l2, s3 + 1, r2, p2 || g2 || r2);
              return this[Bt](t4, a2, !!i2, false);
            }
            if (!t3 && e2 !== v(this, F, "f")) {
              t3 = e2;
              break;
            }
          }
          !v(this, z, "f").hasDefaultCommand() && v(this, lt, "f") && t3 && !y2 && v(this, yt, "f").recommendCommands(t3, h3);
        }
        v(this, F, "f") && c2._.includes(v(this, F, "f")) && !m2 && (v(this, T, "f") && E(true), this.showCompletionScript(), this.exit(0));
      }
      if (v(this, z, "f").hasDefaultCommand() && !y2) {
        const t3 = v(this, z, "f").runCommand(null, this, l2, 0, r2, p2 || g2 || r2);
        return this[Bt](t3, a2, !!i2, false);
      }
      if (m2) {
        v(this, T, "f") && E(true);
        const s3 = (t2 = [].concat(t2)).slice(t2.indexOf(`--${v(this, U, "f").completionKey}`) + 1);
        return v(this, U, "f").getCompletion(s3, (t3, s4) => {
          if (t3)
            throw new e(t3.message);
          (s4 || []).forEach((t4) => {
            v(this, Q, "f").log(t4);
          }), this.exit(0);
        }), this[Bt](c2, !a2, !!i2, false);
      }
      if (v(this, J, "f") || (p2 ? (v(this, T, "f") && E(true), o2 = true, this.showHelp("log"), this.exit(0)) : g2 && (v(this, T, "f") && E(true), o2 = true, v(this, pt, "f").showVersion("log"), this.exit(0))), !o2 && v(this, et, "f").skipValidation.length > 0 && (o2 = Object.keys(c2).some((t3) => v(this, et, "f").skipValidation.indexOf(t3) >= 0 && true === c2[t3])), !o2) {
        if (l2.error)
          throw new e(l2.error.message);
        if (!m2) {
          const t3 = this[Zt](u2, {}, l2.error);
          i2 || (d2 = C(c2, this, v(this, Y, "f").getMiddleware(), true)), d2 = this[zt](t3, null != d2 ? d2 : c2), f(d2) && !i2 && (d2 = d2.then(() => C(c2, this, v(this, Y, "f").getMiddleware(), false)));
        }
      }
    } catch (t3) {
      if (!(t3 instanceof e))
        throw t3;
      v(this, pt, "f").fail(t3.message, t3);
    }
    return this[Bt](null != d2 ? d2 : c2, a2, !!i2, true);
  }
  [Zt](t2, s2, i2, n2) {
    const r2 = { ...this.getDemandedOptions() };
    return (o2) => {
      if (i2)
        throw new e(i2.message);
      v(this, yt, "f").nonOptionCount(o2), v(this, yt, "f").requiredArguments(o2, r2);
      let a2 = false;
      v(this, dt, "f") && (a2 = v(this, yt, "f").unknownCommands(o2)), v(this, ft, "f") && !a2 ? v(this, yt, "f").unknownArguments(o2, t2, s2, !!n2) : v(this, ut, "f") && v(this, yt, "f").unknownArguments(o2, t2, {}, false, false), v(this, yt, "f").limitedChoices(o2), v(this, yt, "f").implications(o2), v(this, yt, "f").conflicting(o2);
    };
  }
  [Xt]() {
    O(this, J, true, "f");
  }
  [Qt](t2) {
    if ("string" == typeof t2)
      v(this, et, "f").key[t2] = true;
    else
      for (const e2 of t2)
        v(this, et, "f").key[e2] = true;
  }
}
var ee, se;
const { readFileSync: ie } = require$$1, { inspect: ne } = util, { resolve: re } = requirePathBrowserify(), oe = requireBuild$2(), ae = requireBuild$1();
var he, le = { assert: { notStrictEqual: t.notStrictEqual, strictEqual: t.strictEqual }, cliui: requireBuild(), findUp: requireSync(), getEnv: (t2) => dist.process.env[t2], getCallerFile: requireGetCallerFile(), getProcessArgvBin: y$1, inspect: ne, mainFilename: null !== (se = null === (ee = null === commonjsRequire || void 0 === commonjsRequire ? void 0 : require.main) || void 0 === ee ? void 0 : ee.filename) && void 0 !== se ? se : dist.process.cwd(), Parser: ae, path: requirePathBrowserify(), process: { argv: () => dist.process.argv, cwd: dist.process.cwd, emitWarning: (t2, e2) => dist.process.emitWarning(t2, e2), execPath: () => dist.process.execPath, exit: (t2) => {
  dist.process.exit(t2);
}, nextTick: dist.process.nextTick, stdColumns: void 0 !== dist.process.stdout.columns ? dist.process.stdout.columns : null }, readFileSync: ie, require: commonjsRequire, requireDirectory: requireRequireDirectory(), stringWidth: requireStringWidth(), y18n: oe({ directory: re(__dirname, "../locales"), updateFiles: false }) };
const ce = (null === (he = null === dist.process || void 0 === dist.process ? void 0 : dist.process.env) || void 0 === he ? void 0 : he.YARGS_MIN_NODE_VERSION) ? Number(dist.process.env.YARGS_MIN_NODE_VERSION) : 12;
if (dist.process && dist.process.version) {
  if (Number(dist.process.version.match(/v([^.]+)/)[1]) < ce)
    throw Error(`yargs supports a minimum Node.js version of ${ce}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
}
const fe = requireBuild$1();
var de, ue = { applyExtends: n, cjsPlatformShim: le, Yargs: (de = le, (t2 = [], e2 = de.process.cwd(), s2) => {
  const i2 = new te(t2, e2, s2, de);
  return Object.defineProperty(i2, "argv", { get: () => i2.parse(), enumerable: true }), i2.help(), i2.version(), i2;
}), argsert: h, isPromise: f, objFilter: g, parseCommand: o, Parser: fe, processArgv: b, YError: e };
var build = ue;
const pkg = /* @__PURE__ */ getDefaultExportFromCjs(build);
const { applyExtends, cjsPlatformShim, Parser: Parser2, processArgv, Yargs } = pkg;
Yargs.applyExtends = (config, cwd2, mergeExtends) => {
  return applyExtends(config, cwd2, mergeExtends, cjsPlatformShim);
};
Yargs.hideBin = processArgv.hideBin;
Yargs.Parser = Parser2;
const y = Yargs(dist.process.argv.slice(2)).string("input-css").string("input-html").string("output-css").string("output-html").string("tailwind-config").string("reset").describe("input-css", "The path to your custom CSS file").describe("input-html", "The path to your input HTML file").describe("output-css", "The path to the CSS file that will be generated").describe("output-html", "The path to the inlined HTML file that will be generated").describe("tailwind-config", "The path to your custom Tailwind config file").describe("reset", "Set to `false` to disable extended resets");
const main = async () => {
  const argv = await y.argv;
  const inputHtmlPath = argv["input-html"];
  const outputHtmlPath = argv["output-html"];
  const inputCssPath = argv["input-css"];
  const outputCssPath = argv["output-css"];
  const tailwindConfigPath = argv["tailwind-config"];
  const reset = argv["reset"];
  if (inputHtmlPath == null) {
    console.log("The --input-html option is required.");
    return;
  }
  if (outputCssPath == null && outputHtmlPath == null) {
    console.log("Either --output-css or --output-html options must be specified.");
    return;
  }
  const inputHtml = empty$5.readFileSync(inputHtmlPath, "utf-8");
  const options2 = {
    css: inputCssPath != null ? empty$5.readFileSync(inputCssPath, "utf-8") : void 0,
    tailwindConfigPath,
    reset: reset === "false" ? false : true
  };
  const output = await mailwindCss(inputHtml, options2);
  if (output == null) {
    console.log("Failed to generate output.");
    return;
  }
  const { html: html2, css: css2 } = output;
  if (outputHtmlPath != null) {
    empty$5.writeFileSync(outputHtmlPath, html2);
  }
  if (outputCssPath != null) {
    empty$5.writeFileSync(outputCssPath, css2);
  }
};
main().catch((error) => {
  console.error(error);
  dist.process.exit(1);
});
//# sourceMappingURL=mailwind.cjs.map
